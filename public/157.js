(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[157],{

/***/ "./node_modules/vue-hotel-datepicker/dist/vueHotelDatepicker.common.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vue-hotel-datepicker/dist/vueHotelDatepicker.common.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"38c1\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"01ed\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\n\n// `Number.isNaN` method\n// https://tc39.es/ecma262/#sec-number.isnan\n$({ target: 'Number', stat: true }, {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number != number;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"01f9\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable es/no-object-getownpropertynames -- safe */\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar $getOwnPropertyNames = __webpack_require__(\"04a4\").f;\n\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return $getOwnPropertyNames(it);\n  } catch (error) {\n    return windowNames.slice();\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]'\n    ? getWindowNames(it)\n    : $getOwnPropertyNames(toIndexedObject(it));\n};\n\n\n/***/ }),\n\n/***/ \"02df\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = __webpack_require__(\"d2ef\");\nvar fails = __webpack_require__(\"56fb\");\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n\n/***/ }),\n\n/***/ \"0308\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"d8fc\")))\n\n/***/ }),\n\n/***/ \"04a4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(\"04fd\");\nvar enumBugKeys = __webpack_require__(\"2294\");\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n\n\n/***/ }),\n\n/***/ \"04c1\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// `Symbol.prototype.description` getter\n// https://tc39.es/ecma262/#sec-symbol.prototype.description\n\nvar $ = __webpack_require__(\"9ef3\");\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar global = __webpack_require__(\"0308\");\nvar has = __webpack_require__(\"c5cf\");\nvar isObject = __webpack_require__(\"74df\");\nvar defineProperty = __webpack_require__(\"cea8\").f;\nvar copyConstructorProperties = __webpack_require__(\"4187\");\n\nvar NativeSymbol = global.Symbol;\n\nif (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||\n  // Safari 12 bug\n  NativeSymbol().description !== undefined\n)) {\n  var EmptyStringDescriptionStore = {};\n  // wrap Symbol constructor for correct work with undefined description\n  var SymbolWrapper = function Symbol() {\n    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var result = this instanceof SymbolWrapper\n      ? new NativeSymbol(description)\n      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'\n      : description === undefined ? NativeSymbol() : NativeSymbol(description);\n    if (description === '') EmptyStringDescriptionStore[result] = true;\n    return result;\n  };\n  copyConstructorProperties(SymbolWrapper, NativeSymbol);\n  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n  symbolPrototype.constructor = SymbolWrapper;\n\n  var symbolToString = symbolPrototype.toString;\n  var native = String(NativeSymbol('test')) == 'Symbol(test)';\n  var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n  defineProperty(symbolPrototype, 'description', {\n    configurable: true,\n    get: function description() {\n      var symbol = isObject(this) ? this.valueOf() : this;\n      var string = symbolToString.call(symbol);\n      if (has(EmptyStringDescriptionStore, symbol)) return '';\n      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');\n      return desc === '' ? undefined : desc;\n    }\n  });\n\n  $({ global: true, forced: true }, {\n    Symbol: SymbolWrapper\n  });\n}\n\n\n/***/ }),\n\n/***/ \"04fd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"c5cf\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar indexOf = __webpack_require__(\"a08f\").indexOf;\nvar hiddenKeys = __webpack_require__(\"a95c\");\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"093a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(\"7e6f\");\nvar classofRaw = __webpack_require__(\"c4d8\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n};\n\n\n/***/ }),\n\n/***/ \"09eb\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar DOMIterables = __webpack_require__(\"f635\");\nvar forEach = __webpack_require__(\"d08c\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  // some Chrome versions have non-configurable methods on DOMTokenList\n  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);\n  } catch (error) {\n    CollectionPrototype.forEach = forEach;\n  }\n}\n\n\n/***/ }),\n\n/***/ \"0c45\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\nvar classof = __webpack_require__(\"c4d8\");\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n\n/***/ }),\n\n/***/ \"0fc4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(\"4430\");\nvar getOwnPropertyNamesModule = __webpack_require__(\"04a4\");\nvar getOwnPropertySymbolsModule = __webpack_require__(\"6aa2\");\nvar anObject = __webpack_require__(\"f65e\");\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n\n/***/ }),\n\n/***/ \"1078\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toPrimitive = __webpack_require__(\"4b1c\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\nvar createPropertyDescriptor = __webpack_require__(\"bd06\");\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n\n\n/***/ }),\n\n/***/ \"1083\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar fails = __webpack_require__(\"56fb\");\nvar isArray = __webpack_require__(\"bdc6\");\nvar isObject = __webpack_require__(\"74df\");\nvar toObject = __webpack_require__(\"a50e\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar createProperty = __webpack_require__(\"1078\");\nvar arraySpeciesCreate = __webpack_require__(\"3f78\");\nvar arrayMethodHasSpeciesSupport = __webpack_require__(\"d7e4\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar V8_VERSION = __webpack_require__(\"d2ef\");\n\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';\n\n// We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\n\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray(O);\n};\n\nvar FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n\n// `Array.prototype.concat` method\n// https://tc39.es/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  concat: function concat(arg) {\n    var O = toObject(this);\n    var A = arraySpeciesCreate(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = toLength(E.length);\n        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);\n      } else {\n        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n        createProperty(A, n++, E);\n      }\n    }\n    A.length = n;\n    return A;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"12da\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"c4d8\");\n\n// `thisNumberValue` abstract operation\n// https://tc39.es/ecma262/#sec-thisnumbervalue\nmodule.exports = function (value) {\n  if (typeof value != 'number' && classof(value) != 'Number') {\n    throw TypeError('Incorrect invocation');\n  }\n  return +value;\n};\n\n\n/***/ }),\n\n/***/ \"1517\":\n/***/ (function(module, exports) {\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n\n\n/***/ }),\n\n/***/ \"1b3b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar defineProperty = __webpack_require__(\"cea8\").f;\nvar create = __webpack_require__(\"ca23\");\nvar redefineAll = __webpack_require__(\"92c9\");\nvar bind = __webpack_require__(\"6c7b\");\nvar anInstance = __webpack_require__(\"5bd7\");\nvar iterate = __webpack_require__(\"c64b\");\nvar defineIterator = __webpack_require__(\"ed54\");\nvar setSpecies = __webpack_require__(\"790d\");\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar fastKey = __webpack_require__(\"4a9f\").fastKey;\nvar InternalStateModule = __webpack_require__(\"fb59\");\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\n\nmodule.exports = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var C = wrapper(function (that, iterable) {\n      anInstance(that, C, CONSTRUCTOR_NAME);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS) that.size = 0;\n      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== 'F') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key == key) return entry;\n      }\n    };\n\n    redefineAll(C.prototype, {\n      // `{ Map, Set }.prototype.clear()` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.clear\n      // https://tc39.es/ecma262/#sec-set.prototype.clear\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS) state.size = 0;\n        else that.size = 0;\n      },\n      // `{ Map, Set }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.delete\n      // https://tc39.es/ecma262/#sec-set.prototype.delete\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first == entry) state.first = next;\n          if (state.last == entry) state.last = prev;\n          if (DESCRIPTORS) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.foreach\n      // https://tc39.es/ecma262/#sec-set.prototype.foreach\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // `{ Map, Set}.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.has\n      // https://tc39.es/ecma262/#sec-set.prototype.has\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    redefineAll(C.prototype, IS_MAP ? {\n      // `Map.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.get\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // `Map.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.set\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // `Set.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-set.prototype.add\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return C;\n  },\n  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods\n    // https://tc39.es/ecma262/#sec-map.prototype.entries\n    // https://tc39.es/ecma262/#sec-map.prototype.keys\n    // https://tc39.es/ecma262/#sec-map.prototype.values\n    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator\n    // https://tc39.es/ecma262/#sec-set.prototype.entries\n    // https://tc39.es/ecma262/#sec-set.prototype.keys\n    // https://tc39.es/ecma262/#sec-set.prototype.values\n    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator\n    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return { value: undefined, done: true };\n      }\n      // return step by kind\n      if (kind == 'keys') return { value: entry.key, done: false };\n      if (kind == 'values') return { value: entry.value, done: false };\n      return { value: [entry.key, entry.value], done: false };\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // `{ Map, Set }.prototype[@@species]` accessors\n    // https://tc39.es/ecma262/#sec-get-map-@@species\n    // https://tc39.es/ecma262/#sec-get-set-@@species\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n\n\n/***/ }),\n\n/***/ \"1cf5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"c5cf\");\nvar toObject = __webpack_require__(\"a50e\");\nvar sharedKey = __webpack_require__(\"7531\");\nvar CORRECT_PROTOTYPE_GETTER = __webpack_require__(\"2f47\");\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectPrototype : null;\n};\n\n\n/***/ }),\n\n/***/ \"1ddd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\nvar anObject = __webpack_require__(\"f65e\");\nvar objectKeys = __webpack_require__(\"3692\");\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"20ed\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar store = __webpack_require__(\"389c\");\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (typeof store.inspectSource != 'function') {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n\n\n/***/ }),\n\n/***/ \"2294\":\n/***/ (function(module, exports) {\n\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\n\n/***/ }),\n\n/***/ \"240a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar exec = __webpack_require__(\"43c6\");\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {\n  exec: exec\n});\n\n\n/***/ }),\n\n/***/ \"2547\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(\"4430\");\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n\n/***/ }),\n\n/***/ \"254f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar path = __webpack_require__(\"7148\");\nvar has = __webpack_require__(\"c5cf\");\nvar wrappedWellKnownSymbolModule = __webpack_require__(\"5a6c\");\nvar defineProperty = __webpack_require__(\"cea8\").f;\n\nmodule.exports = function (NAME) {\n  var Symbol = path.Symbol || (path.Symbol = {});\n  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {\n    value: wrappedWellKnownSymbolModule.f(NAME)\n  });\n};\n\n\n/***/ }),\n\n/***/ \"2627\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\nvar classof = __webpack_require__(\"c4d8\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar MATCH = wellKnownSymbol('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n\n\n/***/ }),\n\n/***/ \"292f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n__webpack_require__(\"240a\");\nvar redefine = __webpack_require__(\"4827\");\nvar regexpExec = __webpack_require__(\"43c6\");\nvar fails = __webpack_require__(\"56fb\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\n\nvar SPECIES = wellKnownSymbol('species');\nvar RegExpPrototype = RegExp.prototype;\n\nmodule.exports = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var $exec = regexp.exec;\n      if ($exec === regexpExec || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n        }\n        return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    redefine(String.prototype, KEY, methods[0]);\n    redefine(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\n\n/***/ }),\n\n/***/ \"29d2\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\nmodule.exports = fails(function () {\n  // babel-minify transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\n  var re = RegExp('.', (typeof '').charAt(0));\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\n\n/***/ }),\n\n/***/ \"2a81\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"c25b\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\n\n// `String.prototype.{ codePointAt, at }` methods implementation\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = String(requireObjectCoercible($this));\n    var position = toInteger(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = S.charCodeAt(position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING ? S.charAt(position) : first\n        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\n\n/***/ }),\n\n/***/ \"2b60\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar collection = __webpack_require__(\"eda8\");\nvar collectionStrong = __webpack_require__(\"1b3b\");\n\n// `Set` constructor\n// https://tc39.es/ecma262/#sec-set-objects\nmodule.exports = collection('Set', function (init) {\n  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\n\n/***/ }),\n\n/***/ \"2bb7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar DOMIterables = __webpack_require__(\"f635\");\nvar ArrayIteratorMethods = __webpack_require__(\"d453\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG]) {\n      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n}\n\n\n/***/ }),\n\n/***/ \"2f47\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\nmodule.exports = !fails(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n\n/***/ }),\n\n/***/ \"31c6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar getBuiltIn = __webpack_require__(\"4430\");\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n\n/***/ }),\n\n/***/ \"32da\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\nvar setPrototypeOf = __webpack_require__(\"a4df\");\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n\n\n/***/ }),\n\n/***/ \"3692\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar internalObjectKeys = __webpack_require__(\"04fd\");\nvar enumBugKeys = __webpack_require__(\"2294\");\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n\n\n/***/ }),\n\n/***/ \"37bb\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar global = __webpack_require__(\"0308\");\nvar getBuiltIn = __webpack_require__(\"4430\");\nvar IS_PURE = __webpack_require__(\"c783\");\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar NATIVE_SYMBOL = __webpack_require__(\"02df\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(\"4f9f\");\nvar fails = __webpack_require__(\"56fb\");\nvar has = __webpack_require__(\"c5cf\");\nvar isArray = __webpack_require__(\"bdc6\");\nvar isObject = __webpack_require__(\"74df\");\nvar anObject = __webpack_require__(\"f65e\");\nvar toObject = __webpack_require__(\"a50e\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar toPrimitive = __webpack_require__(\"4b1c\");\nvar createPropertyDescriptor = __webpack_require__(\"bd06\");\nvar nativeObjectCreate = __webpack_require__(\"ca23\");\nvar objectKeys = __webpack_require__(\"3692\");\nvar getOwnPropertyNamesModule = __webpack_require__(\"04a4\");\nvar getOwnPropertyNamesExternal = __webpack_require__(\"01f9\");\nvar getOwnPropertySymbolsModule = __webpack_require__(\"6aa2\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(\"aa86\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\nvar propertyIsEnumerableModule = __webpack_require__(\"b488\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar redefine = __webpack_require__(\"4827\");\nvar shared = __webpack_require__(\"7c40\");\nvar sharedKey = __webpack_require__(\"7531\");\nvar hiddenKeys = __webpack_require__(\"a95c\");\nvar uid = __webpack_require__(\"fc94\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar wrappedWellKnownSymbolModule = __webpack_require__(\"5a6c\");\nvar defineWellKnownSymbol = __webpack_require__(\"254f\");\nvar setToStringTag = __webpack_require__(\"496a\");\nvar InternalStateModule = __webpack_require__(\"fb59\");\nvar $forEach = __webpack_require__(\"5748\").forEach;\n\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE = 'prototype';\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(SYMBOL);\nvar ObjectPrototype = Object[PROTOTYPE];\nvar $Symbol = global.Symbol;\nvar $stringify = getBuiltIn('JSON', 'stringify');\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\nvar AllSymbols = shared('symbols');\nvar ObjectPrototypeSymbols = shared('op-symbols');\nvar StringToSymbolRegistry = shared('string-to-symbol-registry');\nvar SymbolToStringRegistry = shared('symbol-to-string-registry');\nvar WellKnownSymbolsStore = shared('wks');\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDescriptor = DESCRIPTORS && fails(function () {\n  return nativeObjectCreate(nativeDefineProperty({}, 'a', {\n    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n  nativeDefineProperty(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n  }\n} : nativeDefineProperty;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n  setInternalState(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!DESCRIPTORS) symbol.description = description;\n  return symbol;\n};\n\nvar isSymbol = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return Object(it) instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject(O);\n  var key = toPrimitive(P, true);\n  anObject(Attributes);\n  if (has(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n    } return setSymbolDescriptor(O, key, Attributes);\n  } return nativeDefineProperty(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject(O);\n  var properties = toIndexedObject(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach(keys, function (key) {\n    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPrimitive(V, true);\n  var enumerable = nativePropertyIsEnumerable.call(this, P);\n  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject(O);\n  var key = toPrimitive(P, true);\n  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n  var result = [];\n  $forEach(names, function (key) {\n    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n      result.push(AllSymbols[key]);\n    }\n  });\n  return result;\n};\n\n// `Symbol` constructor\n// https://tc39.es/ecma262/#sec-symbol-constructor\nif (!NATIVE_SYMBOL) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n    var tag = uid(description);\n    var setter = function (value) {\n      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n    };\n    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });\n    return wrap(tag, description);\n  };\n\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n\n  redefine($Symbol, 'withoutSetter', function (description) {\n    return wrap(uid(description), description);\n  });\n\n  propertyIsEnumerableModule.f = $propertyIsEnumerable;\n  definePropertyModule.f = $defineProperty;\n  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n\n  wrappedWellKnownSymbolModule.f = function (name) {\n    return wrap(wellKnownSymbol(name), name);\n  };\n\n  if (DESCRIPTORS) {\n    // https://github.com/tc39/proposal-Symbol-description\n    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n    if (!IS_PURE) {\n      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });\n    }\n  }\n}\n\n$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {\n  Symbol: $Symbol\n});\n\n$forEach(objectKeys(WellKnownSymbolsStore), function (name) {\n  defineWellKnownSymbol(name);\n});\n\n$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {\n  // `Symbol.for` method\n  // https://tc39.es/ecma262/#sec-symbol.for\n  'for': function (key) {\n    var string = String(key);\n    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = $Symbol(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry[symbol] = string;\n    return symbol;\n  },\n  // `Symbol.keyFor` method\n  // https://tc39.es/ecma262/#sec-symbol.keyfor\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');\n    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  },\n  useSetter: function () { USE_SETTER = true; },\n  useSimple: function () { USE_SETTER = false; }\n});\n\n$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {\n  // `Object.create` method\n  // https://tc39.es/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.es/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.es/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // `Object.getOwnPropertySymbols` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\n$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return getOwnPropertySymbolsModule.f(toObject(it));\n  }\n});\n\n// `JSON.stringify` method behavior with symbols\n// https://tc39.es/ecma262/#sec-json.stringify\nif ($stringify) {\n  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {\n    var symbol = $Symbol();\n    // MS Edge converts symbol values to JSON as {}\n    return $stringify([symbol]) != '[null]'\n      // WebKit converts symbol values to JSON as null\n      || $stringify({ a: symbol }) != '{}'\n      // V8 throws on boxed symbols\n      || $stringify(Object(symbol)) != '{}';\n  });\n\n  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    stringify: function stringify(it, replacer, space) {\n      var args = [it];\n      var index = 1;\n      var $replacer;\n      while (arguments.length > index) args.push(arguments[index++]);\n      $replacer = replacer;\n      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n      if (!isArray(replacer)) replacer = function (key, value) {\n        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n        if (!isSymbol(value)) return value;\n      };\n      args[1] = replacer;\n      return $stringify.apply(null, args);\n    }\n  });\n}\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\nif (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n}\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag($Symbol, SYMBOL);\n\nhiddenKeys[HIDDEN] = true;\n\n\n/***/ }),\n\n/***/ \"389c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar setGlobal = __webpack_require__(\"50d0\");\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n\n\n/***/ }),\n\n/***/ \"38c1\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"css\", function() { return /* reexport */ scss_default.a; });\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/@vue+cli-service@4.5.13_0f25d1aa8415e98c3e62a4178f3c555d/node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js\n// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var currentScript = window.document.currentScript\n  if (true) {\n    var getCurrentScript = __webpack_require__(\"7da5\")\n    currentScript = getCurrentScript()\n\n    // for backward compatibility, because previously we directly included the polyfill\n    if (!('currentScript' in document)) {\n      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })\n    }\n  }\n\n  var src = currentScript && currentScript.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/)\n  if (src) {\n    __webpack_require__.p = src[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\n/* harmony default export */ var setPublicPath = (null);\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/HotelDatePicker.vue?vue&type=template&id=26705046&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.value)?_c('div',{ref:(\"DatePicker-\" + _vm.hash),staticClass:\"vhd__datepicker__wrapper\",class:{\n    'vhd__datepicker__wrapper--grid': _vm.gridStyle,\n    'vhd__datepicker__wrapper--booking': _vm.bookings.length > 0,\n    vhd__datepicker__fullview: _vm.alwaysVisible,\n  }},[(_vm.isOpen)?_c('div',{staticClass:\"vhd__datepicker__close-button vhd__hide-on-desktop\",on:{\"click\":_vm.closeMobileDatepicker}},[_c('i',[_vm._v(\"+\")])]):_vm._e(),_c('div',{staticClass:\"vhd__datepicker__dummy-wrapper\",class:{ 'vhd__datepicker__dummy-wrapper--is-active': _vm.isOpen }},[_c('date-input',{attrs:{\"i18n\":_vm.i18n,\"input-date\":_vm.formatDate(_vm.checkIn),\"input-date-type\":\"check-in\",\"is-open\":_vm.isOpen,\"toggle-datepicker\":_vm.toggleDatepicker,\"single-day-selection\":_vm.singleDaySelection}}),(!_vm.singleDaySelection)?_c('date-input',{attrs:{\"i18n\":_vm.i18n,\"input-date\":_vm.formatDate(_vm.checkOut),\"input-date-type\":\"check-out\",\"is-open\":_vm.isOpen,\"toggle-datepicker\":_vm.toggleDatepicker,\"single-day-selection\":_vm.singleDaySelection}}):_vm._e()],1),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.showClearSelectionButton),expression:\"showClearSelectionButton\"}],staticClass:\"vhd__datepicker__clear-button\",attrs:{\"tabindex\":\"0\"},on:{\"click\":_vm.clearSelection}},[_c('svg',{attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"viewBox\":\"0 0 68 68\",\"role\":\"img\",\"aria-label\":\"x\"}},[_c('title',[_vm._v(\"x\")]),_c('path',{attrs:{\"d\":\"M6.5 6.5l55 55m0-55l-55 55\",\"stroke\":\"#000\",\"fill\":\"none\",\"stroke-linecap\":\"square\"}})])]),_c('div',{staticClass:\"vhd__datepicker\",class:{\n      'vhd__datepicker--open': _vm.isOpen && !_vm.alwaysVisible,\n      'vhd__datepicker--closed': !_vm.isOpen && !_vm.alwaysVisible,\n      'vhd__datepicker--right': _vm.positionRight,\n    }},[_c('div',{staticClass:\"vhd__hide-on-desktop\"},[(_vm.isOpen)?_c('div',{staticClass:\"vhd__datepicker__dummy-wrapper vhd__datepicker__dummy-wrapper--no-border\",class:{ 'vhd__datepicker__dummy-wrapper--is-active': _vm.isOpen },on:{\"click\":_vm.toggleDatepicker}},[_c('div',{staticClass:\"vhd__datepicker__input\",class:{\n            'vhd__datepicker__dummy-input--is-active': _vm.isOpen && _vm.checkIn == null,\n          },attrs:{\"tabindex\":\"0\",\"type\":\"button\"}},[_vm._v(\" \"+_vm._s((\"\" + (_vm.checkIn ? _vm.formatDate(_vm.checkIn) : _vm.i18n['check-in'])))+\" \")]),_c('div',{staticClass:\"vhd__datepicker__input\",class:{\n            'vhd__datepicker__dummy-input--is-active': _vm.isOpen && _vm.checkOut == null && _vm.checkIn !== null,\n          },attrs:{\"tabindex\":\"0\",\"type\":\"button\"}},[_vm._v(\" \"+_vm._s((\"\" + (_vm.checkOut ? _vm.formatDate(_vm.checkOut) : _vm.i18n['check-out'])))+\" \")])]):_vm._e()]),(_vm.isOpen || _vm.alwaysVisible)?_c('div',{staticClass:\"vhd__datepicker__inner\"},[_c('div',{class:{\n          vhd__datepicker__header: _vm.isDesktop,\n          'vhd__datepicker__header-mobile': !_vm.isDesktop,\n        }},[_c('button',{staticClass:\"vhd__datepicker__month-button vhd__datepicker__month-button--prev\",attrs:{\"type\":\"button\",\"tabindex\":_vm.isOpen ? 0 : -1,\"disabled\":_vm.activeMonthIndex === 0},on:{\"click\":_vm.renderPreviousMonth,\"keyup\":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"enter\",13,$event.key,\"Enter\")){ return null; }$event.stopPropagation();$event.preventDefault();return _vm.renderPreviousMonth.apply(null, arguments)}}}),_c('button',{staticClass:\"vhd__datepicker__month-button vhd__datepicker__month-button--next\",attrs:{\"type\":\"button\",\"disabled\":_vm.isPreventedMaxMonth,\"tabindex\":_vm.isOpen ? 0 : -1},on:{\"click\":_vm.renderNextMonth,\"keyup\":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"enter\",13,$event.key,\"Enter\")){ return null; }$event.stopPropagation();$event.preventDefault();return _vm.renderNextMonth.apply(null, arguments)}}})]),(_vm.isDesktop || _vm.alwaysVisible)?_c('div',{staticClass:\"vhd__datepicker__months\",class:{ 'vhd__datepicker__months--full': _vm.showSingleMonth }},_vm._l((_vm.paginateMonths),function(month,monthIndex){return _c('Month',{key:(_vm.datepickerMonthKey + \"-\" + monthIndex + \"-desktop\"),ref:\"datepickerMonth\",refInFor:true,attrs:{\"month\":month,\"dayKey\":_vm.datepickerDayKey,\"weekKey\":_vm.datepickerWeekKey,\"isDesktop\":_vm.isDesktop,\"firstDayOfWeek\":_vm.firstDayOfWeek,\"showYear\":_vm.showYear,\"yearBeforeMonth\":_vm.yearBeforeMonth,\"activeMonthIndex\":_vm.activeMonthIndex,\"bookings\":_vm.sortBookings,\"checkIn\":_vm.checkIn,\"checkIncheckOutHalfDay\":_vm.checkIncheckOutHalfDay,\"checkInPeriod\":_vm.checkInPeriod,\"checkOut\":_vm.checkOut,\"disableCheckoutOnCheckin\":_vm.disableCheckoutOnCheckin,\"duplicateBookingDates\":_vm.duplicateBookingDates,\"hoveringDate\":_vm.hoveringDate,\"hoveringPeriod\":_vm.hoveringPeriod,\"i18n\":_vm.i18n,\"isOpen\":_vm.isOpen,\"minNightCount\":_vm.minNightCount,\"nextDisabledDate\":_vm.nextDisabledDate,\"nextPeriodDisableDates\":_vm.nextPeriodDisableDates,\"options\":_vm.dayOptions,\"priceSymbol\":_vm.priceSymbol,\"screenSize\":_vm.screenSize,\"showCustomTooltip\":_vm.showCustomTooltip,\"showPrice\":_vm.showPrice,\"showWeekNumbers\":_vm.showWeekNumbers,\"disabledDates\":_vm.disabledDates,\"periodDates\":_vm.periodDates,\"sortedDisabledDates\":_vm.sortedDisabledDates,\"sortedPeriodDates\":_vm.sortedPeriodDates,\"tooltipMessage\":_vm.customTooltipMessage},on:{\"clear-selection\":_vm.clearSelection,\"booking-clicked\":_vm.handleBookingClicked,\"day-clicked\":_vm.handleDayClick,\"enter-day\":_vm.enterDay,\"enter-month\":_vm.enterMonth}})}),1):_vm._e(),(!_vm.isDesktop && _vm.isOpen && !_vm.alwaysVisible)?_c('div',{class:['vhd__datepicker__months-wrapper', { 'vhd__show-tooltip': _vm.showCustomTooltip && _vm.hoveringTooltip }]},[(_vm.hoveringTooltip)?_c('div',{staticClass:\"vhd__datepicker__tooltip--mobile\"},[(_vm.customTooltipMessage)?[_vm._v(\" \"+_vm._s(_vm.cleanString(_vm.customTooltipMessage))+\" \")]:_vm._e()],2):_vm._e(),_c('div',{ref:\"swiperWrapper\",staticClass:\"vhd__datepicker__months\"},_vm._l((_vm.paginateMonths),function(month,monthIndex){return _c('Month',{key:(_vm.datepickerMonthKey + \"-\" + monthIndex + \"-desktop\"),ref:\"datepickerMonth\",refInFor:true,attrs:{\"month\":month,\"dayKey\":_vm.datepickerDayKey,\"weekKey\":_vm.datepickerWeekKey,\"isDesktop\":_vm.isDesktop,\"firstDayOfWeek\":_vm.firstDayOfWeek,\"showYear\":_vm.showYear,\"yearBeforeMonth\":_vm.yearBeforeMonth,\"activeMonthIndex\":_vm.activeMonthIndex,\"bookings\":_vm.sortBookings,\"checkIn\":_vm.checkIn,\"checkIncheckOutHalfDay\":_vm.checkIncheckOutHalfDay,\"checkInPeriod\":_vm.checkInPeriod,\"checkOut\":_vm.checkOut,\"disableCheckoutOnCheckin\":_vm.disableCheckoutOnCheckin,\"duplicateBookingDates\":_vm.duplicateBookingDates,\"hoveringDate\":_vm.hoveringDate,\"hoveringPeriod\":_vm.hoveringPeriod,\"i18n\":_vm.i18n,\"isOpen\":_vm.isOpen,\"minNightCount\":_vm.minNightCount,\"nextDisabledDate\":_vm.nextDisabledDate,\"nextPeriodDisableDates\":_vm.nextPeriodDisableDates,\"options\":_vm.dayOptions,\"priceSymbol\":_vm.priceSymbol,\"screenSize\":_vm.screenSize,\"showCustomTooltip\":false,\"showPrice\":_vm.showPrice,\"sortedDisabledDates\":_vm.sortedDisabledDates,\"sortedPeriodDates\":_vm.sortedPeriodDates,\"tooltipMessage\":_vm.customTooltipMessage},on:{\"clear-selection\":_vm.clearSelection,\"booking-clicked\":_vm.handleBookingClicked,\"day-clicked\":_vm.handleDayClick,\"enter-day\":_vm.enterDay,\"enter-month\":_vm.enterMonth}})}),1)]):_vm._e()]):_vm._e(),_vm._t(\"content\")],2)]):_vm._e()}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/HotelDatePicker.vue?vue&type=template&id=26705046&\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.keys.js\nvar es_object_keys = __webpack_require__(\"ce65\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.symbol.js\nvar es_symbol = __webpack_require__(\"37bb\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.filter.js\nvar es_array_filter = __webpack_require__(\"5108\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.get-own-property-descriptor.js\nvar es_object_get_own_property_descriptor = __webpack_require__(\"6ae9\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/web.dom-collections.for-each.js\nvar web_dom_collections_for_each = __webpack_require__(\"09eb\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.get-own-property-descriptors.js\nvar es_object_get_own_property_descriptors = __webpack_require__(\"3f5d\");\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/defineProperty.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\n\n\n\n\n\n\n\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.symbol.description.js\nvar es_symbol_description = __webpack_require__(\"04c1\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__(\"fc39\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.symbol.iterator.js\nvar es_symbol_iterator = __webpack_require__(\"5cc7\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.iterator.js\nvar es_array_iterator = __webpack_require__(\"d453\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.string.iterator.js\nvar es_string_iterator = __webpack_require__(\"83ce\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__(\"2bb7\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.from.js\nvar es_array_from = __webpack_require__(\"8170\");\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/iterableToArray.js\n\n\n\n\n\n\n\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.slice.js\nvar es_array_slice = __webpack_require__(\"4065\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.function.name.js\nvar es_function_name = __webpack_require__(\"4e89\");\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\n\n\n\n\n\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n// CONCATENATED MODULE: ./node_modules/.pnpm/@babel+runtime@7.14.6/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.number.constructor.js\nvar es_number_constructor = __webpack_require__(\"af86\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.sort.js\nvar es_array_sort = __webpack_require__(\"b5ec\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.join.js\nvar es_array_join = __webpack_require__(\"ef4e\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.regexp.exec.js\nvar es_regexp_exec = __webpack_require__(\"240a\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.string.split.js\nvar es_string_split = __webpack_require__(\"ef2d\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.set.js\nvar es_set = __webpack_require__(\"2b60\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.map.js\nvar es_array_map = __webpack_require__(\"9808\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.concat.js\nvar es_array_concat = __webpack_require__(\"1083\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.includes.js\nvar es_array_includes = __webpack_require__(\"f28b\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.string.includes.js\nvar es_string_includes = __webpack_require__(\"55ea\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.assign.js\nvar es_object_assign = __webpack_require__(\"6b66\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.object.entries.js\nvar es_object_entries = __webpack_require__(\"9232\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.string.replace.js\nvar es_string_replace = __webpack_require__(\"813a\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.array.find.js\nvar es_array_find = __webpack_require__(\"b5db\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/lodash.throttle@4.1.1/node_modules/lodash.throttle/index.js\nvar lodash_throttle = __webpack_require__(\"6c80\");\nvar lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/fecha@4.2.1/node_modules/fecha/lib/fecha.js\nvar token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\nvar twoDigitsOptional = \"[1-9]\\\\d?\";\nvar twoDigits = \"\\\\d\\\\d\";\nvar threeDigits = \"\\\\d{3}\";\nvar fourDigits = \"\\\\d{4}\";\nvar word = \"[^\\\\s]+\";\nvar literal = /\\[([^]*?)\\]/gm;\nfunction shorten(arr, sLen) {\n    var newArr = [];\n    for (var i = 0, len = arr.length; i < len; i++) {\n        newArr.push(arr[i].substr(0, sLen));\n    }\n    return newArr;\n}\nvar monthUpdate = function (arrName) { return function (v, i18n) {\n    var lowerCaseArr = i18n[arrName].map(function (v) { return v.toLowerCase(); });\n    var index = lowerCaseArr.indexOf(v.toLowerCase());\n    if (index > -1) {\n        return index;\n    }\n    return null;\n}; };\nfunction fecha_assign(origObj) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {\n        var obj = args_1[_a];\n        for (var key in obj) {\n            // @ts-ignore ex\n            origObj[key] = obj[key];\n        }\n    }\n    return origObj;\n}\nvar fecha_dayNames = [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\"\n];\nvar monthNames = [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n];\nvar monthNamesShort = shorten(monthNames, 3);\nvar dayNamesShort = shorten(fecha_dayNames, 3);\nvar defaultI18n = {\n    dayNamesShort: dayNamesShort,\n    dayNames: fecha_dayNames,\n    monthNamesShort: monthNamesShort,\n    monthNames: monthNames,\n    amPm: [\"am\", \"pm\"],\n    DoFn: function (dayOfMonth) {\n        return (dayOfMonth +\n            [\"th\", \"st\", \"nd\", \"rd\"][dayOfMonth % 10 > 3\n                ? 0\n                : ((dayOfMonth - (dayOfMonth % 10) !== 10 ? 1 : 0) * dayOfMonth) % 10]);\n    }\n};\nvar globalI18n = fecha_assign({}, defaultI18n);\nvar setGlobalDateI18n = function (i18n) {\n    return (globalI18n = fecha_assign(globalI18n, i18n));\n};\nvar regexEscape = function (str) {\n    return str.replace(/[|\\\\{()[^$+*?.-]/g, \"\\\\$&\");\n};\nvar pad = function (val, len) {\n    if (len === void 0) { len = 2; }\n    val = String(val);\n    while (val.length < len) {\n        val = \"0\" + val;\n    }\n    return val;\n};\nvar formatFlags = {\n    D: function (dateObj) { return String(dateObj.getDate()); },\n    DD: function (dateObj) { return pad(dateObj.getDate()); },\n    Do: function (dateObj, i18n) {\n        return i18n.DoFn(dateObj.getDate());\n    },\n    d: function (dateObj) { return String(dateObj.getDay()); },\n    dd: function (dateObj) { return pad(dateObj.getDay()); },\n    ddd: function (dateObj, i18n) {\n        return i18n.dayNamesShort[dateObj.getDay()];\n    },\n    dddd: function (dateObj, i18n) {\n        return i18n.dayNames[dateObj.getDay()];\n    },\n    M: function (dateObj) { return String(dateObj.getMonth() + 1); },\n    MM: function (dateObj) { return pad(dateObj.getMonth() + 1); },\n    MMM: function (dateObj, i18n) {\n        return i18n.monthNamesShort[dateObj.getMonth()];\n    },\n    MMMM: function (dateObj, i18n) {\n        return i18n.monthNames[dateObj.getMonth()];\n    },\n    YY: function (dateObj) {\n        return pad(String(dateObj.getFullYear()), 4).substr(2);\n    },\n    YYYY: function (dateObj) { return pad(dateObj.getFullYear(), 4); },\n    h: function (dateObj) { return String(dateObj.getHours() % 12 || 12); },\n    hh: function (dateObj) { return pad(dateObj.getHours() % 12 || 12); },\n    H: function (dateObj) { return String(dateObj.getHours()); },\n    HH: function (dateObj) { return pad(dateObj.getHours()); },\n    m: function (dateObj) { return String(dateObj.getMinutes()); },\n    mm: function (dateObj) { return pad(dateObj.getMinutes()); },\n    s: function (dateObj) { return String(dateObj.getSeconds()); },\n    ss: function (dateObj) { return pad(dateObj.getSeconds()); },\n    S: function (dateObj) {\n        return String(Math.round(dateObj.getMilliseconds() / 100));\n    },\n    SS: function (dateObj) {\n        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n    },\n    SSS: function (dateObj) { return pad(dateObj.getMilliseconds(), 3); },\n    a: function (dateObj, i18n) {\n        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n    },\n    A: function (dateObj, i18n) {\n        return dateObj.getHours() < 12\n            ? i18n.amPm[0].toUpperCase()\n            : i18n.amPm[1].toUpperCase();\n    },\n    ZZ: function (dateObj) {\n        var offset = dateObj.getTimezoneOffset();\n        return ((offset > 0 ? \"-\" : \"+\") +\n            pad(Math.floor(Math.abs(offset) / 60) * 100 + (Math.abs(offset) % 60), 4));\n    },\n    Z: function (dateObj) {\n        var offset = dateObj.getTimezoneOffset();\n        return ((offset > 0 ? \"-\" : \"+\") +\n            pad(Math.floor(Math.abs(offset) / 60), 2) +\n            \":\" +\n            pad(Math.abs(offset) % 60, 2));\n    }\n};\nvar monthParse = function (v) { return +v - 1; };\nvar emptyDigits = [null, twoDigitsOptional];\nvar emptyWord = [null, word];\nvar amPm = [\n    \"isPm\",\n    word,\n    function (v, i18n) {\n        var val = v.toLowerCase();\n        if (val === i18n.amPm[0]) {\n            return 0;\n        }\n        else if (val === i18n.amPm[1]) {\n            return 1;\n        }\n        return null;\n    }\n];\nvar timezoneOffset = [\n    \"timezoneOffset\",\n    \"[^\\\\s]*?[\\\\+\\\\-]\\\\d\\\\d:?\\\\d\\\\d|[^\\\\s]*?Z?\",\n    function (v) {\n        var parts = (v + \"\").match(/([+-]|\\d\\d)/gi);\n        if (parts) {\n            var minutes = +parts[1] * 60 + parseInt(parts[2], 10);\n            return parts[0] === \"+\" ? minutes : -minutes;\n        }\n        return 0;\n    }\n];\nvar parseFlags = {\n    D: [\"day\", twoDigitsOptional],\n    DD: [\"day\", twoDigits],\n    Do: [\"day\", twoDigitsOptional + word, function (v) { return parseInt(v, 10); }],\n    M: [\"month\", twoDigitsOptional, monthParse],\n    MM: [\"month\", twoDigits, monthParse],\n    YY: [\n        \"year\",\n        twoDigits,\n        function (v) {\n            var now = new Date();\n            var cent = +(\"\" + now.getFullYear()).substr(0, 2);\n            return +(\"\" + (+v > 68 ? cent - 1 : cent) + v);\n        }\n    ],\n    h: [\"hour\", twoDigitsOptional, undefined, \"isPm\"],\n    hh: [\"hour\", twoDigits, undefined, \"isPm\"],\n    H: [\"hour\", twoDigitsOptional],\n    HH: [\"hour\", twoDigits],\n    m: [\"minute\", twoDigitsOptional],\n    mm: [\"minute\", twoDigits],\n    s: [\"second\", twoDigitsOptional],\n    ss: [\"second\", twoDigits],\n    YYYY: [\"year\", fourDigits],\n    S: [\"millisecond\", \"\\\\d\", function (v) { return +v * 100; }],\n    SS: [\"millisecond\", twoDigits, function (v) { return +v * 10; }],\n    SSS: [\"millisecond\", threeDigits],\n    d: emptyDigits,\n    dd: emptyDigits,\n    ddd: emptyWord,\n    dddd: emptyWord,\n    MMM: [\"month\", word, monthUpdate(\"monthNamesShort\")],\n    MMMM: [\"month\", word, monthUpdate(\"monthNames\")],\n    a: amPm,\n    A: amPm,\n    ZZ: timezoneOffset,\n    Z: timezoneOffset\n};\n// Some common format strings\nvar globalMasks = {\n    default: \"ddd MMM DD YYYY HH:mm:ss\",\n    shortDate: \"M/D/YY\",\n    mediumDate: \"MMM D, YYYY\",\n    longDate: \"MMMM D, YYYY\",\n    fullDate: \"dddd, MMMM D, YYYY\",\n    isoDate: \"YYYY-MM-DD\",\n    isoDateTime: \"YYYY-MM-DDTHH:mm:ssZ\",\n    shortTime: \"HH:mm\",\n    mediumTime: \"HH:mm:ss\",\n    longTime: \"HH:mm:ss.SSS\"\n};\nvar setGlobalDateMasks = function (masks) { return fecha_assign(globalMasks, masks); };\n/***\n * Format a date\n * @method format\n * @param {Date|number} dateObj\n * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n * @returns {string} Formatted date string\n */\nvar fecha_format = function (dateObj, mask, i18n) {\n    if (mask === void 0) { mask = globalMasks[\"default\"]; }\n    if (i18n === void 0) { i18n = {}; }\n    if (typeof dateObj === \"number\") {\n        dateObj = new Date(dateObj);\n    }\n    if (Object.prototype.toString.call(dateObj) !== \"[object Date]\" ||\n        isNaN(dateObj.getTime())) {\n        throw new Error(\"Invalid Date pass to format\");\n    }\n    mask = globalMasks[mask] || mask;\n    var literals = [];\n    // Make literals inactive by replacing them with @@@\n    mask = mask.replace(literal, function ($0, $1) {\n        literals.push($1);\n        return \"@@@\";\n    });\n    var combinedI18nSettings = fecha_assign(fecha_assign({}, globalI18n), i18n);\n    // Apply formatting rules\n    mask = mask.replace(token, function ($0) {\n        return formatFlags[$0](dateObj, combinedI18nSettings);\n    });\n    // Inline literal values back into the formatted value\n    return mask.replace(/@@@/g, function () { return literals.shift(); });\n};\n/**\n * Parse a date string into a Javascript Date object /\n * @method parse\n * @param {string} dateStr Date string\n * @param {string} format Date parse format\n * @param {i18n} I18nSettingsOptional Full or subset of I18N settings\n * @returns {Date|null} Returns Date object. Returns null what date string is invalid or doesn't match format\n */\nfunction parse(dateStr, format, i18n) {\n    if (i18n === void 0) { i18n = {}; }\n    if (typeof format !== \"string\") {\n        throw new Error(\"Invalid format in fecha parse\");\n    }\n    // Check to see if the format is actually a mask\n    format = globalMasks[format] || format;\n    // Avoid regular expression denial of service, fail early for really long strings\n    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n    if (dateStr.length > 1000) {\n        return null;\n    }\n    // Default to the beginning of the year.\n    var today = new Date();\n    var dateInfo = {\n        year: today.getFullYear(),\n        month: 0,\n        day: 1,\n        hour: 0,\n        minute: 0,\n        second: 0,\n        millisecond: 0,\n        isPm: null,\n        timezoneOffset: null\n    };\n    var parseInfo = [];\n    var literals = [];\n    // Replace all the literals with @@@. Hopefully a string that won't exist in the format\n    var newFormat = format.replace(literal, function ($0, $1) {\n        literals.push(regexEscape($1));\n        return \"@@@\";\n    });\n    var specifiedFields = {};\n    var requiredFields = {};\n    // Change every token that we find into the correct regex\n    newFormat = regexEscape(newFormat).replace(token, function ($0) {\n        var info = parseFlags[$0];\n        var field = info[0], regex = info[1], requiredField = info[3];\n        // Check if the person has specified the same field twice. This will lead to confusing results.\n        if (specifiedFields[field]) {\n            throw new Error(\"Invalid format. \" + field + \" specified twice in format\");\n        }\n        specifiedFields[field] = true;\n        // Check if there are any required fields. For instance, 12 hour time requires AM/PM specified\n        if (requiredField) {\n            requiredFields[requiredField] = true;\n        }\n        parseInfo.push(info);\n        return \"(\" + regex + \")\";\n    });\n    // Check all the required fields are present\n    Object.keys(requiredFields).forEach(function (field) {\n        if (!specifiedFields[field]) {\n            throw new Error(\"Invalid format. \" + field + \" is required in specified format\");\n        }\n    });\n    // Add back all the literals after\n    newFormat = newFormat.replace(/@@@/g, function () { return literals.shift(); });\n    // Check if the date string matches the format. If it doesn't return null\n    var matches = dateStr.match(new RegExp(newFormat, \"i\"));\n    if (!matches) {\n        return null;\n    }\n    var combinedI18nSettings = fecha_assign(fecha_assign({}, globalI18n), i18n);\n    // For each match, call the parser function for that date part\n    for (var i = 1; i < matches.length; i++) {\n        var _a = parseInfo[i - 1], field = _a[0], parser = _a[2];\n        var value = parser\n            ? parser(matches[i], combinedI18nSettings)\n            : +matches[i];\n        // If the parser can't make sense of the value, return null\n        if (value == null) {\n            return null;\n        }\n        dateInfo[field] = value;\n    }\n    if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {\n        dateInfo.hour = +dateInfo.hour + 12;\n    }\n    else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {\n        dateInfo.hour = 0;\n    }\n    var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);\n    var validateFields = [\n        [\"month\", \"getMonth\"],\n        [\"day\", \"getDate\"],\n        [\"hour\", \"getHours\"],\n        [\"minute\", \"getMinutes\"],\n        [\"second\", \"getSeconds\"]\n    ];\n    for (var i = 0, len = validateFields.length; i < len; i++) {\n        // Check to make sure the date field is within the allowed range. Javascript dates allows values\n        // outside the allowed range. If the values don't match the value was invalid\n        if (specifiedFields[validateFields[i][0]] &&\n            dateInfo[validateFields[i][0]] !== dateWithoutTZ[validateFields[i][1]]()) {\n            return null;\n        }\n    }\n    if (dateInfo.timezoneOffset == null) {\n        return dateWithoutTZ;\n    }\n    return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));\n}\nvar fecha = {\n    format: fecha_format,\n    parse: parse,\n    defaultI18n: defaultI18n,\n    setGlobalDateI18n: setGlobalDateI18n,\n    setGlobalDateMasks: setGlobalDateMasks\n};\n\n/* harmony default export */ var lib_fecha = (fecha);\n\n//# sourceMappingURL=fecha.js.map\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Month.vue?vue&type=template&id=7737dfd4&\nvar Monthvue_type_template_id_7737dfd4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:\"datepickerMonth\",staticClass:\"vhd__datepicker__month\",class:{ 'vhd__datepicker__month--with-week-numbers': _vm.showWeekNumbers },on:{\"mouseenter\":function($event){return _vm.enterMonth($event)}}},[_c('p',{staticClass:\"vhd__datepicker__month-name\"},[_vm._v(\" \"+_vm._s(_vm.monthName)+\" \")]),_c('week-row',_vm._b({},'week-row',_vm.$props,false)),(_vm.showWeekNumbers)?_c('div',{staticClass:\"vhd__datepicker__weeknumbers\"},_vm._l((_vm.weekNumbers),function(weekNumber,indexWN){return _c('div',{key:(\"vhd__datepicker__weeknumber__\" + weekNumber + \"-\" + indexWN),staticClass:\"vhd__datepicker__weeknumbers__number\"},[_vm._v(\" \"+_vm._s(weekNumber)+\" \")])}),0):_vm._e(),_vm._l((_vm.month.days),function(day,dayIndex){return _c('div',{key:(_vm.dayKey + \"-\" + dayIndex),staticClass:\"vhd__square\",on:{\"mouseenter\":function($event){return _vm.enterDay($event, day)}}},[_c('Day',_vm._b({attrs:{\"belongsToThisMonth\":day.belongsToThisMonth,\"date\":day.date},on:{\"clear-selection\":_vm.clearSelection,\"booking-clicked\":_vm.handleBookingClicked,\"day-clicked\":_vm.handleDayClick}},'Day',_vm.$props,false))],1)})],2)}\nvar Monthvue_type_template_id_7737dfd4_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/Month.vue?vue&type=template&id=7737dfd4&\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.string.trim.js\nvar es_string_trim = __webpack_require__(\"f135\");\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Day.vue?vue&type=template&id=0b134872&\nvar Dayvue_type_template_id_0b134872_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.showTooltip && _vm.options.hoveringTooltip)?_c('div',{staticClass:\"vhd__datepicker__tooltip\",domProps:{\"innerHTML\":_vm._s(_vm.tooltipMessageDisplay)}}):_vm._e(),_c('div',{ref:\"day\",staticClass:\"vhd__datepicker__month-day\",class:[\n      _vm.dayClass,\n      _vm.disabledClass,\n      _vm.checkinCheckoutClass,\n      _vm.bookingClass,\n      { 'vhd__datepicker__month-day--today': _vm.isToday } ],attrs:{\"tabindex\":_vm.tabIndex},on:{\"click\":function($event){$event.preventDefault();$event.stopPropagation();return _vm.dayClicked($event, _vm.date)}}},[_c('div',{staticClass:\"vhd__datepicker__month-day-wrapper\"},[_c('span',{staticClass:\"day\"},[_vm._v(_vm._s(_vm.dayNumber))]),_c('Price',{attrs:{\"show\":_vm.showPrice,\"price\":_vm.dayPrice,\"symbol\":_vm.priceSymbol}})],1)]),(_vm.currentBooking && _vm.belongsToThisMonth && !_vm.isDisabled)?_c('BookingBullet',{attrs:{\"currentBooking\":_vm.currentBooking,\"duplicateBookingDates\":_vm.duplicateBookingDates,\"formatDate\":_vm.formatDate,\"previousBooking\":_vm.previousBooking}}):_vm._e()],1)}\nvar Dayvue_type_template_id_0b134872_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/Day.vue?vue&type=template&id=0b134872&\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.number.is-nan.js\nvar es_number_is_nan = __webpack_require__(\"01ed\");\n\n// EXTERNAL MODULE: ./node_modules/.pnpm/core-js@3.15.2/node_modules/core-js/modules/es.number.to-fixed.js\nvar es_number_to_fixed = __webpack_require__(\"ba83\");\n\n// CONCATENATED MODULE: ./src/helpers.js\n\n\n\n\n\n/* eslint-disable vars-on-top */\n\nvar helpers = {\n  getNextDate: function getNextDate(datesArray, referenceDate) {\n    var now = new Date(referenceDate);\n    var closest = Infinity;\n    datesArray.forEach(function (d) {\n      var date = new Date(d);\n\n      if (date >= now && date < closest) {\n        closest = d;\n      }\n    });\n\n    if (closest === Infinity) {\n      return null;\n    }\n\n    return closest;\n  },\n  nextDateByDayOfWeek: function nextDateByDayOfWeek(weekDay, referenceDate, i18n) {\n    var newReferenceDate = new Date(referenceDate);\n    var newWeekDay = weekDay.toLowerCase();\n    var daysDefault = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n    var days = i18n ? i18n['day-names'] : daysDefault;\n    var referenceDateDay = newReferenceDate.getDay();\n\n    for (var i = 7;; i--) {\n      if (newWeekDay === days[i]) {\n        newWeekDay = i <= referenceDateDay ? i + 7 : i;\n        break;\n      }\n    }\n\n    var daysUntilNext = newWeekDay - referenceDateDay;\n    return newReferenceDate.setDate(newReferenceDate.getDate() + daysUntilNext);\n  },\n  nextDateByDayOfWeekArray: function nextDateByDayOfWeekArray(daysArray, referenceDate, i18n) {\n    var tempArray = [];\n\n    for (var i = 0; i < daysArray.length; i++) {\n      tempArray.push(new Date(this.nextDateByDayOfWeek(daysArray[i], referenceDate, i18n)));\n    }\n\n    return this.getNextDate(tempArray, referenceDate);\n  },\n  nextDateByDayOfWeekObject: function nextDateByDayOfWeekObject(days, referenceDate, i18n) {\n    var daysArray = Object.entries(days).map(function (e) {\n      return e[1] ? e[0] : false;\n    }).filter(function (v) {\n      return v;\n    });\n    return this.nextDateByDayOfWeekArray(daysArray, referenceDate, i18n);\n  },\n  countDays: function countDays(start, end) {\n    var oneDay = 24 * 60 * 60 * 1000;\n    var firstDate = new Date(start);\n    var secondDate = new Date(end);\n    return Math.round(Math.abs((firstDate.getTime() - secondDate.getTime()) / oneDay));\n  },\n  addDays: function addDays(date, quantity) {\n    var result = new Date(date);\n    result.setDate(result.getDate() + quantity);\n    return result;\n  },\n  getDayDiff: function getDayDiff(d1, d2) {\n    var t2 = new Date(d2).getTime();\n    var t1 = new Date(d1).getTime();\n    return parseInt((t2 - t1) / (24 * 3600 * 1000), 10);\n  },\n  getFirstDay: function getFirstDay(date, firstDayOfWeek) {\n    var firstDay = this.getFirstDayOfMonth(date);\n    var day = firstDay.getDay();\n    var offset = 0;\n\n    if (firstDayOfWeek > 0) {\n      offset = !day ? -6 : firstDayOfWeek;\n    }\n\n    return new Date(firstDay.setDate(firstDay.getDate() - (day - offset)));\n  },\n  getFirstDayOfMonth: function getFirstDayOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n  },\n  getNextMonth: function getNextMonth(date) {\n    var nextMonth;\n\n    if (date.getMonth() === 11) {\n      nextMonth = new Date(date.getFullYear() + 1, 0, 1);\n    } else {\n      nextMonth = new Date(date.getFullYear(), date.getMonth() + 1, 1);\n    }\n\n    return nextMonth;\n  },\n  getPreviousMonth: function getPreviousMonth(date) {\n    var prevMonth;\n\n    if (date.getMonth() === 0) {\n      prevMonth = new Date(date.getFullYear() - 1, 11, 1);\n    } else {\n      prevMonth = new Date(date.getFullYear(), date.getMonth() - 1, 1);\n    }\n\n    return prevMonth;\n  },\n  handleTouchStart: function handleTouchStart(evt) {\n    this.isTouchMove = false;\n\n    if (this.isOpen) {\n      this.xDown = evt.touches[0].clientX;\n      this.yDown = evt.touches[0].clientY;\n    }\n  },\n  handleTouchMove: function handleTouchMove(evt) {\n    if (!this.xDown || !this.yDown) {\n      this.isTouchMove = false;\n      return;\n    }\n\n    this.isTouchMove = true;\n    this.xUp = evt.touches[0].clientX;\n    this.yUp = evt.touches[0].clientY;\n  },\n  handleTouchEnd: function handleTouchEnd() {\n    if (!this.isTouchMove) {\n      return;\n    }\n\n    if (!this.xDown || !this.yDown) {\n      return;\n    }\n\n    var xDiff = this.xDown - this.xUp;\n    var yDiff = this.yDown - this.yUp;\n\n    if (Math.abs(xDiff) < Math.abs(yDiff) && yDiff > 0 && !this.isPreventedMaxMonth) {\n      this.renderNextMonth();\n    } else {\n      this.renderPreviousMonth();\n    }\n\n    this.xDown = null;\n    this.yDown = null;\n  },\n  validateDateBetweenTwoDates: function validateDateBetweenTwoDates(fromDate, toDate, givenDate) {\n    var getvalidDate = function getvalidDate(d) {\n      var formatDateAt00 = new Date(d).setHours(0, 0, 0, 0);\n      return new Date(formatDateAt00);\n    };\n\n    return getvalidDate(givenDate) <= getvalidDate(toDate) && getvalidDate(givenDate) >= getvalidDate(fromDate);\n  },\n  validateDateBetweenDate: function validateDateBetweenDate(fromDate, givenDate) {\n    var getvalidDate = function getvalidDate(d) {\n      return new Date(d);\n    };\n\n    return getvalidDate(givenDate) <= getvalidDate(fromDate);\n  },\n  getMonthDiff: function getMonthDiff(d1, d2) {\n    var newD1 = new Date(d1);\n    var newD2 = new Date(d2);\n    var d1Y = newD1.getFullYear();\n    var d2Y = newD2.getFullYear();\n    var d1M = newD1.getMonth();\n    var d2M = newD2.getMonth();\n    return d2M + 12 * d2Y - (d1M + 12 * d1Y);\n  },\n  shortenString: function shortenString(arr, sLen) {\n    var newArr = [];\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      newArr.push(arr[i].substr(0, sLen));\n    }\n\n    return newArr;\n  },\n  getDaysArray: function getDaysArray(start, end) {\n    for ( // eslint-disable-next-line no-var\n    var arr = [], dt = new Date(start); dt <= end; dt.setDate(dt.getDate() + 1)) {\n      arr.push(new Date(dt));\n    } // eslint-disable-next-line block-scoped-var\n\n\n    return arr;\n  },\n  dateFormater: function dateFormater(date, format) {\n    var f = format || 'YYYY-MM-DD';\n\n    if (date) {\n      return lib_fecha.format(date, f);\n    }\n\n    return '';\n  },\n  pluralize: function pluralize(countOfDays) {\n    var periodType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'night';\n\n    if (periodType === 'week') {\n      return countOfDays > 7 ? this.i18n.weeks : this.i18n.week;\n    }\n\n    return countOfDays !== 1 ? this.i18n.nights : this.i18n.night;\n  },\n  isDateLessOrEquals: function isDateLessOrEquals(time1, time2) {\n    return new Date(time1) < new Date(time2);\n  },\n  compareDay: function compareDay(day1, day2) {\n    var date1 = lib_fecha.format(new Date(day1), 'YYYYMMDD');\n    var date2 = lib_fecha.format(new Date(day2), 'YYYYMMDD');\n\n    if (date1 > date2) {\n      return 1;\n    }\n\n    if (date1 === date2) {\n      return 0;\n    }\n\n    if (date1 < date2) {\n      return -1;\n    }\n\n    return null;\n  },\n  getIsoWeek: function getIsoWeek(testDate) {\n    var date = new Date(testDate);\n    date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.\n\n    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.\n\n    var week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.\n\n    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);\n  }\n};\n/* harmony default export */ var src_helpers = (helpers);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/BookingBullet.vue?vue&type=template&id=73e153d9&\nvar BookingBulletvue_type_template_id_73e153d9_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('i',{staticClass:\"vhd__parent-bullet\"},[(_vm.previousBooking && _vm.duplicateBookingDates.includes(_vm.formatDate))?_c('i',{staticClass:\"vhd__bullet\",class:[\n      {\n        vhd__checkInCheckOut: _vm.duplicateBookingDates.includes(_vm.formatDate),\n      } ],style:(_vm.previousBooking.style)}):_vm._e(),(_vm.previousBooking && _vm.duplicateBookingDates.includes(_vm.formatDate))?_c('i',{staticClass:\"vhd__pipe vhd__checkInCheckOut\",style:(_vm.previousBooking.style)}):_vm._e(),(_vm.currentBooking && (_vm.currentBooking.checkInDate === _vm.formatDate || _vm.currentBooking.checkOutDate === _vm.formatDate))?_c('i',{staticClass:\"vhd__bullet\",class:[\n      {\n        vhd__checkIn: _vm.currentBooking.checkInDate === _vm.formatDate,\n        vhd__checkOut: _vm.currentBooking.checkOutDate === _vm.formatDate,\n      } ],style:(_vm.currentBooking.style)}):_vm._e(),(_vm.currentBooking)?_c('i',{staticClass:\"vhd__pipe\",class:[\n      {\n        vhd__checkIn: _vm.currentBooking.checkInDate === _vm.formatDate,\n        vhd__checkOut: _vm.currentBooking.checkOutDate === _vm.formatDate,\n      } ],style:(_vm.currentBooking.style)}):_vm._e()])}\nvar BookingBulletvue_type_template_id_73e153d9_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/BookingBullet.vue?vue&type=template&id=73e153d9&\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/BookingBullet.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var BookingBulletvue_type_script_lang_js_ = ({\n  name: 'BookingBullet',\n  props: {\n    currentBooking: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    duplicateBookingDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    formatDate: {\n      type: String,\n      default: ''\n    },\n    previousBooking: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/BookingBullet.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_BookingBulletvue_type_script_lang_js_ = (BookingBulletvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/runtime/componentNormalizer.js\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n        injectStyles.call(\n          this,\n          (options.functional ? this.parent : this).$root.$options.shadowRoot\n        )\n      }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n\n// CONCATENATED MODULE: ./src/DatePicker/components/BookingBullet.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = normalizeComponent(\n  components_BookingBulletvue_type_script_lang_js_,\n  BookingBulletvue_type_template_id_73e153d9_render,\n  BookingBulletvue_type_template_id_73e153d9_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var BookingBullet = (component.exports);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Price.vue?vue&type=template&id=2998315e&\nvar Pricevue_type_template_id_2998315e_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.show && _vm.price)?_c('div',{staticClass:\"price\"},[_c('span',{staticClass:\"price-symbol\"},[_vm._v(_vm._s(_vm.symbol))]),_c('span',{staticClass:\"price-number\"},[_vm._v(_vm._s(_vm.price))])]):_vm._e()}\nvar Pricevue_type_template_id_2998315e_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/Price.vue?vue&type=template&id=2998315e&\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Price.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var Pricevue_type_script_lang_js_ = ({\n  name: 'Price',\n  props: {\n    show: {\n      type: Boolean,\n      required: true\n    },\n    price: {\n      type: String,\n      required: true\n    },\n    symbol: {\n      type: [String, null, undefined],\n      default: ''\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/Price.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Pricevue_type_script_lang_js_ = (Pricevue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/components/Price.vue\n\n\n\n\n\n/* normalize component */\n\nvar Price_component = normalizeComponent(\n  components_Pricevue_type_script_lang_js_,\n  Pricevue_type_template_id_2998315e_render,\n  Pricevue_type_template_id_2998315e_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Price = (Price_component.exports);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Day.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ var Dayvue_type_script_lang_js_ = ({\n  name: 'Day',\n  components: {\n    BookingBullet: BookingBullet,\n    Price: Price\n  },\n  props: {\n    bookings: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    activeMonthIndex: {\n      type: Number\n    },\n    belongsToThisMonth: {\n      type: Boolean,\n      default: false\n    },\n    checkIn: {\n      type: Date\n    },\n    checkIncheckOutHalfDay: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    checkInPeriod: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    checkOut: {\n      type: Date\n    },\n    date: {\n      type: Date\n    },\n    disableCheckoutOnCheckin: {\n      type: Boolean,\n      default: false\n    },\n    duplicateBookingDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    hoveringDate: {\n      type: Date\n    },\n    hoveringPeriod: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    hoveringTooltip: {\n      default: true,\n      type: Boolean\n    },\n    i18n: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    isOpen: {\n      type: Boolean,\n      required: true\n    },\n    minNightCount: {\n      type: Number,\n      default: 0\n    },\n    nextDisabledDate: {\n      type: [Date, Number, String]\n    },\n    nextPeriodDisableDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    options: {\n      type: Object\n    },\n    priceSymbol: {\n      type: String,\n      required: true\n    },\n    priceDecimals: {\n      type: [Number, null],\n      default: 0\n    },\n    screenSize: {\n      type: String,\n      default: ''\n    },\n    showCustomTooltip: {\n      default: false,\n      type: Boolean\n    },\n    showPrice: {\n      type: Boolean,\n      default: false\n    },\n    sortedDisabledDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    sortedPeriodDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    tooltipMessage: {\n      default: null,\n      type: String\n    }\n  },\n  data: function data() {\n    return {\n      currentDate: new Date(),\n      isDisabled: false,\n      isHighlighted: false\n    };\n  },\n  computed: {\n    previousBooking: function previousBooking() {\n      var _this = this;\n\n      var previousBooking = null;\n\n      if (this.currentBooking && this.duplicateBookingDates.includes(this.currentBooking.checkInDate)) {\n        previousBooking = this.bookings.find(function (booking) {\n          return booking.checkOutDate === _this.formatDate && _this.duplicateBookingDates.includes(booking.checkOutDate);\n        });\n      }\n\n      return previousBooking;\n    },\n    currentBooking: function currentBooking() {\n      var _this2 = this;\n\n      return this.bookings.find(function (booking) {\n        return _this2.duplicateBookingDates.includes(_this2.formatDate) && booking.checkInDate === _this2.formatDate || !_this2.duplicateBookingDates.includes(_this2.formatDate) && _this2.validateDateBetweenTwoDates(booking.checkInDate, booking.checkOutDate, _this2.formatDate);\n      });\n    },\n    dayNumber: function dayNumber() {\n      return lib_fecha.format(this.date, 'D');\n    },\n    dayPrice: function dayPrice() {\n      var _this3 = this;\n\n      var result = '';\n\n      var currentDate = _toConsumableArray(this.sortedPeriodDates).reverse().find(function (d) {\n        return _this3.validateDateBetweenTwoDates(d.startAt, d.endAt, _this3.formatDate);\n      });\n\n      if (currentDate && currentDate.price) {\n        var priceIsNumeric = typeof currentDate.price === 'number' || !Number.isNaN(parseFloat(currentDate.price));\n        var weeklyPeriod = currentDate.periodType !== 'nightly';\n\n        if (priceIsNumeric && weeklyPeriod) {\n          // Convert the price when weekly and is not a float/int type\n          var price = parseFloat(currentDate.price);\n          var divisor = 7;\n          var decimals = Number.isNaN(parseFloat(this.priceDecimals)) ? 0 : parseFloat(this.priceDecimals);\n          result = (price / divisor).toFixed(decimals);\n        } else {\n          result = currentDate.price;\n        }\n      }\n\n      return String(result);\n    },\n    halfDayClass: function halfDayClass() {\n      if (Object.keys(this.checkIncheckOutHalfDay).length > 0) {\n        var keyDate = this.dateFormater(this.date);\n\n        if (this.checkIncheckOutHalfDay[keyDate] && this.checkIncheckOutHalfDay[keyDate].checkIn) {\n          if (this.checkIn && !this.checkOut) {\n            return 'vhd__datepicker__month-day--halfCheckIn vhd__datepicker__month-day--valid';\n          }\n\n          return 'vhd__datepicker__month-day--halfCheckIn vhd__datepicker__month-day--invalid';\n        }\n\n        if (this.checkIncheckOutHalfDay[keyDate] && this.checkIncheckOutHalfDay[keyDate].checkOut) {\n          return 'vhd__datepicker__month-day--halfCheckOut vhd__datepicker__month-day--valid';\n        }\n      }\n\n      return false;\n    },\n    bookingClass: function bookingClass() {\n      if (this.bookings.length > 0 && this.currentBooking) {\n        if (!this.isDisabled && this.validateDateBetweenTwoDates(this.currentBooking.checkInDate, this.currentBooking.checkOutDate, this.hoveringDate)) {\n          if (this.checkIncheckOutHalfDay[this.formatDate]) {\n            if (this.checkIn && !this.checkOut) {\n              return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n            }\n\n            if (this.checkIncheckOutHalfDay[this.formatDate].checkOut) {\n              return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n            }\n\n            return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--invalid';\n          }\n\n          if (this.checkIn && !this.checkOut) {\n            return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--invalid';\n          }\n\n          return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n        }\n\n        if (this.checkIncheckOutHalfDay[this.formatDate] && this.checkIncheckOutHalfDay[this.formatDate].checkOut && !this.duplicateBookingDates.includes(this.formatDate)) {\n          if (!this.checkIn) {\n            return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n          }\n\n          if (this.checkIn && this.checkIn === this.date || this.checkIn && this.checkOut) {\n            return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n          }\n        }\n\n        if (this.checkIn && !this.checkOut && this.hoveringDate === this.date) {\n          return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--hovering';\n        }\n\n        return 'vhd__datepicker__month-day--not-allowed vhd__datepicker__month-day--invalid';\n      }\n\n      return '';\n    },\n    disabledClass: function disabledClass() {\n      return this.isDisabled || this.isADisabledDay ? ' vhd__datepicker__month-day--disabled ' : '';\n    },\n    dayClass: function dayClass() {\n      if (!this.belongsToThisMonth) {\n        // Good\n        return 'vhd__datepicker__month-day--hidden';\n      } // If the calendar has a minimum number of nights && !checkOut\n\n\n      var nextValidDate = this.addDays(this.checkIn, this.minNightCount);\n      var isDateAfterMinimumDuration = this.getDayDiff(this.hoveringDate, nextValidDate) <= 0;\n\n      if (!isDateAfterMinimumDuration && !this.checkOut && !this.isDisabled && this.compareDay(this.date, this.checkIn) >= 0 && this.minNightCount > 0 && this.compareDay(this.date, this.addDays(this.checkIn, this.minNightCount)) === -1) {\n        return 'vhd__datepicker__month-day--valid vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed minimumDurationUnvalidDay';\n      } // Current Day\n\n\n      if (!this.isDisabled && this.date === this.hoveringDate && this.checkIn !== null && this.checkOut == null) {\n        return 'vhd__datepicker__month-day--selected vhd__datepicker__month-day--hovering vhd__currentDay';\n      } // Highlight the selected dates and prevent the user from selecting\n      // the same date for checkout and checkin\n\n\n      if (this.checkIn !== null && this.dateFormater(this.checkIn) === this.dateFormater(this.date)) {\n        if (this.minNightCount === 0) {\n          return 'vhd__datepicker__month-day--first-day-selected checkIn';\n        } // Good\n\n\n        return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--first-day-selected checkIn';\n      } // Checkout day\n\n\n      if (this.checkOut !== null) {\n        if (this.dateFormater(this.checkOut) === this.dateFormater(this.date)) {\n          if (this.halfDayClass) {\n            return \"vhd__datepicker__month-day--disabled vhd__datepicker__month-day--last-day-selected \".concat(this.halfDayClass, \" checkOut\");\n          }\n\n          return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--last-day-selected checkOut';\n        }\n      } // Only highlight dates that are not disabled\n\n\n      if (this.isHighlighted && !this.isDisabled) {\n        var classSelected = 'vhd__datepicker__month-day--selected';\n\n        if (this.isADisabledDay) {\n          return \"\".concat(classSelected, \" vhd__datepicker__month-day--disabled afterMinimumDurationValidDay\");\n        }\n\n        if (Object.keys(this.checkInPeriod).length > 0 && this.checkInPeriod.periodType.includes('weekly') && this.hoveringDate && (this.checkInPeriod.periodType === 'weekly_by_saturday' && this.hoveringDate.getDay() === 6 || this.checkInPeriod.periodType === 'weekly_by_sunday' && this.hoveringDate.getDay() === 0) && this.isDateLessOrEquals(this.date, this.hoveringDate)) {\n          // If currentPeriod has a minimumDuration 1\n          if (this.checkInPeriod.minimumDuration === 1) {\n            return \"\".concat(classSelected, \" afterMinimumDurationValidDay\");\n          } // If currentPeriod has a minimumDuration superior to 1\n\n\n          if (this.getDayDiff(this.hoveringDate, this.checkInPeriod.nextValidDate) <= 0) {\n            return \"\".concat(classSelected, \" afterMinimumDurationValidDay\");\n          }\n        } else if (Object.keys(this.checkInPeriod).length > 0 && this.checkInPeriod.periodType === 'nightly' && this.hoveringDate && this.hoveringPeriod.periodType.includes('weekly') && (this.hoveringPeriod.periodType === 'weekly_by_saturday' && this.hoveringDate.getDay() === 6 || this.hoveringPeriod.periodType === 'weekly_by_sunday' && this.hoveringDate.getDay() === 0 && this.isDateLessOrEquals(this.date, this.hoveringDate))) {\n          return \"\".concat(classSelected, \" afterMinimumDurationValidDay\");\n        }\n\n        if (this.hoveringPeriod.periodType === 'nightly' && this.isDateLessOrEquals(this.date, this.hoveringDate)) {\n          return \"\".concat(classSelected, \"  afterMinimumDurationValidDay\");\n        }\n\n        if (this.checkIn && this.checkOut) {\n          return \"\".concat(classSelected);\n        }\n\n        return \"\".concat(classSelected, \" vhd__datepicker__month-day--valid\");\n      } // Good\n\n\n      if (this.isDisabled || this.isADisabledDay) {\n        return 'vhd__datepicker__month-day--disabled';\n      }\n\n      if (this.halfDayClass) {\n        return \"\".concat(this.halfDayClass);\n      } // Good\n\n\n      return 'vhd__datepicker__month-day--valid';\n    },\n    checkinCheckoutClass: function checkinCheckoutClass() {\n      var _this4 = this;\n\n      var currentPeriod = null;\n      this.sortedPeriodDates.forEach(function (d) {\n        if (d.endAt !== _this4.formatDate && (d.startAt === _this4.formatDate || _this4.validateDateBetweenTwoDates(d.startAt, d.endAt, _this4.formatDate))) {\n          currentPeriod = d;\n        }\n      });\n\n      if (this.nextPeriodDisableDates ? this.nextPeriodDisableDates.some(function (i) {\n        return _this4.compareDay(i, _this4.date) === 0;\n      }) : null) {\n        return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed nightly';\n      }\n\n      if (currentPeriod) {\n        if (currentPeriod.periodType === 'nightly' && this.belongsToThisMonth && !this.isDisabled) {\n          if ((!this.checkIn && !this.checkOut || this.checkIn && this.checkOut) && this.notAllowedDayDueToNextPeriod(currentPeriod)) {\n            return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed nightly';\n          }\n\n          return 'nightly';\n        } // date.getDay() === 6 => saturday\n\n\n        if (currentPeriod.periodType === 'weekly_by_saturday' && currentPeriod.startAt !== this.formatDate && currentPeriod.endAt !== this.formatDate && this.date.getDay() !== 6) {\n          return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed weekly_by_saturday';\n        } // Disable date between checkIn and nextDate, if minimumDuration is superior to 1\n\n\n        if (this.notAllowDaysBetweenCheckInAndNextValidDate(6)) {\n          return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed weekly_by_saturday';\n        } // date.getDay() === 0 => sunday\n\n\n        if (currentPeriod.periodType === 'weekly_by_sunday' && currentPeriod.startAt !== this.formatDate && currentPeriod.endAt !== this.formatDate && this.date.getDay() !== 0) {\n          return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed weekly_by_sunday';\n        } // Disable date between checkIn and nextDate, if minimumDuration is superior to 1\n\n\n        if (this.notAllowDaysBetweenCheckInAndNextValidDate(0)) {\n          return 'vhd__datepicker__month-day--disabled vhd__datepicker__month-day--not-allowed weekly_by_sunday';\n        }\n\n        return '';\n      }\n\n      return '';\n    },\n    formatDate: function formatDate() {\n      return this.dateFormater(this.date);\n    },\n    tabIndex: function tabIndex() {\n      if (!this.isOpen || !this.belongsToThisMonth || this.isDisabled || !this.isClickable()) {\n        return -1;\n      }\n\n      return 0;\n    },\n    nightsCount: function nightsCount() {\n      return this.countDays(this.checkIn, this.hoveringDate);\n    },\n    tooltipMessageDisplay: function tooltipMessageDisplay() {\n      var dateIsInPeriod = this.validateDateBetweenTwoDates(this.hoveringPeriod.startAt, this.hoveringPeriod.endAt, this.date);\n      var checkInIsInPeriod = this.validateDateBetweenTwoDates(this.hoveringPeriod.startAt, this.hoveringPeriod.endAt, this.checkIn);\n\n      if (this.tooltipMessage) {\n        return this.tooltipMessage;\n      }\n\n      if (this.hoveringPeriod && this.hoveringPeriod.type !== 'nightly' && dateIsInPeriod && checkInIsInPeriod && this.nightsCount >= 7) {\n        return \"\".concat(this.nightsCount / 7, \" \").concat(this.pluralize(this.nightsCount, 'week'));\n      }\n\n      if (this.nightsCount >= 1) {\n        return \"\".concat(this.nightsCount, \" \").concat(this.nightsCount !== 1 ? this.i18n.nights : this.i18n.night);\n      }\n\n      return '';\n    },\n    showTooltip: function showTooltip() {\n      if (this.screenSize === 'desktop' || this.screenSize === 'tablet') {\n        var showCustomTooltip = this.showCustomTooltip && this.date === this.hoveringDate;\n        var showDefaultTooltip = !this.isDisabled && this.belongsToThisMonth && this.date === this.hoveringDate && this.tooltipMessageDisplay.length > 0 && this.checkIn !== null && this.checkOut === null;\n        return showCustomTooltip || showDefaultTooltip;\n      }\n\n      return false;\n    },\n    isToday: function isToday() {\n      return this.compareDay(this.currentDate, this.date) === 0;\n    },\n    isADisabledDay: function isADisabledDay() {\n      var days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n      var day = days[this.date.getUTCDay()];\n      return this.options.disabledWeekDaysObject[day];\n    }\n  },\n  watch: {\n    hoveringDate: function hoveringDate() {\n      this.fetchHighlight();\n    },\n    checkIn: function checkIn() {\n      this.fetchHighlight();\n    },\n    activeMonthIndex: function activeMonthIndex() {\n      this.checkIfDisabled();\n      this.checkIfHighlighted();\n\n      if (this.checkIn !== null && this.checkOut !== null) {\n        if (this.isDateLessOrEquals(this.checkIn, this.date) && this.isDateLessOrEquals(this.date, this.checkOut)) {\n          this.isHighlighted = true;\n        } else {\n          this.isHighlighted = false;\n        }\n      } else if (this.checkIn !== null && this.checkOut === null) {\n        this.disableNextDays();\n      }\n    },\n    nextDisabledDate: function nextDisabledDate() {\n      this.disableNextDays();\n    }\n  },\n  beforeMount: function beforeMount() {\n    this.checkIfDisabled();\n    this.checkIfHighlighted();\n  },\n  methods: _objectSpread2(_objectSpread2({}, src_helpers), {}, {\n    notAllowDaysBetweenCheckInAndNextValidDate: function notAllowDaysBetweenCheckInAndNextValidDate(dayCode) {\n      return this.checkIn && !this.checkOut && this.date.getDay() === dayCode && Object.keys(this.hoveringPeriod).length > 0 && this.validateDateBetweenTwoDates(this.checkIn, this.hoveringPeriod.nextValidDate, this.date) && this.dateFormater(this.checkIn) !== this.formatDate && this.dateFormater(this.hoveringPeriod.nextValidDate) !== this.formatDate;\n    },\n    notAllowedDayDueToNextPeriod: function notAllowedDayDueToNextPeriod(currentPeriod) {\n      // Check if the next period is directly after the current period\n      var date = new Date(currentPeriod.endAt);\n      var nextPeriod = null;\n      this.sortedPeriodDates.forEach(function (period) {\n        var dateA = new Date(period.startAt).setHours(0, 0, 0, 0);\n        var dateB = new Date(date).setHours(0, 0, 0, 0);\n\n        if (dateA === dateB) {\n          nextPeriod = period;\n        }\n      });\n\n      if (nextPeriod) {\n        // Subtract the startAt nextPeriod to the currentPeriod minimumDuration\n        var subtractTimestamp = new Date(nextPeriod.startAt).setHours(0, 0, 0, 0);\n        var subtractDate = new Date(subtractTimestamp);\n        var resultDate = new Date(subtractDate.setDate(subtractDate.getDate() - currentPeriod.minimumDuration));\n\n        if (!this.validateDateBetweenTwoDates(currentPeriod.startAt, resultDate, this.date)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    isClickable: function isClickable() {\n      if (this.$refs && this.$refs.day) {\n        return getComputedStyle(this.$refs.day).pointerEvents !== 'none';\n      }\n\n      return true;\n    },\n    dayClicked: function dayClicked(event, date) {\n      var resetCheckin = false;\n      var disableCheckoutOnCheckin = !this.disableCheckoutOnCheckin;\n\n      if (!this.checkIncheckOutHalfDay[this.formatDate] && this.currentBooking) {\n        this.$emit('booking-clicked', event, date, this.currentBooking);\n        return;\n      }\n\n      if (this.disableCheckoutOnCheckin) {\n        if (this.checkIn && this.checkIn === date) {\n          if (this.checkOut) {\n            disableCheckoutOnCheckin = true;\n            resetCheckin = true;\n          } else {\n            disableCheckoutOnCheckin = false;\n            this.$emit('clear-selection');\n          }\n        } else {\n          disableCheckoutOnCheckin = true;\n        }\n      }\n\n      if (disableCheckoutOnCheckin) {\n        if (!this.isDisabled || this.isClickable()) {\n          var formatDate = this.dateFormater(date);\n          this.$emit('day-clicked', event, date, formatDate, resetCheckin);\n        } else {\n          this.$emit('clear-selection');\n          this.dayClicked(event, date);\n        }\n      }\n    },\n    compareEndDay: function compareEndDay() {\n      if (this.options.endDate !== Infinity) {\n        return this.compareDay(this.date, this.options.endDate) === 1;\n      }\n\n      return false;\n    },\n    checkIfDisabled: function checkIfDisabled() {\n      var _this5 = this;\n\n      this.isDisabled = // If this day is equal any of the disabled dates\n      (this.sortedDisabledDates ? this.sortedDisabledDates.some(function (i) {\n        return _this5.compareDay(i, _this5.date) === 0;\n      }) : null) || // Or is before the start date\n      this.compareDay(this.date, this.options.startDate) === -1 || // Or is after the end date\n      this.compareEndDay() || // Or is in one of the disabled days of the week\n      this.isADisabledDay || // Or is after max Nights\n      this.date >= this.nextDisabledDate && this.nextDisabledDate !== null; // Handle checkout enabled\n\n      if (this.options.enableCheckout) {\n        if (this.compareDay(this.date, this.checkIn) === 1 && this.compareDay(this.date, this.checkOut) === -1) {\n          this.isDisabled = false;\n        }\n      }\n    },\n    checkIfHighlighted: function checkIfHighlighted() {\n      if (this.checkIn !== null && this.checkOut !== null && this.isDisabled === false) {\n        if (this.isDateLessOrEquals(this.checkIn, this.date) && this.isDateLessOrEquals(this.date, this.checkOut)) {\n          this.isHighlighted = true;\n        } else {\n          this.isHighlighted = false;\n        }\n      }\n    },\n    disableNextDays: function disableNextDays() {\n      if (this.nextDisabledDate !== null && !this.isDateLessOrEquals(this.date, this.nextDisabledDate) && this.nextDisabledDate !== Infinity) {\n        this.isDisabled = true;\n      } else if (this.isDateLessOrEquals(this.date, new Date().setDate(this.options.startDate.getDate() - 1))) {\n        this.isDisabled = true;\n      }\n\n      if (this.compareDay(this.date, this.checkIn) === 0 && this.minNightCount === 0) {\n        this.isDisabled = false;\n      }\n\n      if (this.isDateLessOrEquals(this.checkIn, this.date) && this.options.enableCheckout) {\n        this.isDisabled = false;\n      }\n    },\n    fetchHighlight: function fetchHighlight() {\n      if (this.checkIn !== null && this.checkOut === null && this.isDisabled === false) {\n        if (!this.isDateLessOrEquals(this.checkIn, this.date)) {\n          this.isHighlighted = false;\n        } else if (this.isDateLessOrEquals(this.date, this.hoveringDate)) {\n          this.isHighlighted = true;\n        } else if (!this.isDateLessOrEquals(this.date, this.hoveringDate)) {\n          this.isHighlighted = false;\n        }\n      }\n    }\n  })\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/Day.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Dayvue_type_script_lang_js_ = (Dayvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/components/Day.vue\n\n\n\n\n\n/* normalize component */\n\nvar Day_component = normalizeComponent(\n  components_Dayvue_type_script_lang_js_,\n  Dayvue_type_template_id_0b134872_render,\n  Dayvue_type_template_id_0b134872_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Day = (Day_component.exports);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/WeekRow.vue?vue&type=template&id=3204cdf4&\nvar WeekRowvue_type_template_id_3204cdf4_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vhd__datepicker__week-row vhd__hide-up-to-tablet\"},_vm._l((_vm.dayNames),function(name,ix){return _c('div',{key:(_vm.weekKey + \"-\" + ix),staticClass:\"vhd__datepicker__week-name\"},[_vm._v(\" \"+_vm._s(name)+\" \")])}),0)}\nvar WeekRowvue_type_template_id_3204cdf4_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/WeekRow.vue?vue&type=template&id=3204cdf4&\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/WeekRow.vue?vue&type=script&lang=js&\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var WeekRowvue_type_script_lang_js_ = ({\n  name: 'WeekRow',\n  props: {\n    i18n: {\n      type: Object,\n      required: true\n    },\n    weekKey: {\n      type: Number,\n      required: true\n    },\n    firstDayOfWeek: {\n      type: Number,\n      required: true\n    }\n  },\n  computed: {\n    dayNames: function dayNames() {\n      return [].concat(_toConsumableArray(this.i18n['day-names'].slice(this.firstDayOfWeek)), _toConsumableArray(this.i18n['day-names'].slice(0, this.firstDayOfWeek))).slice(0, 7);\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/WeekRow.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_WeekRowvue_type_script_lang_js_ = (WeekRowvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/components/WeekRow.vue\n\n\n\n\n\n/* normalize component */\n\nvar WeekRow_component = normalizeComponent(\n  components_WeekRowvue_type_script_lang_js_,\n  WeekRowvue_type_template_id_3204cdf4_render,\n  WeekRowvue_type_template_id_3204cdf4_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var WeekRow = (WeekRow_component.exports);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/Month.vue?vue&type=script&lang=js&\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n/* harmony default export */ var Monthvue_type_script_lang_js_ = ({\n  name: 'Month',\n  components: {\n    Day: Day,\n    WeekRow: WeekRow\n  },\n  props: {\n    month: {\n      type: Object,\n      required: true\n    },\n    dayKey: {\n      type: Number,\n      required: true\n    },\n    weekKey: {\n      type: Number,\n      required: true\n    },\n    isDesktop: {\n      type: Boolean,\n      required: true\n    },\n    showYear: {\n      type: Boolean,\n      required: true\n    },\n    yearBeforeMonth: {\n      type: Boolean,\n      required: true\n    },\n    firstDayOfWeek: {\n      type: Number,\n      required: true\n    },\n    bookings: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    activeMonthIndex: {\n      type: Number\n    },\n    checkIn: {\n      type: Date\n    },\n    checkIncheckOutHalfDay: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    checkInPeriod: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    checkOut: {\n      type: Date\n    },\n    disableCheckoutOnCheckin: {\n      type: Boolean,\n      default: false\n    },\n    duplicateBookingDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    hoveringDate: {\n      type: Date\n    },\n    hoveringPeriod: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    hoveringTooltip: {\n      default: true,\n      type: Boolean\n    },\n    i18n: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    isOpen: {\n      type: Boolean,\n      required: true\n    },\n    minNightCount: {\n      type: Number,\n      default: 0\n    },\n    nextDisabledDate: {\n      type: [Date, Number, String]\n    },\n    nextPeriodDisableDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    options: {\n      type: Object\n    },\n    priceSymbol: {\n      type: String,\n      default: ''\n    },\n    priceDecimals: {\n      type: [Number, null],\n      default: 0\n    },\n    screenSize: {\n      type: String,\n      default: ''\n    },\n    showCustomTooltip: {\n      default: false,\n      type: Boolean\n    },\n    showPrice: {\n      type: Boolean,\n      default: false\n    },\n    showWeekNumbers: {\n      type: Boolean,\n      default: false\n    },\n    disabledDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    sortedDisabledDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    sortedPeriodDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    tooltipMessage: {\n      default: null,\n      type: String\n    }\n  },\n  computed: {\n    monthName: function monthName() {\n      return this.getMonth(this.month.days[15].date);\n    },\n    weekNumbers: function weekNumbers() {\n      var _this = this;\n\n      return this.month.days.filter(function (day, index) {\n        return index % 7 === 0 && (day.belongsToThisMonth || _this.month.days[index + 6].belongsToThisMonth);\n      }).map(function (day) {\n        return _this.getIsoWeek(day.date);\n      });\n    }\n  },\n  methods: _objectSpread2(_objectSpread2({}, src_helpers), {}, {\n    getMonth: function getMonth(date) {\n      var month = 'MMMM';\n      var year = 'YYYY';\n      var format = month; // const i18n = { monthNames: this.i18n['month-names'] }\n\n      if (this.showYear) {\n        format = this.yearBeforeMonth ? \"\".concat(year, \" \").concat(month) : \"\".concat(month, \" \").concat(year);\n      }\n\n      return lib_fecha.format(date, format).trim();\n    },\n    enterDay: function enterDay(event, day) {\n      this.$emit('enter-day', event, day);\n    },\n    enterMonth: function enterMonth(event) {\n      this.$emit('enter-month', event, this.month);\n    },\n    clearSelection: function clearSelection() {\n      this.$emit('clear-selection');\n    },\n    handleBookingClicked: function handleBookingClicked(event, date, currentBooking) {\n      this.$emit('booking-clicked', event, date, currentBooking);\n    },\n    handleDayClick: function handleDayClick(event, date, formatDate, resetCheckin) {\n      this.$emit('day-clicked', event, date, formatDate, resetCheckin);\n    }\n  })\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/Month.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_Monthvue_type_script_lang_js_ = (Monthvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/components/Month.vue\n\n\n\n\n\n/* normalize component */\n\nvar Month_component = normalizeComponent(\n  components_Monthvue_type_script_lang_js_,\n  Monthvue_type_template_id_7737dfd4_render,\n  Monthvue_type_template_id_7737dfd4_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var Month = (Month_component.exports);\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js?{\"cacheDirectory\":\"node_modules/.cache/vue-loader\",\"cacheIdentifier\":\"5532e410-vue-loader-template\"}!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/DateInput.vue?vue&type=template&id=34f958e6&\nvar DateInputvue_type_template_id_34f958e6_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vhd__datepicker__input\",class:_vm.inputClass,attrs:{\"data-qa\":\"vhd__datepickerInput\",\"tabindex\":_vm.tabIndex},on:{\"click\":_vm.toggleDatepicker,\"keyup\":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,\"enter\",13,$event.key,\"Enter\")){ return null; }$event.stopPropagation();$event.preventDefault();return _vm.toggleDatepicker.apply(null, arguments)}}},[_vm._v(\" \"+_vm._s(_vm.inputDate ? _vm.inputDate : _vm.i18n[_vm.inputDateType])+\" \")])}\nvar DateInputvue_type_template_id_34f958e6_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/DatePicker/components/DateInput.vue?vue&type=template&id=34f958e6&\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/components/DateInput.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n/* harmony default export */ var DateInputvue_type_script_lang_js_ = ({\n  props: {\n    isOpen: {\n      type: Boolean,\n      required: true\n    },\n    inputDate: {\n      type: String,\n      default: null\n    },\n    inputDateType: {\n      type: String,\n      default: 'check-in'\n    },\n    singleDaySelection: {\n      type: Boolean,\n      default: false\n    },\n    toggleDatepicker: {\n      type: Function,\n      required: true\n    },\n    i18n: {\n      type: Object,\n      required: true\n    }\n  },\n  computed: {\n    inputClass: function inputClass() {\n      return {\n        'vhd__datepicker__input--is-active': this.isOpen && this.inputDate == null,\n        'vhd__datepicker__input--single-date': this.singleDaySelection\n      };\n    },\n    tabIndex: function tabIndex() {\n      return this.inputDateType === 'check-in' ? 0 : -1;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/DatePicker/components/DateInput.vue?vue&type=script&lang=js&\n /* harmony default export */ var components_DateInputvue_type_script_lang_js_ = (DateInputvue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/components/DateInput.vue\n\n\n\n\n\n/* normalize component */\n\nvar DateInput_component = normalizeComponent(\n  components_DateInputvue_type_script_lang_js_,\n  DateInputvue_type_template_id_34f958e6_render,\n  DateInputvue_type_template_id_34f958e6_staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var DateInput = (DateInput_component.exports);\n// CONCATENATED MODULE: ./public/i18n/en.js\n/* harmony default export */ var en = ({\n  night: 'Night',\n  nights: 'Nights',\n  week: 'Week',\n  weeks: 'Weeks',\n  'day-names': ['Sun', 'Mon', 'Tue', 'Wed', 'Thur', 'Fri', 'Sat'],\n  'check-in': 'Check-in',\n  'check-out': 'Check-out',\n  'month-names': ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  tooltip: {\n    halfDayCheckIn: 'Available CheckIn',\n    halfDayCheckOut: 'Available CheckOut',\n    saturdayToSaturday: 'Only Saturday to Saturday',\n    sundayToSunday: 'Only Sunday to Sunday',\n    minimumRequiredPeriod: '%{minNightInPeriod} %{night} minimum.'\n  }\n});\n// CONCATENATED MODULE: ./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/.pnpm/thread-loader@2.1.3_webpack@4.46.0/node_modules/thread-loader/dist/cjs.js!./node_modules/.pnpm/babel-loader@8.2.2_44cd8e8988e8f6bdf4058c352d4e72dd/node_modules/babel-loader/lib!./node_modules/.pnpm/cache-loader@4.1.0_webpack@4.46.0/node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/.pnpm/vue-loader@15.9.7_679359cdb69c218f2f8f476b2ba08796/node_modules/vue-loader/lib??vue-loader-options!./src/DatePicker/HotelDatePicker.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ var HotelDatePickervue_type_script_lang_js_ = ({\n  name: 'HotelDatePicker',\n  components: {\n    Month: Month,\n    DateInput: DateInput\n  },\n  props: {\n    alwaysVisible: {\n      type: Boolean,\n      default: false\n    },\n    bookings: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    closeDatepickerOnClickOutside: {\n      type: Boolean,\n      default: true\n    },\n    disableCheckoutOnCheckin: {\n      type: Boolean,\n      default: false\n    },\n    disabledDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    disabledDaysOfWeek: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    disabledWeekDays: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    },\n    displayClearButton: {\n      type: Boolean,\n      default: true\n    },\n    enableCheckout: {\n      type: Boolean,\n      default: false\n    },\n    endDate: {\n      type: [Date, String, Number],\n      default: Infinity\n    },\n    endingDateValue: {\n      type: [Date, null],\n      default: null\n    },\n    firstDayOfWeek: {\n      type: Number,\n      default: 0\n    },\n    format: {\n      type: String,\n      default: 'YYYY-MM-DD'\n    },\n    gridStyle: {\n      type: Boolean,\n      default: true\n    },\n    halfDay: {\n      type: Boolean,\n      default: true\n    },\n    hoveringTooltip: {\n      default: true,\n      type: [Boolean, Function]\n    },\n    i18n: {\n      type: Object,\n      default: function _default() {\n        return en;\n      }\n    },\n    lastDateAvailable: {\n      type: [Number, Date],\n      default: Infinity\n    },\n    maxNights: {\n      type: [Number, null],\n      default: null\n    },\n    minNights: {\n      type: Number,\n      default: 1\n    },\n    periodDates: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    positionRight: {\n      type: Boolean,\n      default: false\n    },\n    priceSymbol: {\n      type: String,\n      default: ''\n    },\n    showPrice: {\n      type: Boolean,\n      default: false\n    },\n    showSingleMonth: {\n      type: Boolean,\n      default: false\n    },\n    showYear: {\n      type: Boolean,\n      default: true\n    },\n    showWeekNumbers: {\n      type: Boolean,\n      default: false\n    },\n    singleDaySelection: {\n      type: Boolean,\n      default: false\n    },\n    startDate: {\n      type: [Date, String],\n      default: function _default() {\n        return new Date();\n      }\n    },\n    startingDateValue: {\n      type: [Date, null],\n      default: null\n    },\n    tooltipMessage: {\n      type: [String, null],\n      default: null\n    },\n    value: {\n      type: Boolean,\n      default: true\n    },\n    yearBeforeMonth: {\n      type: Boolean,\n      default: false\n    }\n  },\n  data: function data() {\n    return {\n      activeMonthIndex: 0,\n      checkIn: this.startingDateValue,\n      checkIncheckOutHalfDay: {},\n      checkInPeriod: {},\n      checkOut: this.endingDateValue,\n      hoveringPeriod: {},\n      customTooltip: '',\n      customTooltipHalfday: '',\n      datepickerDayKey: 0,\n      datepickerMonthKey: 0,\n      datepickerWeekKey: 0,\n      dynamicNightCounts: null,\n      hash: Date.now(),\n      hoveringDate: null,\n      isTouchMove: false,\n      months: [],\n      nextDisabledDate: null,\n      nextPeriodDisableDates: [],\n      open: false,\n      screenSize: null,\n      showCustomTooltip: false,\n      sortedDisabledDates: null,\n      xDown: null,\n      xUp: null,\n      yDown: null,\n      yUp: null\n    };\n  },\n  computed: {\n    isOpen: {\n      get: function get() {\n        return this.open;\n      },\n      set: function set(open) {\n        var _this = this;\n\n        this.open = open;\n\n        if (!this.isDesktop && !this.alwaysVisible) {\n          var body = document.querySelector('body');\n\n          if (open) {\n            body.style.overflow = 'hidden';\n            this.$nextTick(function () {\n              if (_this.$refs) {\n                var swiperWrapper = _this.$refs.swiperWrapper;\n                var monthHeihgt = _this.$refs.datepickerMonth[0].offsetHeight;\n                var currentSelectionIndex = _this.checkOut ? _this.getMonthDiff(new Date(), _this.checkOut) : 0;\n                swiperWrapper.scrollTop = currentSelectionIndex * monthHeihgt;\n              }\n            });\n          } else {\n            body.style.overflow = '';\n          }\n        }\n\n        this.$emit('input', this.open);\n      }\n    },\n    sortBookings: function sortBookings() {\n      if (this.bookings.length > 0) {\n        var bookings = _toConsumableArray(this.bookings);\n\n        return bookings.sort(function (a, b) {\n          var aa = a.checkInDate.split('/').reverse().join();\n          var bb = b.checkOutDate.split('/').reverse().join(); // eslint-disable-next-line no-nested-ternary\n\n          return aa < bb ? -1 : aa > bb ? 1 : 0;\n        });\n      }\n\n      return [];\n    },\n    duplicateBookingDates: function duplicateBookingDates() {\n      return this.baseHalfDayDates.filter(function (newArr) {\n        return function (date) {\n          return newArr.has(date) || !newArr.add(date);\n        };\n      }(new Set()));\n    },\n    baseHalfDayDates: function baseHalfDayDates() {\n      if (this.sortBookings.length > 0) {\n        var bookings = this.sortBookings.map(function (x) {\n          return [x.checkInDate, x.checkOutDate];\n        });\n        return bookings.reduce(function (a, b) {\n          return a.concat(b);\n        });\n      }\n\n      return this.disabledDates;\n    },\n    paginateMonths: function paginateMonths() {\n      var months = [this.months[this.activeMonthIndex]];\n\n      if (!(this.showSingleMonth || this.alwaysVisible && !this.isDesktop)) {\n        months.push(this.months[this.activeMonthIndex + 1]);\n      }\n\n      return months;\n    },\n    customTooltipMessage: function customTooltipMessage() {\n      var tooltip = '';\n\n      if (this.hoveringDate && (this.customTooltip || this.customTooltipHalfday)) {\n        if (this.customTooltip && this.customTooltipHalfday) {\n          tooltip = \"\".concat(this.customTooltipHalfday, \". <br/> \").concat(this.customTooltip);\n        } else if (this.customTooltipHalfday && !this.customTooltip) {\n          tooltip = this.customTooltipHalfday;\n        } else {\n          tooltip = this.customTooltip;\n        }\n\n        return tooltip;\n      }\n\n      return this.tooltipMessage;\n    },\n    sortedPeriodDates: function sortedPeriodDates() {\n      var periodDates = [];\n\n      if (this.periodDates) {\n        var sortFunction = function sortFunction(fecha1, fecha2) {\n          var v1 = fecha1.startAt.split('/').reverse().join() + fecha1.endAt.split('/').reverse().join();\n          var v2 = fecha2.startAt.split('/').reverse().join() + fecha2.endAt.split('/').reverse().join(); // eslint-disable-next-line no-nested-ternary\n\n          return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;\n        };\n\n        periodDates = _toConsumableArray(this.periodDates).sort(sortFunction);\n      }\n\n      return periodDates;\n    },\n    sliceMonthMobile: function sliceMonthMobile() {\n      var nbMonthRenderDom = 4;\n\n      if (this.activeMonthIndex >= nbMonthRenderDom) {\n        return this.months.slice(this.activeMonthIndex - 3, this.activeMonthIndex + 1);\n      }\n\n      return this.months.slice(0, nbMonthRenderDom);\n    },\n    isPreventedMaxMonth: function isPreventedMaxMonth() {\n      var lastIndexMonthAvailable = this.getMonthDiff(this.startDate, this.lastDateAvailable);\n      return this.activeMonthIndex >= lastIndexMonthAvailable - 1;\n    },\n    minNightCount: function minNightCount() {\n      return this.dynamicNightCounts || this.minNights;\n    },\n    showClearSelectionButton: function showClearSelectionButton() {\n      return Boolean((this.checkIn || this.checkOut) && this.displayClearButton);\n    },\n    disabledWeekDaysObject: function disabledWeekDaysObject() {\n      var disabledDays = this.disabledDaysOfWeek.map(function (d) {\n        return d.toLowerCase();\n      }); // const names = this.i18n['day-names']\n\n      var names = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n      var SUNDAY = names[0];\n      var MONDAY = names[1];\n      var TUESDAY = names[2];\n      var WEDNESDAY = names[3];\n      var THURSDAY = names[4];\n      var FRIDAY = names[5];\n      var SATURDAY = names[6]; // The order of _default is important!\n\n      var disabledWeekDaysObject = {\n        sunday: disabledDays.includes(SUNDAY),\n        monday: disabledDays.includes(MONDAY),\n        tuesday: disabledDays.includes(TUESDAY),\n        wednesday: disabledDays.includes(WEDNESDAY),\n        thursday: disabledDays.includes(THURSDAY),\n        friday: disabledDays.includes(FRIDAY),\n        saturday: disabledDays.includes(SATURDAY)\n      };\n      return Object.assign(disabledWeekDaysObject, this.disabledWeekDays);\n    },\n    disabledWeekDaysArray: function disabledWeekDaysArray() {\n      var days = this.disabledWeekDaysObject; // const names = this.i18n['day-names']\n\n      var names = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\n\n      var fn = function fnDisabledWeekDaysArray(day, ix) {\n        return day[1] ? names[ix] : false;\n      };\n\n      return Object.entries(days).map(fn).filter(function (v) {\n        return v;\n      });\n    },\n    dayOptions: function dayOptions() {\n      return _objectSpread2(_objectSpread2({}, this.$props), {}, {\n        disabledWeekDaysObject: this.disabledWeekDaysObject\n      });\n    },\n    numberOfMonths: function numberOfMonths() {\n      return this.showSingleMonth ? 1 : 2;\n    },\n    isDesktop: function isDesktop() {\n      return this.screenSize === 'desktop';\n    }\n  },\n  watch: {\n    bookings: function bookings() {\n      this.createHalfDayDates(this.baseHalfDayDates);\n      this.reRender();\n    },\n    checkIn: function checkIn(newDate) {\n      this.$emit('check-in-changed', newDate);\n      this.$emit('starting-date-changed', newDate);\n      this.reRender();\n    },\n    checkOut: function checkOut(newDate) {\n      this.$emit('ending-date-changed', newDate);\n\n      if (this.checkOut !== null) {\n        this.hoveringDate = null;\n        this.nextDisabledDate = null;\n        this.createHalfDayDates(this.baseHalfDayDates);\n        this.reRender();\n        this.showCustomTooltip = false;\n        this.isOpen = false;\n      }\n\n      this.$emit('check-out-changed', newDate);\n      this.reRender();\n    },\n    firstDayOfWeek: function firstDayOfWeek(newDay) {\n      this.$emit('first-day-of-week-changed', newDay);\n      var startDate = new Date(this.startDate);\n      var offset = this.numberOfMonths + this.activeMonthIndex;\n      this.generateInitialMonths();\n\n      for (var i = this.numberOfMonths; i < offset; i++) {\n        this.createMonth(new Date(startDate.getFullYear(), startDate.getMonth() + i, 1));\n      }\n\n      this.reRender();\n    },\n    startingDateValue: function startingDateValue(date) {\n      this.setCheckIn(date);\n    },\n    endingDateValue: function endingDateValue(date) {\n      this.setCheckOut(date);\n    },\n    singleDaySelection: function singleDaySelection(single) {\n      if (single) {\n        this.setCheckOut(this.checkIn);\n      } else {\n        this.setCheckIn(this.checkIn);\n        this.setCheckOut(null);\n      }\n\n      this.reRender();\n    },\n    yearBeforeMonth: function yearBeforeMonth() {\n      this.reRender();\n    },\n    i18n: function i18n() {\n      this.configureI18n();\n    },\n    disabledDates: function disabledDates() {\n      this.nextDisabledDate = null;\n      this.createHalfDayDates(this.baseHalfDayDates);\n      this.reRender();\n    }\n  },\n  created: function created() {\n    this.configureI18n();\n    this.generateInitialMonths();\n  },\n  mounted: function mounted() {\n    var _this2 = this;\n\n    this.handleWindowResize();\n    window.addEventListener('resize', this.handleWindowResize);\n\n    if (!this.isDesktop) {\n      document.addEventListener('touchstart', this.handleTouchStart, false);\n      document.addEventListener('touchmove', this.handleTouchMove, false);\n      document.addEventListener('touchend', this.handleTouchEnd, false);\n    } else {\n      document.addEventListener('click', this.handleClickOutside, false);\n      document.addEventListener('keyup', this.escFunction, false);\n    }\n\n    this.onElementHeightChange(document.body, function () {\n      _this2.emitHeighChangeEvent();\n    });\n    this.createHalfDayDates(this.baseHalfDayDates);\n  },\n  destroyed: function destroyed() {\n    window.removeEventListener('resize', this.handleWindowResize);\n\n    if (!this.isDesktop) {\n      document.removeEventListener('touchstart', this.handleTouchStart);\n      document.removeEventListener('touchmove', this.handleTouchMove);\n      document.removeEventListener('touchend', this.handleTouchEnd);\n    } else {\n      document.removeEventListener('keyup', this.escFunction, false);\n      document.removeEventListener('click', this.handleClickOutside);\n    }\n  },\n  methods: _objectSpread2(_objectSpread2({}, src_helpers), {}, {\n    transformDisabledWeekDays: function transformDisabledWeekDays() {},\n    configureI18n: function configureI18n() {\n      lib_fecha.setGlobalDateI18n({\n        dayNames: this.i18n['day-names'],\n        dayNamesShort: this.shortenString(this.i18n['day-names'], 3),\n        monthNames: this.i18n['month-names'],\n        monthNamesShort: this.shortenString(this.i18n['month-names'], 3),\n        amPm: ['am', 'pm'],\n        // D is the day of the month, function returns something like...  3rd or 11th\n        DoFn: function DoFn(D) {\n          return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];\n        }\n      });\n    },\n    generateInitialMonths: function generateInitialMonths() {\n      this.months = [];\n\n      if (this.checkIn && (this.getMonthDiff(this.getNextMonth(new Date(this.startDate)), this.checkIn) > 0 || this.getMonthDiff(this.startDate, this.checkIn) > 0)) {\n        this.createMonth(new Date(this.startDate));\n        var count = this.getMonthDiff(this.startDate, this.checkIn);\n        var monthCount = this.showSingleMonth ? count - 1 : count;\n        var nextMonth = new Date(this.startDate);\n\n        for (var i = 0; i <= monthCount; i++) {\n          var tempNextMonth = this.getNextMonth(nextMonth);\n          this.createMonth(tempNextMonth);\n          nextMonth = tempNextMonth;\n        }\n\n        if (this.checkOut && this.getMonthDiff(this.checkIn, this.checkOut) > 0) {\n          this.createMonth(this.getNextMonth(nextMonth));\n          this.activeMonthIndex = 1;\n        }\n\n        this.activeMonthIndex += count;\n      } else {\n        this.createMonth(new Date(this.startDate));\n\n        if (!this.showSingleMonth) {\n          this.createMonth(this.getNextMonth(new Date(this.startDate)));\n        }\n      }\n    },\n    handleBookingClicked: function handleBookingClicked(event, date, currentBooking) {\n      this.$emit('booking-clicked', event, date, currentBooking);\n      /**\n       * @deprecated since v4.0.0 beta 11\n       */\n\n      this.$emit('bookingClicked', event, date, currentBooking);\n    },\n    escFunction: function escFunction(e) {\n      var escTouch = 27;\n\n      if (e.keyCode === escTouch && this.isOpen && this.checkIn) {\n        this.clearSelection();\n      }\n    },\n    formatDate: function formatDate(date) {\n      return this.dateFormater(date, this.format);\n    },\n    cleanString: function cleanString(string) {\n      // eslint-disable-next-line no-useless-escape\n      return string.replace(/\\<br\\/>/g, '');\n    },\n    dateIsInCheckInCheckOut: function dateIsInCheckInCheckOut(date) {\n      var _this3 = this;\n\n      var compareDate = this.dateFormater(date);\n      var currentPeriod = null;\n      this.sortedPeriodDates.forEach(function (d) {\n        if (d.endAt !== compareDate && (d.startAt === compareDate || _this3.validateDateBetweenTwoDates(d.startAt, d.endAt, compareDate))) {\n          currentPeriod = d;\n        }\n      });\n      return currentPeriod;\n    },\n    dayIsDisabled: function dayIsDisabled(date) {\n      if (this.checkIn && !this.checkOut && !this.isDateLessOrEquals(date, this.nextDisabledDate) && this.nextDisabledDate !== Infinity) {\n        return true;\n      }\n\n      if (this.checkIn && !this.checkOut && this.isDateLessOrEquals(date, this.checkIn)) {\n        return true;\n      }\n\n      return false;\n    },\n    enterMonth: function enterMonth(event, month) {\n      this.$emit('enter-month', event, month);\n    },\n    enterDay: function enterDay(event, day) {\n      var formatDate = this.dateFormater(day.date);\n      var halfDays = Object.keys(this.checkIncheckOutHalfDay);\n      var disableDays = this.disabledDates.filter(function (disableDate) {\n        return !halfDays.includes(disableDate);\n      }).includes(formatDate);\n\n      if (!this.dayIsDisabled(day.date) && day.belongsToThisMonth && !disableDays) {\n        this.setCustomTooltipOnHover(day);\n      }\n\n      this.hoveringDate = this.singleDaySelection ? null : day.date;\n      this.$emit('enter-day', event, day);\n    },\n    setCurrentPeriod: function setCurrentPeriod(date, eventType) {\n      var _this4 = this;\n\n      var currentPeriod = {};\n\n      if (this.sortedPeriodDates.length > 0) {\n        this.sortedPeriodDates.forEach(function (d) {\n          if (eventType === 'click' && (d.startAt === _this4.dateFormater(date) || d.endAt !== _this4.dateFormater(date) && _this4.validateDateBetweenTwoDates(d.startAt, d.endAt, date))) {\n            currentPeriod = d;\n          } else if (eventType === 'hover' && (d.startAt === _this4.dateFormater(date) || _this4.validateDateBetweenTwoDates(d.startAt, d.endAt, date))) {\n            currentPeriod = d;\n          }\n        });\n\n        if (Object.keys(currentPeriod).length > 0) {\n          this.hoveringPeriod = currentPeriod;\n        } else if (this.minNightCount > 0 && this.checkIn) {\n          this.hoveringPeriod = {\n            periodType: 'nightly',\n            minimumDuration: this.minNightCount,\n            startAt: this.checkIn,\n            endAt: this.addDays(this.checkIn, this.minNightCount)\n          };\n        } else {\n          this.hoveringPeriod = {\n            periodType: 'nightly',\n            minimumDuration: this.minNightCount,\n            startAt: this.checkIn,\n            endAt: this.addDays(this.checkIn, this.minNightCount)\n          };\n        }\n      } else if (this.minNightCount > 0) {\n        this.hoveringPeriod = {\n          periodType: 'nightly',\n          minimumDuration: this.minNightCount,\n          startAt: this.checkIn,\n          endAt: this.addDays(this.checkIn, this.minNightCount)\n        };\n      }\n    },\n    setCustomTooltipOnHover: function setCustomTooltipOnHover(day) {\n      var date = day.date;\n      this.hoveringDate = date;\n      if (this.showCustomTooltip) this.showCustomTooltip = false;\n      this.setCurrentPeriod(date, 'hover');\n\n      if (Object.keys(this.hoveringPeriod).length > 0) {\n        // Create tooltip\n        if (this.hoveringPeriod.periodType === 'weekly_by_saturday') {\n          var dayCode = 6;\n          var text = this.i18n.tooltip.saturdayToSaturday;\n          this.showTooltipWeeklyOnHover(date, dayCode, text);\n        } else if (this.hoveringPeriod.periodType === 'weekly_by_sunday') {\n          var _dayCode = 0;\n          var _text = this.i18n.tooltip.sundayToSunday;\n          this.showTooltipWeeklyOnHover(date, _dayCode, _text);\n        } else if (this.hoveringPeriod.periodType === 'nightly') {\n          this.showTooltipNightlyOnHover(date);\n        } else {\n          // Clean tooltip\n          this.showCustomTooltip = false;\n          this.customTooltip = '';\n        }\n      } else {\n        this.hoveringPeriod = {};\n      }\n\n      if (this.halfDay) {\n        this.createHalfDayTooltip(day.date);\n      }\n    },\n    handleDayClick: function handleDayClick(event, date, formatDate, resetCheckin) {\n      var _this5 = this;\n\n      this.nextPeriodDisableDates = [];\n\n      if (resetCheckin) {\n        this.clearSelection();\n        this.$nextTick(function () {\n          _this5.handleDayClick(event, date, formatDate, false);\n        });\n        return;\n      }\n\n      var nextDisabledDate = (this.maxNights ? this.addDays(date, this.maxNights + 1) : null) || this.getNextDate(this.sortedDisabledDates, date) || this.nextDateByDayOfWeekArray(this.disabledWeekDaysArray, date, this.i18n) || this.nextBookingDate(date) || Infinity;\n      this.dynamicNightCounts = null;\n\n      if (this.enableCheckout) {\n        nextDisabledDate = Infinity;\n      }\n\n      if (this.checkIn == null && !this.singleDaySelection) {\n        this.checkIn = date;\n        this.$emit('check-in-selected', date);\n        this.setMinimumDuration(date);\n      } else if (this.singleDaySelection) {\n        this.checkIn = date;\n        this.$emit('check-in-selected', date);\n        this.checkOut = date;\n      } else if (this.checkIn !== null && this.checkOut == null && this.isDateLessOrEquals(date, this.checkIn)) {\n        this.checkIn = date;\n        this.$emit('check-in-selected', date);\n      } else if (this.checkIn !== null && this.checkOut == null) {\n        this.checkOut = date;\n        this.$emit('period-selected', event, this.checkIn, this.checkOut);\n        /**\n         * @deprecated since v4.0.0 beta 11\n         */\n\n        this.$emit('periodSelected', event, this.checkIn, this.checkOut);\n      } else {\n        this.checkOut = null;\n        this.checkIn = date;\n        this.$emit('check-in-selected', date);\n        this.setMinimumDuration(date);\n      }\n\n      if (this.checkIn && !this.checkOut) {\n        this.setCurrentPeriod(date, 'click');\n        this.checkInPeriod = this.hoveringPeriod;\n        this.setCustomTooltipOnClick();\n      }\n\n      this.nextDisabledDate = nextDisabledDate;\n      this.hoveringDate = null;\n      this.hoveringDate = date;\n      this.$emit('day-clicked', date, formatDate, nextDisabledDate);\n      /**\n       * @deprecated since v4.0.0 beta 11\n       */\n\n      this.$emit('dayClicked', date, formatDate, nextDisabledDate);\n    },\n    nextBookingDate: function nextBookingDate(date) {\n      var _this6 = this;\n\n      var closest = Infinity;\n\n      if (this.sortBookings.length > 0) {\n        var nextDateFormated = this.dateFormater(this.addDays(date, 1));\n        var nextBooking = this.sortBookings.find(function (booking) {\n          return _this6.validateDateBetweenDate(booking.checkInDate, nextDateFormated) || _this6.validateDateBetweenTwoDates(booking.checkInDate, booking.checkOutDate, nextDateFormated);\n        });\n        closest = nextBooking ? nextBooking.checkInDate : Infinity;\n      }\n\n      return closest;\n    },\n    setCustomTooltipOnClick: function setCustomTooltipOnClick() {\n      if (Object.keys(this.checkInPeriod).length > 0 && this.checkInPeriod.periodType.includes('weekly')) {\n        var nextValidDate = this.addDays(this.checkIn, this.minNightCount);\n        this.checkInPeriod.nextValidDate = nextValidDate;\n        this.showTooltipWeeklyOnClick();\n      } else if (this.checkInPeriod.periodType === 'nightly') {\n        this.showTooltipNightlyOnClick();\n      }\n    },\n    showTooltipWeeklyOnHover: function showTooltipWeeklyOnHover(date, periodDayType, text) {\n      var countDaysBetweenCheckInCurrentDay = this.countDays(this.checkIn, date);\n      var notOnPeriodDayType = date.getDay() !== periodDayType;\n      var isCheckInCheckOut = this.checkIn && this.checkOut;\n      var notCheckInNotPeriodDayType = !this.checkIn && notOnPeriodDayType;\n      var isCheckInNotCheckOut = this.checkIn && !this.checkOut;\n      var isNotBetweenCheckInAndCheckOut = !this.validateDateBetweenTwoDates(this.checkIn, this.checkOut, date);\n      var notAllowDaysBetweenCheckInAndNextValidDate = this.hoveringPeriod.nextValidDate && this.validateDateBetweenTwoDates(this.checkIn, this.hoveringPeriod.nextValidDate, this.hoveringDate) && this.dateFormater(this.checkIn) !== this.dateFormater(this.hoveringDate) && this.dateFormater(this.hoveringPeriod.nextValidDate) !== this.dateFormater(this.hoveringDate);\n      var hasHalfDayOnWeeklyPeriod = Object.keys(this.checkIncheckOutHalfDay).length > 0 && this.checkIncheckOutHalfDay[this.dateFormater(date)] && this.checkIncheckOutHalfDay[this.dateFormater(date)].checkIn; // Show tooltip on not-allowed day\n\n      if (notCheckInNotPeriodDayType) {\n        this.showCustomTooltip = true;\n        this.customTooltip = text;\n      } else {\n        this.showCustomTooltip = false;\n        this.customTooltip = '';\n      } // Show tooltip when CheckIn\n\n\n      if (isCheckInNotCheckOut) {\n        var nextDayValid = this.addDays(this.checkIn, this.minNightCount);\n        var isDateAfterMinimumDuration = this.getDayDiff(date, nextDayValid) <= 0;\n\n        if (isDateAfterMinimumDuration && notOnPeriodDayType) {\n          this.showCustomTooltip = true;\n          this.customTooltip = text;\n        } else if (notOnPeriodDayType || notAllowDaysBetweenCheckInAndNextValidDate) {\n          if (this.checkInPeriod && this.checkInPeriod.periodType === 'nightly') {\n            this.showCustomTooltip = false;\n            this.customTooltip = '';\n          } else {\n            // Show default message on currentDay\n            var night = this.pluralize(this.minNightCount, 'week');\n            this.showCustomTooltip = true;\n            this.customTooltip = this.completeTrad(this.i18n.tooltip.minimumRequiredPeriod, {\n              minNightInPeriod: this.minNightCount / 7,\n              night: night\n            });\n          }\n        } else if (hasHalfDayOnWeeklyPeriod) {\n          // Show the correct wording in comparison to periodType of this.checkInPeriod equal to \"nightly\" / \"weekly\"\n          if (this.checkInPeriod.periodType !== 'nightly') {\n            this.customTooltip = \"\".concat(countDaysBetweenCheckInCurrentDay / 7, \" \").concat(this.pluralize(this.minNightCount, 'week'));\n          } else if (this.checkInPeriod.periodType === 'nightly') {\n            this.customTooltip = \"\".concat(countDaysBetweenCheckInCurrentDay, \" \").concat(countDaysBetweenCheckInCurrentDay !== 1 ? this.i18n.nights : this.i18n.night);\n          }\n        } else {\n          // Clean tooltip\n          this.showCustomTooltip = false;\n          this.customTooltip = '';\n        } // Show tooltip when CheckIn & CheckOut on all the days that are not between checkIn and CheckOut\n\n      } else if (isCheckInCheckOut && notOnPeriodDayType && isNotBetweenCheckInAndCheckOut) {\n        this.showCustomTooltip = true;\n        this.customTooltip = text;\n      }\n    },\n    showTooltipWeeklyOnClick: function showTooltipWeeklyOnClick() {\n      var night = this.pluralize(this.minNightCount, 'week');\n      this.showCustomTooltip = true;\n      this.customTooltip = this.completeTrad(this.i18n.tooltip.minimumRequiredPeriod, {\n        minNightInPeriod: this.minNightCount / 7,\n        night: night\n      });\n    },\n    showTooltipNightlyOnHover: function showTooltipNightlyOnHover(date) {\n      if (this.checkIn && !this.checkOut) {\n        var nextDayValid = this.addDays(this.checkIn, this.minNightCount);\n        var isDateAfterMinimumDuration = this.getDayDiff(date, nextDayValid) <= 0;\n        var countOfDays = this.countDays(this.checkIn, date);\n        var night = this.pluralize(Math.max(this.minNightCount, countOfDays));\n\n        if (!isDateAfterMinimumDuration) {\n          var minNightInPeriod = this.hoveringPeriod.minimumDuration;\n          this.showCustomTooltip = true;\n          this.customTooltip = this.completeTrad(this.i18n.tooltip.minimumRequiredPeriod, {\n            minNightInPeriod: minNightInPeriod,\n            night: night\n          });\n        } else {\n          this.customTooltip = \"\".concat(countOfDays, \" \").concat(night);\n        }\n      } else {\n        this.customTooltip = '';\n      }\n    },\n    showTooltipNightlyOnClick: function showTooltipNightlyOnClick() {\n      var minNightInPeriod = this.hoveringPeriod.minimumDuration;\n      var night = this.pluralize(this.minNightCount);\n      this.showCustomTooltip = true;\n      this.customTooltip = this.completeTrad(this.i18n.tooltip.minimumRequiredPeriod, {\n        minNightInPeriod: minNightInPeriod,\n        night: night\n      });\n    },\n    createHalfDayTooltip: function createHalfDayTooltip(date) {\n      this.customTooltipHalfday = '';\n      var formatedHoveringDate = this.dateFormater(date);\n\n      if (this.checkIncheckOutHalfDay[formatedHoveringDate]) {\n        this.showCustomTooltip = true;\n\n        if (this.checkIncheckOutHalfDay[formatedHoveringDate].checkIn) {\n          this.customTooltipHalfday = this.i18n.tooltip.halfDayCheckOut;\n        } else if (this.checkIncheckOutHalfDay[formatedHoveringDate].checkOut) {\n          this.customTooltipHalfday = this.i18n.tooltip.halfDayCheckIn;\n        }\n      }\n    },\n    completeTrad: function completeTrad(translation, keys) {\n      var newT = translation;\n      var keysTranslations = Object.keys(keys);\n      keysTranslations.forEach(function (key) {\n        newT = newT.replace(\"%{\".concat(key, \"}\"), keys[key]);\n      });\n      return newT;\n    },\n    handleClickOutside: function handleClickOutside(event) {\n      var ignoreClickOnMeElement = this.$refs[\"DatePicker-\".concat(this.hash)];\n\n      if (ignoreClickOnMeElement) {\n        var isClickInsideElement = ignoreClickOnMeElement.contains(event.target);\n\n        if (!isClickInsideElement) {\n          this.hideDatepicker();\n        }\n      }\n    },\n    handleWindowResize: function handleWindowResize() {\n      if (window.innerWidth < 480) {\n        this.screenSize = 'smartphone';\n      } else if (window.innerWidth >= 480 && window.innerWidth < 768) {\n        this.screenSize = 'tablet';\n      } else if (window.innerWidth >= 768) {\n        this.screenSize = 'desktop';\n      }\n\n      return this.screenSize;\n    },\n    onElementHeightChange: function onElementHeightChange(el, callback) {\n      var lastHeight = el.clientHeight;\n      var newHeight = lastHeight;\n      var newEl = el;\n\n      (function run() {\n        newHeight = el.clientHeight;\n\n        if (lastHeight !== newHeight) {\n          callback();\n        }\n\n        lastHeight = newHeight;\n\n        if (newEl.onElementHeightChangeTimer) {\n          clearTimeout(el.onElementHeightChangeTimer);\n        }\n\n        newEl.onElementHeightChangeTimer = setTimeout(run, 1000);\n      })();\n    },\n    emitHeighChangeEvent: function emitHeighChangeEvent() {\n      this.$emit('height-changed');\n    },\n    reRender: function reRender() {\n      this.datepickerDayKey += 1;\n      this.datepickerMonthKey += 1;\n      this.datepickerWeekKey += 1;\n    },\n    clearSelection: function clearSelection() {\n      this.hoveringDate = null;\n      this.checkIn = null;\n      this.checkOut = null;\n      this.nextDisabledDate = null;\n      this.nextPeriodDisableDates = [];\n      this.showCustomTooltip = false;\n      this.hoveringPeriod = {};\n      this.checkInPeriod = {};\n      this.createHalfDayDates(this.baseHalfDayDates);\n      this.reRender();\n      this.$emit('clear-selection');\n    },\n    closeMobileDatepicker: function closeMobileDatepicker() {\n      this.hideDatepicker();\n    },\n    hideDatepicker: function hideDatepicker() {\n      this.isOpen = false;\n    },\n    showDatepicker: function showDatepicker() {\n      this.isOpen = true;\n    },\n    toggleDatepicker: function toggleDatepicker() {\n      this[this.isOpen ? 'hideDatepicker' : 'showDatepicker']();\n    },\n    clearCheckIn: function clearCheckIn() {\n      if (this.checkIn && !this.checkOut) {\n        this.clearSelection();\n      }\n    },\n    clickOutside: function clickOutside() {\n      if (this.closeDatepickerOnClickOutside) {\n        this.hideDatepicker();\n      }\n    },\n    setMinimumDuration: function setMinimumDuration(date) {\n      var _this7 = this;\n\n      if (this.sortedPeriodDates) {\n        var nextPeriod = null;\n        var currentPeriod = null;\n        var compareDate = this.dateFormater(date);\n        this.sortedPeriodDates.forEach(function (d) {\n          if (d.endAt !== compareDate && (d.startAt === compareDate || _this7.validateDateBetweenTwoDates(d.startAt, d.endAt, date))) {\n            currentPeriod = d;\n          }\n        });\n\n        if (currentPeriod) {\n          this.sortedPeriodDates.forEach(function (period) {\n            if (period.startAt === currentPeriod.endAt) {\n              nextPeriod = period;\n            }\n          });\n\n          if (this.checkIn && !this.checkOut && nextPeriod) {\n            var endNextPeriod = this.addDays(nextPeriod.startAt, nextPeriod.minimumDuration - 1);\n            var startNextPeriodPlusOne = this.addDays(nextPeriod.startAt, 1);\n            var newDisablesDates = this.getDaysArray(startNextPeriodPlusOne, endNextPeriod);\n            this.nextPeriodDisableDates = newDisablesDates;\n          }\n\n          if (currentPeriod.periodType === 'nightly' && currentPeriod.endAt !== date) {\n            this.dynamicNightCounts = currentPeriod.minimumDuration;\n          }\n\n          if (currentPeriod.periodType === 'weekly_by_saturday' || currentPeriod.periodType === 'weekly_by_sunday') {\n            var minimumDuration = currentPeriod.minimumDuration * 7;\n            this.dynamicNightCounts = minimumDuration;\n          }\n        } else {\n          this.dynamicNightCounts = 0;\n        }\n      }\n    },\n    renderPreviousMonth: function renderPreviousMonth() {\n      if (this.activeMonthIndex >= 1) {\n        var firstDayOfLastMonth = this.months[this.activeMonthIndex].days.filter(function (day) {\n          return day.belongsToThisMonth === true;\n        });\n        var previousMonth = this.getPreviousMonth(firstDayOfLastMonth[0].date);\n        this.activeMonthIndex--;\n        this.$emit('previous-month-rendered', previousMonth);\n      }\n    },\n    renderNextMonth: lodash_throttle_default()(function throttleRenderNextMonth() {\n      if (!this.showSingleMonth && this.activeMonthIndex < this.months.length - 2 || this.showSingleMonth && this.activeMonthIndex < this.months.length - 1) {\n        this.activeMonthIndex++;\n        return;\n      }\n\n      var firstDayOfLastMonth;\n\n      if (!this.isDesktop || this.showSingleMonth) {\n        firstDayOfLastMonth = this.months[this.months.length - 1].days.filter(function (day) {\n          return day.belongsToThisMonth === true;\n        });\n      } else {\n        firstDayOfLastMonth = this.months[this.activeMonthIndex + 1].days.filter(function (day) {\n          return day.belongsToThisMonth === true;\n        });\n      }\n\n      if (this.endDate !== Infinity) {\n        if (lib_fecha.format(firstDayOfLastMonth[0].date, 'YYYYMM') === lib_fecha.format(new Date(this.endDate), 'YYYYMM')) {\n          return;\n        }\n      }\n\n      var nextMonth = this.getNextMonth(firstDayOfLastMonth[0].date);\n      this.createMonth(nextMonth);\n      this.activeMonthIndex++;\n      this.$emit('next-month-rendered', nextMonth);\n    }, 350),\n    setCheckIn: function setCheckIn(date) {\n      this.checkIn = date;\n    },\n    setCheckOut: function setCheckOut(date) {\n      this.checkOut = date;\n    },\n    createMonth: function createMonth(date) {\n      var firstDay = this.getFirstDay(date, this.firstDayOfWeek);\n      var month = {\n        days: []\n      };\n\n      for (var i = 0; i < 42; i++) {\n        month.days.push({\n          date: this.addDays(firstDay, i),\n          belongsToThisMonth: this.addDays(firstDay, i).getMonth() === date.getMonth()\n        });\n      }\n\n      this.months.push(month);\n    },\n    createHalfDayDates: function createHalfDayDates(_baseHalfDayDates) {\n      var sortedDates = [];\n      var checkIncheckOutHalfDay = {};\n\n      var baseHalfDayDates = _toConsumableArray(_baseHalfDayDates); // Sorted disabledDates\n\n\n      baseHalfDayDates.sort(function (a, b) {\n        var aa = a.split('/').reverse().join();\n        var bb = b.split('/').reverse().join(); // eslint-disable-next-line no-nested-ternary\n\n        return aa < bb ? -1 : aa > bb ? 1 : 0;\n      });\n\n      if (this.sortBookings.length === 0) {\n        for (var i = 0; i < baseHalfDayDates.length; i++) {\n          var newDate = baseHalfDayDates[i];\n\n          if (this.halfDay) {\n            var newDateIncrementOne = baseHalfDayDates[i + 1];\n\n            if (i === 0) {\n              checkIncheckOutHalfDay[newDate] = {\n                checkIn: true\n              };\n            }\n\n            if (!checkIncheckOutHalfDay[newDate] && baseHalfDayDates[i + 1] && this.getDayDiff(newDate, newDateIncrementOne) > 1) {\n              checkIncheckOutHalfDay[newDate] = {\n                checkOut: true\n              };\n              checkIncheckOutHalfDay[newDateIncrementOne] = {\n                checkIn: true\n              };\n            }\n\n            if (i === baseHalfDayDates.length - 1) {\n              checkIncheckOutHalfDay[baseHalfDayDates[baseHalfDayDates.length - 1]] = {\n                checkOut: true\n              };\n            }\n          }\n\n          sortedDates[i] = baseHalfDayDates[i];\n        }\n      } else {\n        this.sortBookings.forEach(function (booking) {\n          checkIncheckOutHalfDay[booking.checkInDate] = {\n            checkIn: true\n          };\n          checkIncheckOutHalfDay[booking.checkOutDate] = {\n            checkOut: true\n          };\n        });\n      }\n\n      if (this.halfDay) {\n        var halfDays = Object.keys(checkIncheckOutHalfDay);\n        sortedDates = sortedDates.filter(function (date) {\n          return !halfDays.includes(date);\n        });\n      }\n\n      sortedDates = sortedDates.map(function (date) {\n        return new Date(date);\n      });\n      this.sortedDisabledDates = sortedDates.sort(function (a, b) {\n        return a - b;\n      });\n      this.checkIncheckOutHalfDay = checkIncheckOutHalfDay;\n      this.$emit('handle-checkin-checkout-half-day', this.checkIncheckOutHalfDay);\n      /**\n       * @deprecated since v4.0.0 beta 11\n       */\n\n      this.$emit('handleCheckinCheckoutHalfDay', this.checkIncheckOutHalfDay);\n    }\n  })\n});\n// CONCATENATED MODULE: ./src/DatePicker/HotelDatePicker.vue?vue&type=script&lang=js&\n /* harmony default export */ var DatePicker_HotelDatePickervue_type_script_lang_js_ = (HotelDatePickervue_type_script_lang_js_); \n// CONCATENATED MODULE: ./src/DatePicker/HotelDatePicker.vue\n\n\n\n\n\n/* normalize component */\n\nvar HotelDatePicker_component = normalizeComponent(\n  DatePicker_HotelDatePickervue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* harmony default export */ var HotelDatePicker = (HotelDatePicker_component.exports);\n// EXTERNAL MODULE: ./src/assets/scss/index.scss\nvar scss = __webpack_require__(\"a41b\");\nvar scss_default = /*#__PURE__*/__webpack_require__.n(scss);\n\n// CONCATENATED MODULE: ./src/index.js\n\n\n/* harmony default export */ var src_0 = (HotelDatePicker);\n\n// CONCATENATED MODULE: ./node_modules/.pnpm/@vue+cli-service@4.5.13_0f25d1aa8415e98c3e62a4178f3c555d/node_modules/@vue/cli-service/lib/commands/build/entry-lib.js\n\n\n/* harmony default export */ var entry_lib = __webpack_exports__[\"default\"] = (src_0);\n\n\n\n/***/ }),\n\n/***/ \"3e40\":\n/***/ (function(module, exports) {\n\n// TODO: use something more complex like timsort?\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    mergeSort(array.slice(0, middle), comparefn),\n    mergeSort(array.slice(middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n  var result = [];\n\n  while (lindex < llength || rindex < rlength) {\n    if (lindex < llength && rindex < rlength) {\n      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);\n    } else {\n      result.push(lindex < llength ? left[lindex++] : right[rindex++]);\n    }\n  } return result;\n};\n\nmodule.exports = mergeSort;\n\n\n/***/ }),\n\n/***/ \"3f5d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar ownKeys = __webpack_require__(\"0fc4\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(\"aa86\");\nvar createProperty = __webpack_require__(\"1078\");\n\n// `Object.getOwnPropertyDescriptors` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n    return result;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"3f78\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\nvar isArray = __webpack_require__(\"bdc6\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n\n\n/***/ }),\n\n/***/ \"4065\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar isObject = __webpack_require__(\"74df\");\nvar isArray = __webpack_require__(\"bdc6\");\nvar toAbsoluteIndex = __webpack_require__(\"99c7\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar createProperty = __webpack_require__(\"1078\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar arrayMethodHasSpeciesSupport = __webpack_require__(\"d7e4\");\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');\n\nvar SPECIES = wellKnownSymbol('species');\nvar nativeSlice = [].slice;\nvar max = Math.max;\n\n// `Array.prototype.slice` method\n// https://tc39.es/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject(this);\n    var length = toLength(O.length);\n    var k = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n    var Constructor, result, n;\n    if (isArray(O)) {\n      Constructor = O.constructor;\n      // cross-realm fallback\n      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject(Constructor)) {\n        Constructor = Constructor[SPECIES];\n        if (Constructor === null) Constructor = undefined;\n      }\n      if (Constructor === Array || Constructor === undefined) {\n        return nativeSlice.call(O, k, fin);\n      }\n    }\n    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);\n    result.length = n;\n    return result;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"4187\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar has = __webpack_require__(\"c5cf\");\nvar ownKeys = __webpack_require__(\"0fc4\");\nvar getOwnPropertyDescriptorModule = __webpack_require__(\"aa86\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n\n\n/***/ }),\n\n/***/ \"42a1\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(\"1517\");\nvar whitespaces = __webpack_require__(\"5bfd\");\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = String(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n\n\n/***/ }),\n\n/***/ \"43c6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* eslint-disable regexp/no-assertion-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar regexpFlags = __webpack_require__(\"611a\");\nvar stickyHelpers = __webpack_require__(\"f05b\");\nvar shared = __webpack_require__(\"7c40\");\nvar create = __webpack_require__(\"ca23\");\nvar getInternalState = __webpack_require__(\"fb59\").get;\nvar UNSUPPORTED_DOT_ALL = __webpack_require__(\"29d2\");\nvar UNSUPPORTED_NCG = __webpack_require__(\"9ccd\");\n\nvar nativeExec = RegExp.prototype.exec;\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\n\nvar patchedExec = nativeExec;\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  // eslint-disable-next-line max-statements -- TODO\n  patchedExec = function exec(str) {\n    var re = this;\n    var state = getInternalState(re);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = patchedExec.call(raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y && re.sticky;\n    var flags = regexpFlags.call(re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = flags.replace('y', '');\n      if (flags.indexOf('g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = String(str).slice(re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = nativeExec.call(sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = match.input.slice(charsAdded);\n        match[0] = match[0].slice(charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n\n\n/***/ }),\n\n/***/ \"4430\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar path = __webpack_require__(\"7148\");\nvar global = __webpack_require__(\"0308\");\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n\n/***/ }),\n\n/***/ \"4590\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar objectKeys = __webpack_require__(\"3692\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar propertyIsEnumerable = __webpack_require__(\"b488\").f;\n\n// `Object.{ entries, values }` methods implementation\nvar createMethod = function (TO_ENTRIES) {\n  return function (it) {\n    var O = toIndexedObject(it);\n    var keys = objectKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {\n        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n\nmodule.exports = {\n  // `Object.entries` method\n  // https://tc39.es/ecma262/#sec-object.entries\n  entries: createMethod(true),\n  // `Object.values` method\n  // https://tc39.es/ecma262/#sec-object.values\n  values: createMethod(false)\n};\n\n\n/***/ }),\n\n/***/ \"45bf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar inspectSource = __webpack_require__(\"20ed\");\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n\n/***/ }),\n\n/***/ \"468e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(\"7e6f\");\nvar classof = __webpack_require__(\"093a\");\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n  return '[object ' + classof(this) + ']';\n};\n\n\n/***/ }),\n\n/***/ \"4827\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar has = __webpack_require__(\"c5cf\");\nvar setGlobal = __webpack_require__(\"50d0\");\nvar inspectSource = __webpack_require__(\"20ed\");\nvar InternalStateModule = __webpack_require__(\"fb59\");\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var state;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) {\n      createNonEnumerableProperty(value, 'name', key);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n\n/***/ }),\n\n/***/ \"496a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineProperty = __webpack_require__(\"cea8\").f;\nvar has = __webpack_require__(\"c5cf\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\n\nmodule.exports = function (it, TAG, STATIC) {\n  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });\n  }\n};\n\n\n/***/ }),\n\n/***/ \"4a9f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar hiddenKeys = __webpack_require__(\"a95c\");\nvar isObject = __webpack_require__(\"74df\");\nvar has = __webpack_require__(\"c5cf\");\nvar defineProperty = __webpack_require__(\"cea8\").f;\nvar uid = __webpack_require__(\"fc94\");\nvar FREEZING = __webpack_require__(\"61cf\");\n\nvar METADATA = uid('meta');\nvar id = 0;\n\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\n\nvar setMetadata = function (it) {\n  defineProperty(it, METADATA, { value: {\n    objectID: 'O' + id++, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData = function (it, create) {\n  if (!has(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar meta = module.exports = {\n  REQUIRED: false,\n  fastKey: fastKey,\n  getWeakData: getWeakData,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n\n\n/***/ }),\n\n/***/ \"4b1c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n/***/ }),\n\n/***/ \"4b70\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar userAgent = __webpack_require__(\"2547\");\n\nvar firefox = userAgent.match(/firefox\\/(\\d+)/i);\n\nmodule.exports = !!firefox && +firefox[1];\n\n\n/***/ }),\n\n/***/ \"4bb8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar MATCH = wellKnownSymbol('match');\n\nmodule.exports = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\n\n/***/ }),\n\n/***/ \"4e35\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(\"56fb\");\nvar getPrototypeOf = __webpack_require__(\"1cf5\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar has = __webpack_require__(\"c5cf\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar IS_PURE = __webpack_require__(\"c783\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\n\nvar returnThis = function () { return this; };\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype[ITERATOR].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\n\nmodule.exports = {\n  IteratorPrototype: IteratorPrototype,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n\n/***/ }),\n\n/***/ \"4e89\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar defineProperty = __webpack_require__(\"cea8\").f;\n\nvar FunctionPrototype = Function.prototype;\nvar FunctionPrototypeToString = FunctionPrototype.toString;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// Function instances `.name` property\n// https://tc39.es/ecma262/#sec-function-instances-name\nif (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n  defineProperty(FunctionPrototype, NAME, {\n    configurable: true,\n    get: function () {\n      try {\n        return FunctionPrototypeToString.call(this).match(nameRE)[1];\n      } catch (error) {\n        return '';\n      }\n    }\n  });\n}\n\n\n/***/ }),\n\n/***/ \"4f71\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar bind = __webpack_require__(\"6c7b\");\nvar toObject = __webpack_require__(\"a50e\");\nvar callWithSafeIterationClosing = __webpack_require__(\"d3c3\");\nvar isArrayIteratorMethod = __webpack_require__(\"9cc6\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar createProperty = __webpack_require__(\"1078\");\nvar getIteratorMethod = __webpack_require__(\"8691\");\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nmodule.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject(arrayLike);\n  var C = typeof this == 'function' ? this : Array;\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n    iterator = iteratorMethod.call(O);\n    next = iterator.next;\n    result = new C();\n    for (;!(step = next.call(iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty(result, index, value);\n    }\n  } else {\n    length = toLength(O.length);\n    result = new C(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"4f9f\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = __webpack_require__(\"02df\");\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\n\n/***/ }),\n\n/***/ \"50d0\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\n\nmodule.exports = function (key, value) {\n  try {\n    createNonEnumerableProperty(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n\n\n/***/ }),\n\n/***/ \"5108\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $filter = __webpack_require__(\"5748\").filter;\nvar arrayMethodHasSpeciesSupport = __webpack_require__(\"d7e4\");\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"55ea\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar notARegExp = __webpack_require__(\"6d9d\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\nvar correctIsRegExpLogic = __webpack_require__(\"4bb8\");\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~String(requireObjectCoercible(this))\n      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"56fb\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"5748\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar bind = __webpack_require__(\"6c7b\");\nvar IndexedObject = __webpack_require__(\"0c45\");\nvar toObject = __webpack_require__(\"a50e\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar arraySpeciesCreate = __webpack_require__(\"3f78\");\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_OUT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push.call(target, value); // filterOut\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterOut` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterOut: createMethod(7)\n};\n\n\n/***/ }),\n\n/***/ \"5a6c\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nexports.f = wellKnownSymbol;\n\n\n/***/ }),\n\n/***/ \"5bd7\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it, Constructor, name) {\n  if (!(it instanceof Constructor)) {\n    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"5bfd\":\n/***/ (function(module, exports) {\n\n// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\n\n/***/ }),\n\n/***/ \"5cc7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar defineWellKnownSymbol = __webpack_require__(\"254f\");\n\n// `Symbol.iterator` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.iterator\ndefineWellKnownSymbol('iterator');\n\n\n/***/ }),\n\n/***/ \"5dac\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar isObject = __webpack_require__(\"74df\");\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n\n\n/***/ }),\n\n/***/ \"611a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar anObject = __webpack_require__(\"f65e\");\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"61b5\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = __webpack_require__(\"0c45\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n\n\n/***/ }),\n\n/***/ \"61cf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n\n\n/***/ }),\n\n/***/ \"68cc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"f65e\");\n\nmodule.exports = function (iterator) {\n  var returnMethod = iterator['return'];\n  if (returnMethod !== undefined) {\n    return anObject(returnMethod.call(iterator)).value;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"6aa2\":\n/***/ (function(module, exports) {\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n\n\n/***/ }),\n\n/***/ \"6ae9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar fails = __webpack_require__(\"56fb\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar nativeGetOwnPropertyDescriptor = __webpack_require__(\"aa86\").f;\nvar DESCRIPTORS = __webpack_require__(\"c826\");\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });\nvar FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"6b66\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar assign = __webpack_require__(\"c99b\");\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\n\n/***/ }),\n\n/***/ \"6c7b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar aFunction = __webpack_require__(\"e7f4\");\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n/***/ }),\n\n/***/ \"6c80\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = throttle;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"d8fc\")))\n\n/***/ }),\n\n/***/ \"6d9d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isRegExp = __webpack_require__(\"2627\");\n\nmodule.exports = function (it) {\n  if (isRegExp(it)) {\n    throw TypeError(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"7148\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\n\nmodule.exports = global;\n\n\n/***/ }),\n\n/***/ \"74df\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n/***/ }),\n\n/***/ \"7531\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar shared = __webpack_require__(\"7c40\");\nvar uid = __webpack_require__(\"fc94\");\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n\n\n/***/ }),\n\n/***/ \"7891\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(\"2a81\").charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\n\n/***/ }),\n\n/***/ \"790d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar getBuiltIn = __webpack_require__(\"4430\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar DESCRIPTORS = __webpack_require__(\"c826\");\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule.f;\n\n  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n    defineProperty(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\n\n/***/ }),\n\n/***/ \"7c40\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar IS_PURE = __webpack_require__(\"c783\");\nvar store = __webpack_require__(\"389c\");\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.15.2',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'\n});\n\n\n/***/ }),\n\n/***/ \"7da5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller\n// MIT license\n// source: https://github.com/amiller-gh/currentScript-polyfill\n\n// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505\n\n(function (root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n}(typeof self !== 'undefined' ? self : this, function () {\n  function getCurrentScript () {\n    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')\n    // for chrome\n    if (!descriptor && 'currentScript' in document && document.currentScript) {\n      return document.currentScript\n    }\n\n    // for other browsers with native support for currentScript\n    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {\n      return document.currentScript\n    }\n  \n    // IE 8-10 support script readyState\n    // IE 11+ & Firefox support stack trace\n    try {\n      throw new Error();\n    }\n    catch (err) {\n      // Find the second match for the \"at\" string to get file src url from stack.\n      var ieStackRegExp = /.*at [^(]*\\((.*):(.+):(.+)\\)$/ig,\n        ffStackRegExp = /@([^@]*):(\\d+):(\\d+)\\s*$/ig,\n        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),\n        scriptLocation = (stackDetails && stackDetails[1]) || false,\n        line = (stackDetails && stackDetails[2]) || false,\n        currentLocation = document.location.href.replace(document.location.hash, ''),\n        pageSource,\n        inlineScriptSourceRegExp,\n        inlineScriptSource,\n        scripts = document.getElementsByTagName('script'); // Live NodeList collection\n  \n      if (scriptLocation === currentLocation) {\n        pageSource = document.documentElement.outerHTML;\n        inlineScriptSourceRegExp = new RegExp('(?:[^\\\\n]+?\\\\n){0,' + (line - 2) + '}[^<]*<script>([\\\\d\\\\D]*?)<\\\\/script>[\\\\d\\\\D]*', 'i');\n        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();\n      }\n  \n      for (var i = 0; i < scripts.length; i++) {\n        // If ready state is interactive, return the script tag\n        if (scripts[i].readyState === 'interactive') {\n          return scripts[i];\n        }\n  \n        // If src matches, return the script tag\n        if (scripts[i].src === scriptLocation) {\n          return scripts[i];\n        }\n  \n        // If inline source matches, return the script tag\n        if (\n          scriptLocation === currentLocation &&\n          scripts[i].innerHTML &&\n          scripts[i].innerHTML.trim() === inlineScriptSource\n        ) {\n          return scripts[i];\n        }\n      }\n  \n      // If no match, return null\n      return null;\n    }\n  };\n\n  return getCurrentScript\n}));\n\n\n/***/ }),\n\n/***/ \"7e6f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG] = 'z';\n\nmodule.exports = String(test) === '[object z]';\n\n\n/***/ }),\n\n/***/ \"7f9d\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar fails = __webpack_require__(\"56fb\");\nvar createElement = __webpack_require__(\"5dac\");\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\n\n/***/ }),\n\n/***/ \"813a\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(\"292f\");\nvar fails = __webpack_require__(\"56fb\");\nvar anObject = __webpack_require__(\"f65e\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar toInteger = __webpack_require__(\"c25b\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\nvar advanceStringIndex = __webpack_require__(\"7891\");\nvar getSubstitution = __webpack_require__(\"8b0b\");\nvar regExpExec = __webpack_require__(\"8a10\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar REPLACE = wellKnownSymbol('replace');\nvar max = Math.max;\nvar min = Math.min;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// IE <= 11 replaces $0 with the whole match, as if it was $&\n// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0\nvar REPLACE_KEEPS_$0 = (function () {\n  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing\n  return 'a'.replace(/./, '$0') === '$0';\n})();\n\n// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string\nvar REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {\n  if (/./[REPLACE]) {\n    return /./[REPLACE]('a', '$0') === '';\n  }\n  return false;\n})();\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\n// @@replace logic\nfixRegExpWellKnownSymbolLogic('replace', function (_, nativeReplace, maybeCallNative) {\n  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';\n\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.es/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = requireObjectCoercible(this);\n      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return replacer !== undefined\n        ? replacer.call(searchValue, O, replaceValue)\n        : nativeReplace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace\n    function (string, replaceValue) {\n      if (\n        typeof replaceValue === 'string' &&\n        replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1 &&\n        replaceValue.indexOf('$<') === -1\n      ) {\n        var res = maybeCallNative(nativeReplace, this, string, replaceValue);\n        if (res.done) return res.value;\n      }\n\n      var rx = anObject(this);\n      var S = String(string);\n\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n\n        results.push(result);\n        if (!global) break;\n\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n}, !REPLACE_SUPPORTS_NAMED_GROUPS || !REPLACE_KEEPS_$0 || REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE);\n\n\n/***/ }),\n\n/***/ \"8170\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar from = __webpack_require__(\"4f71\");\nvar checkCorrectnessOfIteration = __webpack_require__(\"e9bc\");\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from\n});\n\n\n/***/ }),\n\n/***/ \"83ce\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar charAt = __webpack_require__(\"2a81\").charAt;\nvar InternalStateModule = __webpack_require__(\"fb59\");\nvar defineIterator = __webpack_require__(\"ed54\");\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator(String, 'String', function (iterated) {\n  setInternalState(this, {\n    type: STRING_ITERATOR,\n    string: String(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return { value: undefined, done: true };\n  point = charAt(string, index);\n  state.index += point.length;\n  return { value: point, done: false };\n});\n\n\n/***/ }),\n\n/***/ \"8691\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"093a\");\nvar Iterators = __webpack_require__(\"aa2f\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\n\nmodule.exports = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n/***/ }),\n\n/***/ \"8a10\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"c4d8\");\nvar regexpExec = __webpack_require__(\"43c6\");\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n\n  if (classof(R) !== 'RegExp') {\n    throw TypeError('RegExp#exec called on incompatible receiver');\n  }\n\n  return regexpExec.call(R, S);\n};\n\n\n\n/***/ }),\n\n/***/ \"8b0b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toObject = __webpack_require__(\"a50e\");\n\nvar floor = Math.floor;\nvar replace = ''.replace;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&'`]|\\d{1,2}|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&'`]|\\d{1,2})/g;\n\n// `GetSubstitution` abstract operation\n// https://tc39.es/ecma262/#sec-getsubstitution\nmodule.exports = function (matched, str, position, captures, namedCaptures, replacement) {\n  var tailPos = position + matched.length;\n  var m = captures.length;\n  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n  if (namedCaptures !== undefined) {\n    namedCaptures = toObject(namedCaptures);\n    symbols = SUBSTITUTION_SYMBOLS;\n  }\n  return replace.call(replacement, symbols, function (match, ch) {\n    var capture;\n    switch (ch.charAt(0)) {\n      case '$': return '$';\n      case '&': return matched;\n      case '`': return str.slice(0, position);\n      case \"'\": return str.slice(tailPos);\n      case '<':\n        capture = namedCaptures[ch.slice(1, -1)];\n        break;\n      default: // \\d\\d?\n        var n = +ch;\n        if (n === 0) return match;\n        if (n > m) {\n          var f = floor(n / 10);\n          if (f === 0) return match;\n          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n          return match;\n        }\n        capture = captures[n - 1];\n    }\n    return capture === undefined ? '' : capture;\n  });\n};\n\n\n/***/ }),\n\n/***/ \"9232\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $entries = __webpack_require__(\"4590\").entries;\n\n// `Object.entries` method\n// https://tc39.es/ecma262/#sec-object.entries\n$({ target: 'Object', stat: true }, {\n  entries: function entries(O) {\n    return $entries(O);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"92c9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar redefine = __webpack_require__(\"4827\");\n\nmodule.exports = function (target, src, options) {\n  for (var key in src) redefine(target, key, src[key], options);\n  return target;\n};\n\n\n/***/ }),\n\n/***/ \"9808\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $map = __webpack_require__(\"5748\").map;\nvar arrayMethodHasSpeciesSupport = __webpack_require__(\"d7e4\");\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"99c7\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"c25b\");\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n\n/***/ }),\n\n/***/ \"9cc6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar Iterators = __webpack_require__(\"aa2f\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\n\n// check on default Array iterator\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n\n/***/ }),\n\n/***/ \"9ccd\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\nmodule.exports = fails(function () {\n  // babel-minify transpiles RegExp('.', 'g') -> /./g and it causes SyntaxError\n  var re = RegExp('(?<a>b)', (typeof '').charAt(5));\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n\n/***/ }),\n\n/***/ \"9e3b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"f65e\");\nvar aFunction = __webpack_require__(\"e7f4\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nmodule.exports = function (O, defaultConstructor) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\n};\n\n\n/***/ }),\n\n/***/ \"9ef3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar getOwnPropertyDescriptor = __webpack_require__(\"aa86\").f;\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar redefine = __webpack_require__(\"4827\");\nvar setGlobal = __webpack_require__(\"50d0\");\nvar copyConstructorProperties = __webpack_require__(\"4187\");\nvar isForced = __webpack_require__(\"fff9\");\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n\n\n/***/ }),\n\n/***/ \"a08f\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar toAbsoluteIndex = __webpack_require__(\"99c7\");\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n\n\n/***/ }),\n\n/***/ \"a41b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n// extracted by mini-css-extract-plugin\n\n/***/ }),\n\n/***/ \"a4df\":\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-disable no-proto -- safe */\nvar anObject = __webpack_require__(\"f65e\");\nvar aPossiblePrototype = __webpack_require__(\"c6c9\");\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\n\n/***/ }),\n\n/***/ \"a50e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar requireObjectCoercible = __webpack_require__(\"1517\");\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n\n\n/***/ }),\n\n/***/ \"a95c\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"aa2f\":\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n\n/***/ }),\n\n/***/ \"aa86\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar propertyIsEnumerableModule = __webpack_require__(\"b488\");\nvar createPropertyDescriptor = __webpack_require__(\"bd06\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar toPrimitive = __webpack_require__(\"4b1c\");\nvar has = __webpack_require__(\"c5cf\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"7f9d\");\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n\n/***/ }),\n\n/***/ \"ae0a\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar userAgent = __webpack_require__(\"2547\");\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nmodule.exports = !!webkit && +webkit[1];\n\n\n/***/ }),\n\n/***/ \"af86\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar global = __webpack_require__(\"0308\");\nvar isForced = __webpack_require__(\"fff9\");\nvar redefine = __webpack_require__(\"4827\");\nvar has = __webpack_require__(\"c5cf\");\nvar classof = __webpack_require__(\"c4d8\");\nvar inheritIfRequired = __webpack_require__(\"32da\");\nvar toPrimitive = __webpack_require__(\"4b1c\");\nvar fails = __webpack_require__(\"56fb\");\nvar create = __webpack_require__(\"ca23\");\nvar getOwnPropertyNames = __webpack_require__(\"04a4\").f;\nvar getOwnPropertyDescriptor = __webpack_require__(\"aa86\").f;\nvar defineProperty = __webpack_require__(\"cea8\").f;\nvar trim = __webpack_require__(\"42a1\").trim;\n\nvar NUMBER = 'Number';\nvar NativeNumber = global[NUMBER];\nvar NumberPrototype = NativeNumber.prototype;\n\n// Opera ~12 has broken Object#toString\nvar BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n\n// `ToNumber` abstract operation\n// https://tc39.es/ecma262/#sec-tonumber\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  var first, third, radix, maxCode, digits, length, index, code;\n  if (typeof it == 'string' && it.length > 2) {\n    it = trim(it);\n    first = it.charCodeAt(0);\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i\n        default: return +it;\n      }\n      digits = it.slice(2);\n      length = digits.length;\n      for (index = 0; index < length; index++) {\n        code = digits.charCodeAt(index);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\n// `Number` constructor\n// https://tc39.es/ecma262/#sec-number-constructor\nif (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {\n  var NumberWrapper = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var dummy = this;\n    return dummy instanceof NumberWrapper\n      // check on 1..constructor(foo) case\n      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)\n        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n  };\n  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES2015 (in case, if modules with ES2015 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +\n    // ESNext\n    'fromString,range'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n    }\n  }\n  NumberWrapper.prototype = NumberPrototype;\n  NumberPrototype.constructor = NumberWrapper;\n  redefine(global, NUMBER, NumberWrapper);\n}\n\n\n/***/ }),\n\n/***/ \"b38c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __webpack_require__(\"4e35\").IteratorPrototype;\nvar create = __webpack_require__(\"ca23\");\nvar createPropertyDescriptor = __webpack_require__(\"bd06\");\nvar setToStringTag = __webpack_require__(\"496a\");\nvar Iterators = __webpack_require__(\"aa2f\");\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (IteratorConstructor, NAME, next) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators[TO_STRING_TAG] = returnThis;\n  return IteratorConstructor;\n};\n\n\n/***/ }),\n\n/***/ \"b488\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n\n/***/ }),\n\n/***/ \"b5db\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $find = __webpack_require__(\"5748\").find;\nvar addToUnscopables = __webpack_require__(\"c566\");\n\nvar FIND = 'find';\nvar SKIPS_HOLES = true;\n\n// Shouldn't skip holes\nif (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });\n\n// `Array.prototype.find` method\n// https://tc39.es/ecma262/#sec-array.prototype.find\n$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {\n  find: function find(callbackfn /* , that = undefined */) {\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables(FIND);\n\n\n/***/ }),\n\n/***/ \"b5ec\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar aFunction = __webpack_require__(\"e7f4\");\nvar toObject = __webpack_require__(\"a50e\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar fails = __webpack_require__(\"56fb\");\nvar internalSort = __webpack_require__(\"3e40\");\nvar arrayMethodIsStrict = __webpack_require__(\"e244\");\nvar FF = __webpack_require__(\"4b70\");\nvar IE_OR_EDGE = __webpack_require__(\"f3f5\");\nvar V8 = __webpack_require__(\"d2ef\");\nvar WEBKIT = __webpack_require__(\"ae0a\");\n\nvar test = [];\nvar nativeSort = test.sort;\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD = arrayMethodIsStrict('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return String(x) > String(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$({ target: 'Array', proto: true, forced: FORCED }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aFunction(comparefn);\n\n    var array = toObject(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);\n\n    var items = [];\n    var arrayLength = toLength(array.length);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) items.push(array[index]);\n    }\n\n    items = internalSort(items, getSortCompare(comparefn));\n    itemsLength = items.length;\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) delete array[index++];\n\n    return array;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"ba83\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar toInteger = __webpack_require__(\"c25b\");\nvar thisNumberValue = __webpack_require__(\"12da\");\nvar repeat = __webpack_require__(\"e3a6\");\nvar fails = __webpack_require__(\"56fb\");\n\nvar nativeToFixed = 1.0.toFixed;\nvar floor = Math.floor;\n\nvar pow = function (x, n, acc) {\n  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);\n};\n\nvar log = function (x) {\n  var n = 0;\n  var x2 = x;\n  while (x2 >= 4096) {\n    n += 12;\n    x2 /= 4096;\n  }\n  while (x2 >= 2) {\n    n += 1;\n    x2 /= 2;\n  } return n;\n};\n\nvar multiply = function (data, n, c) {\n  var index = -1;\n  var c2 = c;\n  while (++index < 6) {\n    c2 += n * data[index];\n    data[index] = c2 % 1e7;\n    c2 = floor(c2 / 1e7);\n  }\n};\n\nvar divide = function (data, n) {\n  var index = 6;\n  var c = 0;\n  while (--index >= 0) {\n    c += data[index];\n    data[index] = floor(c / n);\n    c = (c % n) * 1e7;\n  }\n};\n\nvar dataToString = function (data) {\n  var index = 6;\n  var s = '';\n  while (--index >= 0) {\n    if (s !== '' || index === 0 || data[index] !== 0) {\n      var t = String(data[index]);\n      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;\n    }\n  } return s;\n};\n\nvar FORCED = nativeToFixed && (\n  0.00008.toFixed(3) !== '0.000' ||\n  0.9.toFixed(0) !== '1' ||\n  1.255.toFixed(2) !== '1.25' ||\n  1000000000000000128.0.toFixed(0) !== '1000000000000000128'\n) || !fails(function () {\n  // V8 ~ Android 4.3-\n  nativeToFixed.call({});\n});\n\n// `Number.prototype.toFixed` method\n// https://tc39.es/ecma262/#sec-number.prototype.tofixed\n$({ target: 'Number', proto: true, forced: FORCED }, {\n  toFixed: function toFixed(fractionDigits) {\n    var number = thisNumberValue(this);\n    var fractDigits = toInteger(fractionDigits);\n    var data = [0, 0, 0, 0, 0, 0];\n    var sign = '';\n    var result = '0';\n    var e, z, j, k;\n\n    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (number != number) return 'NaN';\n    if (number <= -1e21 || number >= 1e21) return String(number);\n    if (number < 0) {\n      sign = '-';\n      number = -number;\n    }\n    if (number > 1e-21) {\n      e = log(number * pow(2, 69, 1)) - 69;\n      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);\n      z *= 0x10000000000000;\n      e = 52 - e;\n      if (e > 0) {\n        multiply(data, 0, z);\n        j = fractDigits;\n        while (j >= 7) {\n          multiply(data, 1e7, 0);\n          j -= 7;\n        }\n        multiply(data, pow(10, j, 1), 0);\n        j = e - 1;\n        while (j >= 23) {\n          divide(data, 1 << 23);\n          j -= 23;\n        }\n        divide(data, 1 << j);\n        multiply(data, 1, 1);\n        divide(data, 2);\n        result = dataToString(data);\n      } else {\n        multiply(data, 0, z);\n        multiply(data, 1 << -e, 0);\n        result = dataToString(data) + repeat.call('0', fractDigits);\n      }\n    }\n    if (fractDigits > 0) {\n      k = result.length;\n      result = sign + (k <= fractDigits\n        ? '0.' + repeat.call('0', fractDigits - k) + result\n        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));\n    } else {\n      result = sign + result;\n    } return result;\n  }\n});\n\n\n/***/ }),\n\n/***/ \"bd06\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n/***/ }),\n\n/***/ \"bdc6\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar classof = __webpack_require__(\"c4d8\");\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(arg) {\n  return classof(arg) == 'Array';\n};\n\n\n/***/ }),\n\n/***/ \"c25b\":\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n\n/***/ }),\n\n/***/ \"c4d8\":\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n/***/ }),\n\n/***/ \"c566\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar create = __webpack_require__(\"ca23\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\n\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nmodule.exports = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n\n/***/ }),\n\n/***/ \"c5cf\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toObject = __webpack_require__(\"a50e\");\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n\n\n/***/ }),\n\n/***/ \"c64b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"f65e\");\nvar isArrayIteratorMethod = __webpack_require__(\"9cc6\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar bind = __webpack_require__(\"6c7b\");\nvar getIteratorMethod = __webpack_require__(\"8691\");\nvar iteratorClose = __webpack_require__(\"68cc\");\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nmodule.exports = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = toLength(iterable.length); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && result instanceof Result) return result;\n      } return new Result(false);\n    }\n    iterator = iterFn.call(iterable);\n  }\n\n  next = iterator.next;\n  while (!(step = next.call(iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator);\n      throw error;\n    }\n    if (typeof result == 'object' && result && result instanceof Result) return result;\n  } return new Result(false);\n};\n\n\n/***/ }),\n\n/***/ \"c6c9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"c783\":\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n\n/***/ }),\n\n/***/ \"c826\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\n\n/***/ }),\n\n/***/ \"c99b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar fails = __webpack_require__(\"56fb\");\nvar objectKeys = __webpack_require__(\"3692\");\nvar getOwnPropertySymbolsModule = __webpack_require__(\"6aa2\");\nvar propertyIsEnumerableModule = __webpack_require__(\"b488\");\nvar toObject = __webpack_require__(\"a50e\");\nvar IndexedObject = __webpack_require__(\"0c45\");\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\n\n/***/ }),\n\n/***/ \"ca23\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"f65e\");\nvar defineProperties = __webpack_require__(\"1ddd\");\nvar enumBugKeys = __webpack_require__(\"2294\");\nvar hiddenKeys = __webpack_require__(\"a95c\");\nvar html = __webpack_require__(\"31c6\");\nvar documentCreateElement = __webpack_require__(\"5dac\");\nvar sharedKey = __webpack_require__(\"7531\");\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject -- old IE */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n\n/***/ }),\n\n/***/ \"ce65\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar $ = __webpack_require__(\"9ef3\");\nvar toObject = __webpack_require__(\"a50e\");\nvar nativeKeys = __webpack_require__(\"3692\");\nvar fails = __webpack_require__(\"56fb\");\n\nvar FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject(it));\n  }\n});\n\n\n/***/ }),\n\n/***/ \"cea8\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar IE8_DOM_DEFINE = __webpack_require__(\"7f9d\");\nvar anObject = __webpack_require__(\"f65e\");\nvar toPrimitive = __webpack_require__(\"4b1c\");\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n/***/ }),\n\n/***/ \"cf70\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\nvar whitespaces = __webpack_require__(\"5bfd\");\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n\n\n/***/ }),\n\n/***/ \"d08c\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $forEach = __webpack_require__(\"5748\").forEach;\nvar arrayMethodIsStrict = __webpack_require__(\"e244\");\n\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nmodule.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n\n\n/***/ }),\n\n/***/ \"d2ef\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar userAgent = __webpack_require__(\"2547\");\n\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n\n\n/***/ }),\n\n/***/ \"d3c3\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar anObject = __webpack_require__(\"f65e\");\nvar iteratorClose = __webpack_require__(\"68cc\");\n\n// call something on iterator step with safe closing on error\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose(iterator);\n    throw error;\n  }\n};\n\n\n/***/ }),\n\n/***/ \"d453\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar addToUnscopables = __webpack_require__(\"c566\");\nvar Iterators = __webpack_require__(\"aa2f\");\nvar InternalStateModule = __webpack_require__(\"fb59\");\nvar defineIterator = __webpack_require__(\"ed54\");\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nIterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n/***/ }),\n\n/***/ \"d7ae\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar DESCRIPTORS = __webpack_require__(\"c826\");\nvar definePropertyModule = __webpack_require__(\"cea8\");\nvar createPropertyDescriptor = __webpack_require__(\"bd06\");\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n/***/ }),\n\n/***/ \"d7e4\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar V8_VERSION = __webpack_require__(\"d2ef\");\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\n\n/***/ }),\n\n/***/ \"d8fc\":\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n\n/***/ \"e244\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fails = __webpack_require__(\"56fb\");\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n\n\n/***/ }),\n\n/***/ \"e3a6\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar toInteger = __webpack_require__(\"c25b\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\n\n// `String.prototype.repeat` method implementation\n// https://tc39.es/ecma262/#sec-string.prototype.repeat\nmodule.exports = function repeat(count) {\n  var str = String(requireObjectCoercible(this));\n  var result = '';\n  var n = toInteger(count);\n  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');\n  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;\n  return result;\n};\n\n\n/***/ }),\n\n/***/ \"e7f4\":\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"e8ad\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toInteger = __webpack_require__(\"c25b\");\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\n\n/***/ }),\n\n/***/ \"e9bc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\n\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nmodule.exports = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\n\n/***/ }),\n\n/***/ \"ed54\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar createIteratorConstructor = __webpack_require__(\"b38c\");\nvar getPrototypeOf = __webpack_require__(\"1cf5\");\nvar setPrototypeOf = __webpack_require__(\"a4df\");\nvar setToStringTag = __webpack_require__(\"496a\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar redefine = __webpack_require__(\"4827\");\nvar wellKnownSymbol = __webpack_require__(\"f1dc\");\nvar IS_PURE = __webpack_require__(\"c783\");\nvar Iterators = __webpack_require__(\"aa2f\");\nvar IteratorsCore = __webpack_require__(\"4e35\");\n\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf) {\n          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    INCORRECT_VALUES_NAME = true;\n    defaultIterator = function values() { return nativeIterator.call(this); };\n  }\n\n  // define iterator\n  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n  }\n  Iterators[NAME] = defaultIterator;\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        redefine(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  return methods;\n};\n\n\n/***/ }),\n\n/***/ \"eda8\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar global = __webpack_require__(\"0308\");\nvar isForced = __webpack_require__(\"fff9\");\nvar redefine = __webpack_require__(\"4827\");\nvar InternalMetadataModule = __webpack_require__(\"4a9f\");\nvar iterate = __webpack_require__(\"c64b\");\nvar anInstance = __webpack_require__(\"5bd7\");\nvar isObject = __webpack_require__(\"74df\");\nvar fails = __webpack_require__(\"56fb\");\nvar checkCorrectnessOfIteration = __webpack_require__(\"e9bc\");\nvar setToStringTag = __webpack_require__(\"496a\");\nvar inheritIfRequired = __webpack_require__(\"32da\");\n\nmodule.exports = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var NativeConstructor = global[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var Constructor = NativeConstructor;\n  var exported = {};\n\n  var fixMethod = function (KEY) {\n    var nativeMethod = NativePrototype[KEY];\n    redefine(NativePrototype, KEY,\n      KEY == 'add' ? function add(value) {\n        nativeMethod.call(this, value === 0 ? 0 : value);\n        return this;\n      } : KEY == 'delete' ? function (key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'get' ? function get(key) {\n        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : KEY == 'has' ? function has(key) {\n        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n      } : function set(key, value) {\n        nativeMethod.call(this, key === 0 ? 0 : key, value);\n        return this;\n      }\n    );\n  };\n\n  var REPLACE = isForced(\n    CONSTRUCTOR_NAME,\n    typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n      new NativeConstructor().entries().next();\n    }))\n  );\n\n  if (REPLACE) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule.REQUIRED = true;\n  } else if (isForced(CONSTRUCTOR_NAME, true)) {\n    var instance = new Constructor();\n    // early implementations not supports chaining\n    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false\n    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });\n    // most early implementations doesn't supports iterables, most modern - not close it correctly\n    // eslint-disable-next-line no-new -- required for testing\n    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });\n    // for early implementations -0 and +0 not the same\n    var BUGGY_ZERO = !IS_WEAK && fails(function () {\n      // V8 ~ Chromium 42- fails only with 5+ elements\n      var $instance = new NativeConstructor();\n      var index = 5;\n      while (index--) $instance[ADDER](index, index);\n      return !$instance.has(-0);\n    });\n\n    if (!ACCEPT_ITERABLES) {\n      Constructor = wrapper(function (dummy, iterable) {\n        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n        return that;\n      });\n      Constructor.prototype = NativePrototype;\n      NativePrototype.constructor = Constructor;\n    }\n\n    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n\n    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);\n\n    // weak collections should not contains .clear method\n    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;\n  }\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $({ global: true, forced: Constructor != NativeConstructor }, exported);\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n\n\n/***/ }),\n\n/***/ \"ef2d\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar fixRegExpWellKnownSymbolLogic = __webpack_require__(\"292f\");\nvar isRegExp = __webpack_require__(\"2627\");\nvar anObject = __webpack_require__(\"f65e\");\nvar requireObjectCoercible = __webpack_require__(\"1517\");\nvar speciesConstructor = __webpack_require__(\"9e3b\");\nvar advanceStringIndex = __webpack_require__(\"7891\");\nvar toLength = __webpack_require__(\"e8ad\");\nvar callRegExpExec = __webpack_require__(\"8a10\");\nvar regexpExec = __webpack_require__(\"43c6\");\nvar stickyHelpers = __webpack_require__(\"f05b\");\nvar fails = __webpack_require__(\"56fb\");\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar arrayPush = [].push;\nvar min = Math.min;\nvar MAX_UINT32 = 0xFFFFFFFF;\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = String(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return nativeSplit.call(string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = regexpExec.call(separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output.length > lim ? output.slice(0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : separator[SPLIT];\n      return splitter !== undefined\n        ? splitter.call(separator, O, limit)\n        : internalSplit.call(String(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var res = maybeCallNative(internalSplit, this, string, limit, internalSplit !== nativeSplit);\n      if (res.done) return res.value;\n\n      var rx = anObject(this);\n      var S = String(string);\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          A.push(S.slice(p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            A.push(z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      A.push(S.slice(p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n\n\n/***/ }),\n\n/***/ \"ef4e\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar IndexedObject = __webpack_require__(\"0c45\");\nvar toIndexedObject = __webpack_require__(\"61b5\");\nvar arrayMethodIsStrict = __webpack_require__(\"e244\");\n\nvar nativeJoin = [].join;\n\nvar ES3_STRINGS = IndexedObject != Object;\nvar STRICT_METHOD = arrayMethodIsStrict('join', ',');\n\n// `Array.prototype.join` method\n// https://tc39.es/ecma262/#sec-array.prototype.join\n$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {\n  join: function join(separator) {\n    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"f05b\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\n// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,\nvar RE = function (s, f) {\n  return RegExp(s, f);\n};\n\nexports.UNSUPPORTED_Y = fails(function () {\n  var re = RE('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\nexports.BROKEN_CARET = fails(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = RE('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\n\n/***/ }),\n\n/***/ \"f135\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $trim = __webpack_require__(\"42a1\").trim;\nvar forcedStringTrimMethod = __webpack_require__(\"cf70\");\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\n\n/***/ }),\n\n/***/ \"f1dc\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar global = __webpack_require__(\"0308\");\nvar shared = __webpack_require__(\"7c40\");\nvar has = __webpack_require__(\"c5cf\");\nvar uid = __webpack_require__(\"fc94\");\nvar NATIVE_SYMBOL = __webpack_require__(\"02df\");\nvar USE_SYMBOL_AS_UID = __webpack_require__(\"4f9f\");\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\n\n/***/ }),\n\n/***/ \"f28b\":\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar $ = __webpack_require__(\"9ef3\");\nvar $includes = __webpack_require__(\"a08f\").includes;\nvar addToUnscopables = __webpack_require__(\"c566\");\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$({ target: 'Array', proto: true }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\n\n/***/ }),\n\n/***/ \"f3f5\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar UA = __webpack_require__(\"2547\");\n\nmodule.exports = /MSIE|Trident/.test(UA);\n\n\n/***/ }),\n\n/***/ \"f635\":\n/***/ (function(module, exports) {\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n\n/***/ }),\n\n/***/ \"f65e\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(\"74df\");\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n\n\n/***/ }),\n\n/***/ \"fb59\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar NATIVE_WEAK_MAP = __webpack_require__(\"45bf\");\nvar global = __webpack_require__(\"0308\");\nvar isObject = __webpack_require__(\"74df\");\nvar createNonEnumerableProperty = __webpack_require__(\"d7ae\");\nvar objectHas = __webpack_require__(\"c5cf\");\nvar shared = __webpack_require__(\"389c\");\nvar sharedKey = __webpack_require__(\"7531\");\nvar hiddenKeys = __webpack_require__(\"a95c\");\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\n\n/***/ }),\n\n/***/ \"fc39\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __webpack_require__(\"7e6f\");\nvar redefine = __webpack_require__(\"4827\");\nvar toString = __webpack_require__(\"468e\");\n\n// `Object.prototype.toString` method\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nif (!TO_STRING_TAG_SUPPORT) {\n  redefine(Object.prototype, 'toString', toString, { unsafe: true });\n}\n\n\n/***/ }),\n\n/***/ \"fc94\":\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n\n/***/ }),\n\n/***/ \"fff9\":\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fails = __webpack_require__(\"56fb\");\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=vueHotelDatepicker.common.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWhvdGVsLWRhdGVwaWNrZXIvZGlzdC92dWVIb3RlbERhdGVwaWNrZXIuY29tbW9uLmpzP2ZmZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxrQkFBa0I7QUFDbEY7QUFDQSx5REFBeUQsY0FBYztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQ0FBaUM7QUFDbEYsd0hBQXdILG1CQUFtQixFQUFFO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUcsK0JBQStCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYSxFQUFFOztBQUUvQiw0QkFBNEI7O0FBRTVCLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxLQUFLLDZCQUE2QjtBQUNsQztBQUNBLEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGtCQUFrQixFQUFFOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRywrQ0FBK0M7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFF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OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7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RztBQUNBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTztBQUNQOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EseUc7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNIQUFzSCxtR0FBbUc7QUFDek4sK0RBQStELGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsK0RBQStELHlDQUF5QyxpQkFBaUIsc0VBQXNFLGlDQUFpQztBQUMvVzs7O0FBR0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGlIO0FBQ0E7Ozs7OztBQU1BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5Rzs7QUFFekc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2Qzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsMkNBQTJDLGtCQUFrQjtBQUM3RCxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU5BQWlOOztBQUVqTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQyxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtRUFBbUU7OztBQUduRTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBLE9BQU87O0FBRVA7QUFDQSx1QkFBdUIsNkJBQTZCO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsaUk7QUFDQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7OztBQUdBOzs7O0FBSUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyxtREFBbUQ7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2REFBNkQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixnREFBZ0Q7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEU7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZ0JBQWdCO0FBQ2hCLEdBQUcsRUFBRTtBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlCQUFpQjtBQUN0QixHQUFHO0FBQ0g7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1DQUFtQztBQUM3QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2REFBNkQ7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLDJFQUEyRTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsZ0VBQWdFO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDLFNBQVM7QUFDVCwrQkFBK0I7QUFDL0IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hELENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsbUNBQW1DLEVBQUU7QUFDbEY7O0FBRUE7QUFDQTtBQUNBLEdBQUcsbUVBQW1FO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUVBQWlFO0FBQ3BFO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QUFDQSx5Q0FBeUMsSUFBSTtBQUM3QyxrREFBa0QsSUFBSTs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsK0JBQStCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDZEQUE2RDtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLCtCQUErQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVAsVUFBVTtBQUNWIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1ob3RlbC1kYXRlcGlja2VyL2Rpc3QvdnVlSG90ZWxEYXRlcGlja2VyLmNvbW1vbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID1cbi8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIzOGMxXCIpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyBcIjAxZWRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWVmM1wiKTtcblxuLy8gYE51bWJlci5pc05hTmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci5pc25hblxuJCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDFmOVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjYxYjVcIik7XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDRhNFwiKS5mO1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiAkZ2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMDJkZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQyZWZcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwMzA4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ4ZmNcIikpKVxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwNGE0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDRmZFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMjk0XCIpO1xuXG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eW5hbWVzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwNGMxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gYFN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25gIGdldHRlclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uXG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDMwOFwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzVjZlwiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NGRmXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQxODdcIik7XG5cbnZhciBOYXRpdmVTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xuXG5pZiAoREVTQ1JJUFRPUlMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHxcbiAgLy8gU2FmYXJpIDEyIGJ1Z1xuICBOYXRpdmVTeW1ib2woKS5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkXG4pKSB7XG4gIHZhciBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUgPSB7fTtcbiAgLy8gd3JhcCBTeW1ib2wgY29uc3RydWN0b3IgZm9yIGNvcnJlY3Qgd29yayB3aXRoIHVuZGVmaW5lZCBkZXNjcmlwdGlvblxuICB2YXIgU3ltYm9sV3JhcHBlciA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBhcmd1bWVudHMubGVuZ3RoIDwgMSB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICAgIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlclxuICAgICAgPyBuZXcgTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKVxuICAgICAgLy8gaW4gRWRnZSAxMywgU3RyaW5nKFN5bWJvbCh1bmRlZmluZWQpKSA9PT0gJ1N5bWJvbCh1bmRlZmluZWQpJ1xuICAgICAgOiBkZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkID8gTmF0aXZlU3ltYm9sKCkgOiBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pO1xuICAgIGlmIChkZXNjcmlwdGlvbiA9PT0gJycpIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFN5bWJvbFdyYXBwZXIsIE5hdGl2ZVN5bWJvbCk7XG4gIHZhciBzeW1ib2xQcm90b3R5cGUgPSBTeW1ib2xXcmFwcGVyLnByb3RvdHlwZSA9IE5hdGl2ZVN5bWJvbC5wcm90b3R5cGU7XG4gIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG5cbiAgdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgbmF0aXZlID0gU3RyaW5nKE5hdGl2ZVN5bWJvbCgndGVzdCcpKSA9PSAnU3ltYm9sKHRlc3QpJztcbiAgdmFyIHJlZ2V4cCA9IC9eU3ltYm9sXFwoKC4qKVxcKVteKV0rJC87XG4gIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgdmFyIHN5bWJvbCA9IGlzT2JqZWN0KHRoaXMpID8gdGhpcy52YWx1ZU9mKCkgOiB0aGlzO1xuICAgICAgdmFyIHN0cmluZyA9IHN5bWJvbFRvU3RyaW5nLmNhbGwoc3ltYm9sKTtcbiAgICAgIGlmIChoYXMoRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlLCBzeW1ib2wpKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZGVzYyA9IG5hdGl2ZSA/IHN0cmluZy5zbGljZSg3LCAtMSkgOiBzdHJpbmcucmVwbGFjZShyZWdleHAsICckMScpO1xuICAgICAgcmV0dXJuIGRlc2MgPT09ICcnID8gdW5kZWZpbmVkIDogZGVzYztcbiAgICB9XG4gIH0pO1xuXG4gICQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gICAgU3ltYm9sOiBTeW1ib2xXcmFwcGVyXG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjA0ZmRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNWNmXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIGluZGV4T2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTA4ZlwiKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTk1Y1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIwOTNhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2U2ZlwiKTtcbnZhciBjbGFzc29mUmF3ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM0ZDhcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjA5ZWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzA4XCIpO1xudmFyIERPTUl0ZXJhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjM1XCIpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDA4Y1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdhZVwiKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsICdmb3JFYWNoJywgZm9yRWFjaCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgQ29sbGVjdGlvblByb3RvdHlwZS5mb3JFYWNoID0gZm9yRWFjaDtcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjBjNDVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNGQ4XCIpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMGZjNFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NDMwXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDRhNFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmFhMlwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxMDc4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGIxY1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZWE4XCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZDA2XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9QcmltaXRpdmUoa2V5KTtcbiAgaWYgKHByb3BlcnR5S2V5IGluIG9iamVjdCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMCwgdmFsdWUpKTtcbiAgZWxzZSBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjEwODNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkYzZcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU4YWRcIik7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTA3OFwiKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y3OFwiKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3ZTRcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMmVmXCIpO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xuXG4vLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBTUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdjb25jYXQnKTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSB0b0xlbmd0aChFLmxlbmd0aCk7XG4gICAgICAgIGlmIChuICsgbGVuID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjEyZGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzRkOFwiKTtcblxuLy8gYHRoaXNOdW1iZXJWYWx1ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRoaXNudW1iZXJ2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyAmJiBjbGFzc29mKHZhbHVlKSAhPSAnTnVtYmVyJykge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIxNTE3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIGBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVxdWlyZW9iamVjdGNvZXJjaWJsZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWIzYlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2EyM1wiKTtcbnZhciByZWRlZmluZUFsbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5MmM5XCIpO1xudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmM3YlwiKTtcbnZhciBhbkluc3RhbmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjViZDdcIik7XG52YXIgaXRlcmF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNjRiXCIpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVkNTRcIik7XG52YXIgc2V0U3BlY2llcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3OTBkXCIpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4MjZcIik7XG52YXIgZmFzdEtleSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YTlmXCIpLmZhc3RLZXk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYjU5XCIpO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaW5kZXg6IGNyZWF0ZShudWxsKSxcbiAgICAgICAgZmlyc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkLFxuICAgICAgICBzaXplOiAwXG4gICAgICB9KTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgeyB0aGF0OiB0aGF0LCBBU19FTlRSSUVTOiBJU19NQVAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgdmFyIHByZXZpb3VzLCBpbmRleDtcbiAgICAgIC8vIGNoYW5nZSBleGlzdGluZyBlbnRyeVxuICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIGVudHJ5LnZhbHVlID0gdmFsdWU7XG4gICAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgICAgICAgaW5kZXg6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLFxuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBwcmV2aW91czogcHJldmlvdXMgPSBzdGF0ZS5sYXN0LFxuICAgICAgICAgIG5leHQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICByZW1vdmVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXN0YXRlLmZpcnN0KSBzdGF0ZS5maXJzdCA9IGVudHJ5O1xuICAgICAgICBpZiAocHJldmlvdXMpIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplKys7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplKys7XG4gICAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgICBpZiAoaW5kZXggIT09ICdGJykgc3RhdGUuaW5kZXhbaW5kZXhdID0gZW50cnk7XG4gICAgICB9IHJldHVybiB0aGF0O1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgLy8gZmFzdCBjYXNlXG4gICAgICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gICAgICB2YXIgZW50cnk7XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICAgICAgZm9yIChlbnRyeSA9IHN0YXRlLmZpcnN0OyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uZXh0KSB7XG4gICAgICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5jbGVhcigpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuY2xlYXJcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5jbGVhclxuICAgICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBkYXRhID0gc3RhdGUuaW5kZXg7XG4gICAgICAgIHZhciBlbnRyeSA9IHN0YXRlLmZpcnN0O1xuICAgICAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoZW50cnkucHJldmlvdXMpIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBkZWxldGUgZGF0YVtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKERFU0NSSVBUT1JTKSBzdGF0ZS5zaXplID0gMDtcbiAgICAgICAgZWxzZSB0aGF0LnNpemUgPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZGVsZXRlXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnByZXZpb3VzO1xuICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5pbmRleFtlbnRyeS5pbmRleF07XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucHJldmlvdXMgPSBwcmV2O1xuICAgICAgICAgIGlmIChzdGF0ZS5maXJzdCA9PSBlbnRyeSkgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICAgICAgIGlmIChzdGF0ZS5sYXN0ID09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcbiAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMpIHN0YXRlLnNpemUtLTtcbiAgICAgICAgICBlbHNlIHRoYXQuc2l6ZS0tO1xuICAgICAgICB9IHJldHVybiAhIWVudHJ5O1xuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZm9yZWFjaFxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XG4gICAgICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIGB7IE1hcCwgU2V0fS5wcm90b3R5cGUuaGFzKGtleSlgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5oYXNcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLmdldChrZXkpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5nZXRcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gYE1hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5zZXRcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIGBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlgIG1ldGhvZFxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmFkZFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eShDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS57IGtleXMsIHZhbHVlcywgZW50cmllcywgQEBpdGVyYXRvciB9KClgIG1ldGhvZHNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmVudHJpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUua2V5c1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS52YWx1ZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUtQEBpdGVyYXRvclxuICAgIGRlZmluZUl0ZXJhdG9yKEMsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICAgIHR5cGU6IElURVJBVE9SX05BTUUsXG4gICAgICAgIHRhcmdldDogaXRlcmF0ZWQsXG4gICAgICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICAgICAgdmFyIGVudHJ5ID0gc3RhdGUubGFzdDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAvLyBnZXQgbmV4dCBlbnRyeVxuICAgICAgaWYgKCFzdGF0ZS50YXJnZXQgfHwgIShzdGF0ZS5sYXN0ID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5zdGF0ZS5maXJzdCkpIHtcbiAgICAgICAgLy8gb3IgZmluaXNoIHRoZSBpdGVyYXRpb25cbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBlbnRyeS5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LnZhbHVlLCBkb25lOiBmYWxzZSB9O1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICB9LCBJU19NQVAgPyAnZW50cmllcycgOiAndmFsdWVzJywgIUlTX01BUCwgdHJ1ZSk7XG5cbiAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZVtAQHNwZWNpZXNdYCBhY2Nlc3NvcnNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1tYXAtQEBzcGVjaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtc2V0LUBAc3BlY2llc1xuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWNmNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTUwZVwiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzUzMVwiKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMmY0N1wiKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMWRkZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZWE4XCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2NWVcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNjkyXCIpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihPLCBrZXkgPSBrZXlzW2luZGV4KytdLCBQcm9wZXJ0aWVzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjBlZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzg5Y1wiKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi50b1N0cmluZztcblxuLy8gdGhpcyBoZWxwZXIgYnJva2VuIGluIGBjb3JlLWpzQDMuNC4xLTMuNC40YCwgc28gd2UgY2FuJ3QgdXNlIGBzaGFyZWRgIGhlbHBlclxuaWYgKHR5cGVvZiBzdG9yZS5pbnNwZWN0U291cmNlICE9ICdmdW5jdGlvbicpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjI5NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNDBhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyIGV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDNjNlwiKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCh7IHRhcmdldDogJ1JlZ0V4cCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IC8uLy5leGVjICE9PSBleGVjIH0sIHtcbiAgZXhlYzogZXhlY1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjU0N1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NDMwXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNTRmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjcxNDhcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YTZjXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuICB2YXIgU3ltYm9sID0gcGF0aC5TeW1ib2wgfHwgKHBhdGguU3ltYm9sID0ge30pO1xuICBpZiAoIWhhcyhTeW1ib2wsIE5BTUUpKSBkZWZpbmVQcm9wZXJ0eShTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKE5BTUUpXG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyNjI3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NGRmXCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzRkOFwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjFkY1wiKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIyOTJmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIG1vdmVkIHRvIGVudHJ5IHBvaW50c1xuX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MGFcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDgyN1wiKTtcbnZhciByZWdleHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQzYzZcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjFkY1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdhZVwiKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN5bWJvbC1uYW1lZCBSZWdFeHAgbWV0aG9kcyBjYWxsIC5leGVjXG4gICAgdmFyIGV4ZWNDYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgcmUgPSAvYS87XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBXZSBjYW4ndCB1c2UgcmVhbCByZWdleCBoZXJlIHNpbmNlIGl0IGNhdXNlcyBkZW9wdGltaXphdGlvblxuICAgICAgLy8gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb24gaW4gVjhcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMDZcbiAgICAgIHJlID0ge307XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgICByZS5mbGFncyA9ICcnO1xuICAgICAgcmVbU1lNQk9MXSA9IC8uL1tTWU1CT0xdO1xuICAgIH1cblxuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcblxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSk7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgRk9SQ0VEXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgbWV0aG9kcyA9IGV4ZWMoU1lNQk9MLCAnJ1tLRVldLCBmdW5jdGlvbiAobmF0aXZlTWV0aG9kLCByZWdleHAsIHN0ciwgYXJnMiwgZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgIHZhciAkZXhlYyA9IHJlZ2V4cC5leGVjO1xuICAgICAgaWYgKCRleGVjID09PSByZWdleHBFeGVjIHx8ICRleGVjID09PSBSZWdFeHBQcm90b3R5cGUuZXhlYykge1xuICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAvLyBUaGUgbmF0aXZlIFN0cmluZyBtZXRob2QgYWxyZWFkeSBkZWxlZ2F0ZXMgdG8gQEBtZXRob2QgKHRoaXNcbiAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlUmVnRXhwTWV0aG9kLmNhbGwocmVnZXhwLCBzdHIsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgbWV0aG9kc1swXSk7XG4gICAgcmVkZWZpbmUoUmVnRXhwUHJvdG90eXBlLCBTWU1CT0wsIG1ldGhvZHNbMV0pO1xuICB9XG5cbiAgaWYgKFNIQU0pIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShSZWdFeHBQcm90b3R5cGVbU1lNQk9MXSwgJ3NoYW0nLCB0cnVlKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMjlkMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnLicsICdzJykgLT4gLy4vcyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG4gIHZhciByZSA9IFJlZ0V4cCgnLicsICh0eXBlb2YgJycpLmNoYXJBdCgwKSk7XG4gIHJldHVybiAhKHJlLmRvdEFsbCAmJiByZS5leGVjKCdcXG4nKSAmJiByZS5mbGFncyA9PT0gJ3MnKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJhODFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMjViXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTUxN1wiKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmNvZGVwb2ludGF0XG4gIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kKHRydWUpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJiNjBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb2xsZWN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVkYThcIik7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxYjNiXCIpO1xuXG4vLyBgU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQtb2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJiYjdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzA4XCIpO1xudmFyIERPTUl0ZXJhYmxlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjM1XCIpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ0NTNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3YWVcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjJmNDdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzMWM2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ0MzBcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzJkYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNGRmXCIpO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgdHlwZW9mIChOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM2OTJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwNGZkXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjIyOTRcIik7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM3YmJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NDMwXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzc4M1wiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjODI2XCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDJkZlwiKTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZjlmXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZGM2XCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc0ZGZcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjY1ZVwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRiMWNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkMDZcIik7XG52YXIgbmF0aXZlT2JqZWN0Q3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhMjNcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzNjkyXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDRhNFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDFmOVwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmFhMlwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWE4NlwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZWE4XCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI0ODhcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3YWVcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDgyN1wiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M0MFwiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzUzMVwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5NWNcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjOTRcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YTZjXCIpO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTRmXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ5NmFcIik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYjU5XCIpO1xudmFyICRmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU3NDhcIikuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgaXNTeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9QcmltaXRpdmUoViwgdHJ1ZSk7XG4gIHZhciBlbnVtZXJhYmxlID0gbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIHJlZGVmaW5lKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTtcbn0pO1xuXG4kKHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5pZiAoJHN0cmluZ2lmeSkge1xuICB2YXIgRk9SQ0VEX0pTT05fU1RSSU5HSUZZID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG4gICAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgICAgfHwgJHN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG4gICAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiAgfSk7XG5cbiAgJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyICRyZXBsYWNlcjtcbiAgICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpIGFyZ3MucHVzaChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgICAgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgICAgcmV0dXJuICRzdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjM4OWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzA4XCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MGQwXCIpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiMzhjMVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8vIEVTTSBDT01QQVQgRkxBR1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjc3NcIiwgZnVuY3Rpb24oKSB7IHJldHVybiAvKiByZWV4cG9ydCAqLyBzY3NzX2RlZmF1bHQuYTsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2dWUrY2xpLXNlcnZpY2VANC41LjEzXzBmMjVkMWFhODQxNWU5OGMzZTYyYTQxNzhmM2M1NTVkL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9zZXRQdWJsaWNQYXRoLmpzXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgaW50byBsaWIvd2MgY2xpZW50IGJ1bmRsZXMuXG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHdpbmRvdy5kb2N1bWVudC5jdXJyZW50U2NyaXB0XG4gIGlmICh0cnVlKSB7XG4gICAgdmFyIGdldEN1cnJlbnRTY3JpcHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2RhNVwiKVxuICAgIGN1cnJlbnRTY3JpcHQgPSBnZXRDdXJyZW50U2NyaXB0KClcblxuICAgIC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBiZWNhdXNlIHByZXZpb3VzbHkgd2UgZGlyZWN0bHkgaW5jbHVkZWQgdGhlIHBvbHlmaWxsXG4gICAgaWYgKCEoJ2N1cnJlbnRTY3JpcHQnIGluIGRvY3VtZW50KSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAnY3VycmVudFNjcmlwdCcsIHsgZ2V0OiBnZXRDdXJyZW50U2NyaXB0IH0pXG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYyA9IGN1cnJlbnRTY3JpcHQgJiYgY3VycmVudFNjcmlwdC5zcmMubWF0Y2goLyguK1xcLylbXi9dK1xcLmpzKFxcPy4qKT8kLylcbiAgaWYgKHNyYykge1xuICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IHNyY1sxXSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIH1cbn1cblxuLy8gSW5kaWNhdGUgdG8gd2VicGFjayB0aGF0IHRoaXMgZmlsZSBjYW4gYmUgY29uY2F0ZW5hdGVkXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzZXRQdWJsaWNQYXRoID0gKG51bGwpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjU1MzJlNDEwLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvRGF0ZVBpY2tlci9Ib3RlbERhdGVQaWNrZXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI2NzA1MDQ2JlxudmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gKF92bS52YWx1ZSk/X2MoJ2Rpdicse3JlZjooXCJEYXRlUGlja2VyLVwiICsgX3ZtLmhhc2gpLHN0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyX193cmFwcGVyXCIsY2xhc3M6e1xuICAgICd2aGRfX2RhdGVwaWNrZXJfX3dyYXBwZXItLWdyaWQnOiBfdm0uZ3JpZFN0eWxlLFxuICAgICd2aGRfX2RhdGVwaWNrZXJfX3dyYXBwZXItLWJvb2tpbmcnOiBfdm0uYm9va2luZ3MubGVuZ3RoID4gMCxcbiAgICB2aGRfX2RhdGVwaWNrZXJfX2Z1bGx2aWV3OiBfdm0uYWx3YXlzVmlzaWJsZSxcbiAgfX0sWyhfdm0uaXNPcGVuKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX2Nsb3NlLWJ1dHRvbiB2aGRfX2hpZGUtb24tZGVza3RvcFwiLG9uOntcImNsaWNrXCI6X3ZtLmNsb3NlTW9iaWxlRGF0ZXBpY2tlcn19LFtfYygnaScsW192bS5fdihcIitcIildKV0pOl92bS5fZSgpLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fZHVtbXktd3JhcHBlclwiLGNsYXNzOnsgJ3ZoZF9fZGF0ZXBpY2tlcl9fZHVtbXktd3JhcHBlci0taXMtYWN0aXZlJzogX3ZtLmlzT3BlbiB9fSxbX2MoJ2RhdGUtaW5wdXQnLHthdHRyczp7XCJpMThuXCI6X3ZtLmkxOG4sXCJpbnB1dC1kYXRlXCI6X3ZtLmZvcm1hdERhdGUoX3ZtLmNoZWNrSW4pLFwiaW5wdXQtZGF0ZS10eXBlXCI6XCJjaGVjay1pblwiLFwiaXMtb3BlblwiOl92bS5pc09wZW4sXCJ0b2dnbGUtZGF0ZXBpY2tlclwiOl92bS50b2dnbGVEYXRlcGlja2VyLFwic2luZ2xlLWRheS1zZWxlY3Rpb25cIjpfdm0uc2luZ2xlRGF5U2VsZWN0aW9ufX0pLCghX3ZtLnNpbmdsZURheVNlbGVjdGlvbik/X2MoJ2RhdGUtaW5wdXQnLHthdHRyczp7XCJpMThuXCI6X3ZtLmkxOG4sXCJpbnB1dC1kYXRlXCI6X3ZtLmZvcm1hdERhdGUoX3ZtLmNoZWNrT3V0KSxcImlucHV0LWRhdGUtdHlwZVwiOlwiY2hlY2stb3V0XCIsXCJpcy1vcGVuXCI6X3ZtLmlzT3BlbixcInRvZ2dsZS1kYXRlcGlja2VyXCI6X3ZtLnRvZ2dsZURhdGVwaWNrZXIsXCJzaW5nbGUtZGF5LXNlbGVjdGlvblwiOl92bS5zaW5nbGVEYXlTZWxlY3Rpb259fSk6X3ZtLl9lKCldLDEpLF9jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5zaG93Q2xlYXJTZWxlY3Rpb25CdXR0b24pLGV4cHJlc3Npb246XCJzaG93Q2xlYXJTZWxlY3Rpb25CdXR0b25cIn1dLHN0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyX19jbGVhci1idXR0b25cIixhdHRyczp7XCJ0YWJpbmRleFwiOlwiMFwifSxvbjp7XCJjbGlja1wiOl92bS5jbGVhclNlbGVjdGlvbn19LFtfYygnc3ZnJyx7YXR0cnM6e1wieG1sbnNcIjpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJ2aWV3Qm94XCI6XCIwIDAgNjggNjhcIixcInJvbGVcIjpcImltZ1wiLFwiYXJpYS1sYWJlbFwiOlwieFwifX0sW19jKCd0aXRsZScsW192bS5fdihcInhcIildKSxfYygncGF0aCcse2F0dHJzOntcImRcIjpcIk02LjUgNi41bDU1IDU1bTAtNTVsLTU1IDU1XCIsXCJzdHJva2VcIjpcIiMwMDBcIixcImZpbGxcIjpcIm5vbmVcIixcInN0cm9rZS1saW5lY2FwXCI6XCJzcXVhcmVcIn19KV0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyXCIsY2xhc3M6e1xuICAgICAgJ3ZoZF9fZGF0ZXBpY2tlci0tb3Blbic6IF92bS5pc09wZW4gJiYgIV92bS5hbHdheXNWaXNpYmxlLFxuICAgICAgJ3ZoZF9fZGF0ZXBpY2tlci0tY2xvc2VkJzogIV92bS5pc09wZW4gJiYgIV92bS5hbHdheXNWaXNpYmxlLFxuICAgICAgJ3ZoZF9fZGF0ZXBpY2tlci0tcmlnaHQnOiBfdm0ucG9zaXRpb25SaWdodCxcbiAgICB9fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmhkX19oaWRlLW9uLWRlc2t0b3BcIn0sWyhfdm0uaXNPcGVuKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX2R1bW15LXdyYXBwZXIgdmhkX19kYXRlcGlja2VyX19kdW1teS13cmFwcGVyLS1uby1ib3JkZXJcIixjbGFzczp7ICd2aGRfX2RhdGVwaWNrZXJfX2R1bW15LXdyYXBwZXItLWlzLWFjdGl2ZSc6IF92bS5pc09wZW4gfSxvbjp7XCJjbGlja1wiOl92bS50b2dnbGVEYXRlcGlja2VyfX0sW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9faW5wdXRcIixjbGFzczp7XG4gICAgICAgICAgICAndmhkX19kYXRlcGlja2VyX19kdW1teS1pbnB1dC0taXMtYWN0aXZlJzogX3ZtLmlzT3BlbiAmJiBfdm0uY2hlY2tJbiA9PSBudWxsLFxuICAgICAgICAgIH0sYXR0cnM6e1widGFiaW5kZXhcIjpcIjBcIixcInR5cGVcIjpcImJ1dHRvblwifX0sW192bS5fdihcIiBcIitfdm0uX3MoKFwiXCIgKyAoX3ZtLmNoZWNrSW4gPyBfdm0uZm9ybWF0RGF0ZShfdm0uY2hlY2tJbikgOiBfdm0uaTE4blsnY2hlY2staW4nXSkpKStcIiBcIildKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX2lucHV0XCIsY2xhc3M6e1xuICAgICAgICAgICAgJ3ZoZF9fZGF0ZXBpY2tlcl9fZHVtbXktaW5wdXQtLWlzLWFjdGl2ZSc6IF92bS5pc09wZW4gJiYgX3ZtLmNoZWNrT3V0ID09IG51bGwgJiYgX3ZtLmNoZWNrSW4gIT09IG51bGwsXG4gICAgICAgICAgfSxhdHRyczp7XCJ0YWJpbmRleFwiOlwiMFwiLFwidHlwZVwiOlwiYnV0dG9uXCJ9fSxbX3ZtLl92KFwiIFwiK192bS5fcygoXCJcIiArIChfdm0uY2hlY2tPdXQgPyBfdm0uZm9ybWF0RGF0ZShfdm0uY2hlY2tPdXQpIDogX3ZtLmkxOG5bJ2NoZWNrLW91dCddKSkpK1wiIFwiKV0pXSk6X3ZtLl9lKCldKSwoX3ZtLmlzT3BlbiB8fCBfdm0uYWx3YXlzVmlzaWJsZSk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyX19pbm5lclwifSxbX2MoJ2Rpdicse2NsYXNzOntcbiAgICAgICAgICB2aGRfX2RhdGVwaWNrZXJfX2hlYWRlcjogX3ZtLmlzRGVza3RvcCxcbiAgICAgICAgICAndmhkX19kYXRlcGlja2VyX19oZWFkZXItbW9iaWxlJzogIV92bS5pc0Rlc2t0b3AsXG4gICAgICAgIH19LFtfYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWJ1dHRvbiB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWJ1dHRvbi0tcHJldlwiLGF0dHJzOntcInR5cGVcIjpcImJ1dHRvblwiLFwidGFiaW5kZXhcIjpfdm0uaXNPcGVuID8gMCA6IC0xLFwiZGlzYWJsZWRcIjpfdm0uYWN0aXZlTW9udGhJbmRleCA9PT0gMH0sb246e1wiY2xpY2tcIjpfdm0ucmVuZGVyUHJldmlvdXNNb250aCxcImtleXVwXCI6ZnVuY3Rpb24oJGV2ZW50KXtpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJl92bS5faygkZXZlbnQua2V5Q29kZSxcImVudGVyXCIsMTMsJGV2ZW50LmtleSxcIkVudGVyXCIpKXsgcmV0dXJuIG51bGw7IH0kZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JGV2ZW50LnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIF92bS5yZW5kZXJQcmV2aW91c01vbnRoLmFwcGx5KG51bGwsIGFyZ3VtZW50cyl9fX0pLF9jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtYnV0dG9uIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtYnV0dG9uLS1uZXh0XCIsYXR0cnM6e1widHlwZVwiOlwiYnV0dG9uXCIsXCJkaXNhYmxlZFwiOl92bS5pc1ByZXZlbnRlZE1heE1vbnRoLFwidGFiaW5kZXhcIjpfdm0uaXNPcGVuID8gMCA6IC0xfSxvbjp7XCJjbGlja1wiOl92bS5yZW5kZXJOZXh0TW9udGgsXCJrZXl1cFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZfdm0uX2soJGV2ZW50LmtleUNvZGUsXCJlbnRlclwiLDEzLCRldmVudC5rZXksXCJFbnRlclwiKSl7IHJldHVybiBudWxsOyB9JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyRldmVudC5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBfdm0ucmVuZGVyTmV4dE1vbnRoLmFwcGx5KG51bGwsIGFyZ3VtZW50cyl9fX0pXSksKF92bS5pc0Rlc2t0b3AgfHwgX3ZtLmFsd2F5c1Zpc2libGUpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fbW9udGhzXCIsY2xhc3M6eyAndmhkX19kYXRlcGlja2VyX19tb250aHMtLWZ1bGwnOiBfdm0uc2hvd1NpbmdsZU1vbnRoIH19LF92bS5fbCgoX3ZtLnBhZ2luYXRlTW9udGhzKSxmdW5jdGlvbihtb250aCxtb250aEluZGV4KXtyZXR1cm4gX2MoJ01vbnRoJyx7a2V5Oihfdm0uZGF0ZXBpY2tlck1vbnRoS2V5ICsgXCItXCIgKyBtb250aEluZGV4ICsgXCItZGVza3RvcFwiKSxyZWY6XCJkYXRlcGlja2VyTW9udGhcIixyZWZJbkZvcjp0cnVlLGF0dHJzOntcIm1vbnRoXCI6bW9udGgsXCJkYXlLZXlcIjpfdm0uZGF0ZXBpY2tlckRheUtleSxcIndlZWtLZXlcIjpfdm0uZGF0ZXBpY2tlcldlZWtLZXksXCJpc0Rlc2t0b3BcIjpfdm0uaXNEZXNrdG9wLFwiZmlyc3REYXlPZldlZWtcIjpfdm0uZmlyc3REYXlPZldlZWssXCJzaG93WWVhclwiOl92bS5zaG93WWVhcixcInllYXJCZWZvcmVNb250aFwiOl92bS55ZWFyQmVmb3JlTW9udGgsXCJhY3RpdmVNb250aEluZGV4XCI6X3ZtLmFjdGl2ZU1vbnRoSW5kZXgsXCJib29raW5nc1wiOl92bS5zb3J0Qm9va2luZ3MsXCJjaGVja0luXCI6X3ZtLmNoZWNrSW4sXCJjaGVja0luY2hlY2tPdXRIYWxmRGF5XCI6X3ZtLmNoZWNrSW5jaGVja091dEhhbGZEYXksXCJjaGVja0luUGVyaW9kXCI6X3ZtLmNoZWNrSW5QZXJpb2QsXCJjaGVja091dFwiOl92bS5jaGVja091dCxcImRpc2FibGVDaGVja291dE9uQ2hlY2tpblwiOl92bS5kaXNhYmxlQ2hlY2tvdXRPbkNoZWNraW4sXCJkdXBsaWNhdGVCb29raW5nRGF0ZXNcIjpfdm0uZHVwbGljYXRlQm9va2luZ0RhdGVzLFwiaG92ZXJpbmdEYXRlXCI6X3ZtLmhvdmVyaW5nRGF0ZSxcImhvdmVyaW5nUGVyaW9kXCI6X3ZtLmhvdmVyaW5nUGVyaW9kLFwiaTE4blwiOl92bS5pMThuLFwiaXNPcGVuXCI6X3ZtLmlzT3BlbixcIm1pbk5pZ2h0Q291bnRcIjpfdm0ubWluTmlnaHRDb3VudCxcIm5leHREaXNhYmxlZERhdGVcIjpfdm0ubmV4dERpc2FibGVkRGF0ZSxcIm5leHRQZXJpb2REaXNhYmxlRGF0ZXNcIjpfdm0ubmV4dFBlcmlvZERpc2FibGVEYXRlcyxcIm9wdGlvbnNcIjpfdm0uZGF5T3B0aW9ucyxcInByaWNlU3ltYm9sXCI6X3ZtLnByaWNlU3ltYm9sLFwic2NyZWVuU2l6ZVwiOl92bS5zY3JlZW5TaXplLFwic2hvd0N1c3RvbVRvb2x0aXBcIjpfdm0uc2hvd0N1c3RvbVRvb2x0aXAsXCJzaG93UHJpY2VcIjpfdm0uc2hvd1ByaWNlLFwic2hvd1dlZWtOdW1iZXJzXCI6X3ZtLnNob3dXZWVrTnVtYmVycyxcImRpc2FibGVkRGF0ZXNcIjpfdm0uZGlzYWJsZWREYXRlcyxcInBlcmlvZERhdGVzXCI6X3ZtLnBlcmlvZERhdGVzLFwic29ydGVkRGlzYWJsZWREYXRlc1wiOl92bS5zb3J0ZWREaXNhYmxlZERhdGVzLFwic29ydGVkUGVyaW9kRGF0ZXNcIjpfdm0uc29ydGVkUGVyaW9kRGF0ZXMsXCJ0b29sdGlwTWVzc2FnZVwiOl92bS5jdXN0b21Ub29sdGlwTWVzc2FnZX0sb246e1wiY2xlYXItc2VsZWN0aW9uXCI6X3ZtLmNsZWFyU2VsZWN0aW9uLFwiYm9va2luZy1jbGlja2VkXCI6X3ZtLmhhbmRsZUJvb2tpbmdDbGlja2VkLFwiZGF5LWNsaWNrZWRcIjpfdm0uaGFuZGxlRGF5Q2xpY2ssXCJlbnRlci1kYXlcIjpfdm0uZW50ZXJEYXksXCJlbnRlci1tb250aFwiOl92bS5lbnRlck1vbnRofX0pfSksMSk6X3ZtLl9lKCksKCFfdm0uaXNEZXNrdG9wICYmIF92bS5pc09wZW4gJiYgIV92bS5hbHdheXNWaXNpYmxlKT9fYygnZGl2Jyx7Y2xhc3M6Wyd2aGRfX2RhdGVwaWNrZXJfX21vbnRocy13cmFwcGVyJywgeyAndmhkX19zaG93LXRvb2x0aXAnOiBfdm0uc2hvd0N1c3RvbVRvb2x0aXAgJiYgX3ZtLmhvdmVyaW5nVG9vbHRpcCB9XX0sWyhfdm0uaG92ZXJpbmdUb29sdGlwKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX3Rvb2x0aXAtLW1vYmlsZVwifSxbKF92bS5jdXN0b21Ub29sdGlwTWVzc2FnZSk/W192bS5fdihcIiBcIitfdm0uX3MoX3ZtLmNsZWFuU3RyaW5nKF92bS5jdXN0b21Ub29sdGlwTWVzc2FnZSkpK1wiIFwiKV06X3ZtLl9lKCldLDIpOl92bS5fZSgpLF9jKCdkaXYnLHtyZWY6XCJzd2lwZXJXcmFwcGVyXCIsc3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX21vbnRoc1wifSxfdm0uX2woKF92bS5wYWdpbmF0ZU1vbnRocyksZnVuY3Rpb24obW9udGgsbW9udGhJbmRleCl7cmV0dXJuIF9jKCdNb250aCcse2tleTooX3ZtLmRhdGVwaWNrZXJNb250aEtleSArIFwiLVwiICsgbW9udGhJbmRleCArIFwiLWRlc2t0b3BcIikscmVmOlwiZGF0ZXBpY2tlck1vbnRoXCIscmVmSW5Gb3I6dHJ1ZSxhdHRyczp7XCJtb250aFwiOm1vbnRoLFwiZGF5S2V5XCI6X3ZtLmRhdGVwaWNrZXJEYXlLZXksXCJ3ZWVrS2V5XCI6X3ZtLmRhdGVwaWNrZXJXZWVrS2V5LFwiaXNEZXNrdG9wXCI6X3ZtLmlzRGVza3RvcCxcImZpcnN0RGF5T2ZXZWVrXCI6X3ZtLmZpcnN0RGF5T2ZXZWVrLFwic2hvd1llYXJcIjpfdm0uc2hvd1llYXIsXCJ5ZWFyQmVmb3JlTW9udGhcIjpfdm0ueWVhckJlZm9yZU1vbnRoLFwiYWN0aXZlTW9udGhJbmRleFwiOl92bS5hY3RpdmVNb250aEluZGV4LFwiYm9va2luZ3NcIjpfdm0uc29ydEJvb2tpbmdzLFwiY2hlY2tJblwiOl92bS5jaGVja0luLFwiY2hlY2tJbmNoZWNrT3V0SGFsZkRheVwiOl92bS5jaGVja0luY2hlY2tPdXRIYWxmRGF5LFwiY2hlY2tJblBlcmlvZFwiOl92bS5jaGVja0luUGVyaW9kLFwiY2hlY2tPdXRcIjpfdm0uY2hlY2tPdXQsXCJkaXNhYmxlQ2hlY2tvdXRPbkNoZWNraW5cIjpfdm0uZGlzYWJsZUNoZWNrb3V0T25DaGVja2luLFwiZHVwbGljYXRlQm9va2luZ0RhdGVzXCI6X3ZtLmR1cGxpY2F0ZUJvb2tpbmdEYXRlcyxcImhvdmVyaW5nRGF0ZVwiOl92bS5ob3ZlcmluZ0RhdGUsXCJob3ZlcmluZ1BlcmlvZFwiOl92bS5ob3ZlcmluZ1BlcmlvZCxcImkxOG5cIjpfdm0uaTE4bixcImlzT3BlblwiOl92bS5pc09wZW4sXCJtaW5OaWdodENvdW50XCI6X3ZtLm1pbk5pZ2h0Q291bnQsXCJuZXh0RGlzYWJsZWREYXRlXCI6X3ZtLm5leHREaXNhYmxlZERhdGUsXCJuZXh0UGVyaW9kRGlzYWJsZURhdGVzXCI6X3ZtLm5leHRQZXJpb2REaXNhYmxlRGF0ZXMsXCJvcHRpb25zXCI6X3ZtLmRheU9wdGlvbnMsXCJwcmljZVN5bWJvbFwiOl92bS5wcmljZVN5bWJvbCxcInNjcmVlblNpemVcIjpfdm0uc2NyZWVuU2l6ZSxcInNob3dDdXN0b21Ub29sdGlwXCI6ZmFsc2UsXCJzaG93UHJpY2VcIjpfdm0uc2hvd1ByaWNlLFwic29ydGVkRGlzYWJsZWREYXRlc1wiOl92bS5zb3J0ZWREaXNhYmxlZERhdGVzLFwic29ydGVkUGVyaW9kRGF0ZXNcIjpfdm0uc29ydGVkUGVyaW9kRGF0ZXMsXCJ0b29sdGlwTWVzc2FnZVwiOl92bS5jdXN0b21Ub29sdGlwTWVzc2FnZX0sb246e1wiY2xlYXItc2VsZWN0aW9uXCI6X3ZtLmNsZWFyU2VsZWN0aW9uLFwiYm9va2luZy1jbGlja2VkXCI6X3ZtLmhhbmRsZUJvb2tpbmdDbGlja2VkLFwiZGF5LWNsaWNrZWRcIjpfdm0uaGFuZGxlRGF5Q2xpY2ssXCJlbnRlci1kYXlcIjpfdm0uZW50ZXJEYXksXCJlbnRlci1tb250aFwiOl92bS5lbnRlck1vbnRofX0pfSksMSldKTpfdm0uX2UoKV0pOl92bS5fZSgpLF92bS5fdChcImNvbnRlbnRcIildLDIpXSk6X3ZtLl9lKCl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL0hvdGVsRGF0ZVBpY2tlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjY3MDUwNDYmXG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1xudmFyIGVzX29iamVjdF9rZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlNjVcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcbnZhciBlc19zeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzdiYlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbHRlci5qc1xudmFyIGVzX2FycmF5X2ZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1MTA4XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xudmFyIGVzX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmFlOVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcbnZhciB3ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA5ZWJcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1xudmFyIGVzX29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjNmNWRcIik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL0BiYWJlbCtydW50aW1lQDcuMTQuNi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3J1bnRpbWVANy4xNC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RTcHJlYWQyLmpzXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuXG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL0BiYWJlbCtydW50aW1lQDcuMTQuNi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qc1xuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3J1bnRpbWVANy4xNC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qc1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qc1xudmFyIGVzX3N5bWJvbF9kZXNjcmlwdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwNGMxXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1xudmFyIGVzX29iamVjdF90b19zdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmMzOVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1xudmFyIGVzX3N5bWJvbF9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1Y2M3XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkNDUzXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzXG52YXIgZXNfc3RyaW5nX2l0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjgzY2VcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzXG52YXIgd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYmI3XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZnJvbS5qc1xudmFyIGVzX2FycmF5X2Zyb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODE3MFwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3J1bnRpbWVANy4xNC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXkuanNcblxuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcbnZhciBlc19hcnJheV9zbGljZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MDY1XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1xudmFyIGVzX2Z1bmN0aW9uX25hbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGU4OVwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3J1bnRpbWVANy4xNC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1xuXG5cblxuXG5cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vQGJhYmVsK3J1bnRpbWVANy4xNC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qc1xuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL0BiYWJlbCtydW50aW1lQDcuMTQuNi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanNcblxuXG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qc1xudmFyIGVzX251bWJlcl9jb25zdHJ1Y3RvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZjg2XCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qc1xudmFyIGVzX2FycmF5X3NvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjVlY1wiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcbnZhciBlc19hcnJheV9qb2luID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImVmNGVcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAuZXhlYy5qc1xudmFyIGVzX3JlZ2V4cF9leGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI0MGFcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanNcbnZhciBlc19zdHJpbmdfc3BsaXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWYyZFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qc1xudmFyIGVzX3NldCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYjYwXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzXG52YXIgZXNfYXJyYXlfbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk4MDhcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY29yZS1qc0AzLjE1LjIvbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcbnZhciBlc19hcnJheV9jb25jYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTA4M1wiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzXG52YXIgZXNfYXJyYXlfaW5jbHVkZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjI4YlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pbmNsdWRlcy5qc1xudmFyIGVzX3N0cmluZ19pbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NWVhXCIpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbi5qc1xudmFyIGVzX29iamVjdF9hc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmI2NlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5lbnRyaWVzLmpzXG52YXIgZXNfb2JqZWN0X2VudHJpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOTIzMlwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yZXBsYWNlLmpzXG52YXIgZXNfc3RyaW5nX3JlcGxhY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODEzYVwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQuanNcbnZhciBlc19hcnJheV9maW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImI1ZGJcIik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vbG9kYXNoLnRocm90dGxlQDQuMS4xL25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanNcbnZhciBsb2Rhc2hfdGhyb3R0bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmM4MFwiKTtcbnZhciBsb2Rhc2hfdGhyb3R0bGVfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX3Rocm90dGxlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vZmVjaGFANC4yLjEvbm9kZV9tb2R1bGVzL2ZlY2hhL2xpYi9mZWNoYS5qc1xudmFyIHRva2VuID0gL2R7MSw0fXxNezEsNH18WVkoPzpZWSk/fFN7MSwzfXxEb3xaWnxafChbSGhNc0RtXSlcXDE/fFthQV18XCJbXlwiXSpcInwnW14nXSonL2c7XG52YXIgdHdvRGlnaXRzT3B0aW9uYWwgPSBcIlsxLTldXFxcXGQ/XCI7XG52YXIgdHdvRGlnaXRzID0gXCJcXFxcZFxcXFxkXCI7XG52YXIgdGhyZWVEaWdpdHMgPSBcIlxcXFxkezN9XCI7XG52YXIgZm91ckRpZ2l0cyA9IFwiXFxcXGR7NH1cIjtcbnZhciB3b3JkID0gXCJbXlxcXFxzXStcIjtcbnZhciBsaXRlcmFsID0gL1xcWyhbXl0qPylcXF0vZ207XG5mdW5jdGlvbiBzaG9ydGVuKGFyciwgc0xlbikge1xuICAgIHZhciBuZXdBcnIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG5ld0Fyci5wdXNoKGFycltpXS5zdWJzdHIoMCwgc0xlbikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3QXJyO1xufVxudmFyIG1vbnRoVXBkYXRlID0gZnVuY3Rpb24gKGFyck5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICh2LCBpMThuKSB7XG4gICAgdmFyIGxvd2VyQ2FzZUFyciA9IGkxOG5bYXJyTmFtZV0ubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiB2LnRvTG93ZXJDYXNlKCk7IH0pO1xuICAgIHZhciBpbmRleCA9IGxvd2VyQ2FzZUFyci5pbmRleE9mKHYudG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07IH07XG5mdW5jdGlvbiBmZWNoYV9hc3NpZ24ob3JpZ09iaikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGFyZ3NfMVtfYV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgZXhcbiAgICAgICAgICAgIG9yaWdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnT2JqO1xufVxudmFyIGZlY2hhX2RheU5hbWVzID0gW1xuICAgIFwiU3VuZGF5XCIsXG4gICAgXCJNb25kYXlcIixcbiAgICBcIlR1ZXNkYXlcIixcbiAgICBcIldlZG5lc2RheVwiLFxuICAgIFwiVGh1cnNkYXlcIixcbiAgICBcIkZyaWRheVwiLFxuICAgIFwiU2F0dXJkYXlcIlxuXTtcbnZhciBtb250aE5hbWVzID0gW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbl07XG52YXIgbW9udGhOYW1lc1Nob3J0ID0gc2hvcnRlbihtb250aE5hbWVzLCAzKTtcbnZhciBkYXlOYW1lc1Nob3J0ID0gc2hvcnRlbihmZWNoYV9kYXlOYW1lcywgMyk7XG52YXIgZGVmYXVsdEkxOG4gPSB7XG4gICAgZGF5TmFtZXNTaG9ydDogZGF5TmFtZXNTaG9ydCxcbiAgICBkYXlOYW1lczogZmVjaGFfZGF5TmFtZXMsXG4gICAgbW9udGhOYW1lc1Nob3J0OiBtb250aE5hbWVzU2hvcnQsXG4gICAgbW9udGhOYW1lczogbW9udGhOYW1lcyxcbiAgICBhbVBtOiBbXCJhbVwiLCBcInBtXCJdLFxuICAgIERvRm46IGZ1bmN0aW9uIChkYXlPZk1vbnRoKSB7XG4gICAgICAgIHJldHVybiAoZGF5T2ZNb250aCArXG4gICAgICAgICAgICBbXCJ0aFwiLCBcInN0XCIsIFwibmRcIiwgXCJyZFwiXVtkYXlPZk1vbnRoICUgMTAgPiAzXG4gICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgOiAoKGRheU9mTW9udGggLSAoZGF5T2ZNb250aCAlIDEwKSAhPT0gMTAgPyAxIDogMCkgKiBkYXlPZk1vbnRoKSAlIDEwXSk7XG4gICAgfVxufTtcbnZhciBnbG9iYWxJMThuID0gZmVjaGFfYXNzaWduKHt9LCBkZWZhdWx0STE4bik7XG52YXIgc2V0R2xvYmFsRGF0ZUkxOG4gPSBmdW5jdGlvbiAoaTE4bikge1xuICAgIHJldHVybiAoZ2xvYmFsSTE4biA9IGZlY2hhX2Fzc2lnbihnbG9iYWxJMThuLCBpMThuKSk7XG59O1xudmFyIHJlZ2V4RXNjYXBlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxceygpW14kKyo/Li1dL2csIFwiXFxcXCQmXCIpO1xufTtcbnZhciBwYWQgPSBmdW5jdGlvbiAodmFsLCBsZW4pIHtcbiAgICBpZiAobGVuID09PSB2b2lkIDApIHsgbGVuID0gMjsgfVxuICAgIHZhbCA9IFN0cmluZyh2YWwpO1xuICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIHZhbCA9IFwiMFwiICsgdmFsO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufTtcbnZhciBmb3JtYXRGbGFncyA9IHtcbiAgICBEOiBmdW5jdGlvbiAoZGF0ZU9iaikgeyByZXR1cm4gU3RyaW5nKGRhdGVPYmouZ2V0RGF0ZSgpKTsgfSxcbiAgICBERDogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIHBhZChkYXRlT2JqLmdldERhdGUoKSk7IH0sXG4gICAgRG86IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICAgIHJldHVybiBpMThuLkRvRm4oZGF0ZU9iai5nZXREYXRlKCkpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIFN0cmluZyhkYXRlT2JqLmdldERheSgpKTsgfSxcbiAgICBkZDogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIHBhZChkYXRlT2JqLmdldERheSgpKTsgfSxcbiAgICBkZGQ6IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICAgIHJldHVybiBpMThuLmRheU5hbWVzU2hvcnRbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBkZGRkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgICByZXR1cm4gaTE4bi5kYXlOYW1lc1tkYXRlT2JqLmdldERheSgpXTtcbiAgICB9LFxuICAgIE06IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBTdHJpbmcoZGF0ZU9iai5nZXRNb250aCgpICsgMSk7IH0sXG4gICAgTU06IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBwYWQoZGF0ZU9iai5nZXRNb250aCgpICsgMSk7IH0sXG4gICAgTU1NOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzU2hvcnRbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIE1NTU06IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICAgIHJldHVybiBpMThuLm1vbnRoTmFtZXNbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIFlZOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgICByZXR1cm4gcGFkKFN0cmluZyhkYXRlT2JqLmdldEZ1bGxZZWFyKCkpLCA0KS5zdWJzdHIoMik7XG4gICAgfSxcbiAgICBZWVlZOiBmdW5jdGlvbiAoZGF0ZU9iaikgeyByZXR1cm4gcGFkKGRhdGVPYmouZ2V0RnVsbFllYXIoKSwgNCk7IH0sXG4gICAgaDogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIFN0cmluZyhkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMik7IH0sXG4gICAgaGg6IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBwYWQoZGF0ZU9iai5nZXRIb3VycygpICUgMTIgfHwgMTIpOyB9LFxuICAgIEg6IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBTdHJpbmcoZGF0ZU9iai5nZXRIb3VycygpKTsgfSxcbiAgICBISDogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkpOyB9LFxuICAgIG06IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBTdHJpbmcoZGF0ZU9iai5nZXRNaW51dGVzKCkpOyB9LFxuICAgIG1tOiBmdW5jdGlvbiAoZGF0ZU9iaikgeyByZXR1cm4gcGFkKGRhdGVPYmouZ2V0TWludXRlcygpKTsgfSxcbiAgICBzOiBmdW5jdGlvbiAoZGF0ZU9iaikgeyByZXR1cm4gU3RyaW5nKGRhdGVPYmouZ2V0U2Vjb25kcygpKTsgfSxcbiAgICBzczogZnVuY3Rpb24gKGRhdGVPYmopIHsgcmV0dXJuIHBhZChkYXRlT2JqLmdldFNlY29uZHMoKSk7IH0sXG4gICAgUzogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJvdW5kKGRhdGVPYmouZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMDApKTtcbiAgICB9LFxuICAgIFNTOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgICByZXR1cm4gcGFkKE1hdGgucm91bmQoZGF0ZU9iai5nZXRNaWxsaXNlY29uZHMoKSAvIDEwKSwgMik7XG4gICAgfSxcbiAgICBTU1M6IGZ1bmN0aW9uIChkYXRlT2JqKSB7IHJldHVybiBwYWQoZGF0ZU9iai5nZXRNaWxsaXNlY29uZHMoKSwgMyk7IH0sXG4gICAgYTogZnVuY3Rpb24gKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKSA8IDEyID8gaTE4bi5hbVBtWzBdIDogaTE4bi5hbVBtWzFdO1xuICAgIH0sXG4gICAgQTogZnVuY3Rpb24gKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKSA8IDEyXG4gICAgICAgICAgICA/IGkxOG4uYW1QbVswXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICA6IGkxOG4uYW1QbVsxXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0sXG4gICAgWlo6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiAoKG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiKSArXG4gICAgICAgICAgICBwYWQoTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApICogMTAwICsgKE1hdGguYWJzKG9mZnNldCkgJSA2MCksIDQpKTtcbiAgICB9LFxuICAgIFo6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiAoKG9mZnNldCA+IDAgPyBcIi1cIiA6IFwiK1wiKSArXG4gICAgICAgICAgICBwYWQoTWF0aC5mbG9vcihNYXRoLmFicyhvZmZzZXQpIC8gNjApLCAyKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICBwYWQoTWF0aC5hYnMob2Zmc2V0KSAlIDYwLCAyKSk7XG4gICAgfVxufTtcbnZhciBtb250aFBhcnNlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuICt2IC0gMTsgfTtcbnZhciBlbXB0eURpZ2l0cyA9IFtudWxsLCB0d29EaWdpdHNPcHRpb25hbF07XG52YXIgZW1wdHlXb3JkID0gW251bGwsIHdvcmRdO1xudmFyIGFtUG0gPSBbXG4gICAgXCJpc1BtXCIsXG4gICAgd29yZCxcbiAgICBmdW5jdGlvbiAodiwgaTE4bikge1xuICAgICAgICB2YXIgdmFsID0gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodmFsID09PSBpMThuLmFtUG1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5dO1xudmFyIHRpbWV6b25lT2Zmc2V0ID0gW1xuICAgIFwidGltZXpvbmVPZmZzZXRcIixcbiAgICBcIlteXFxcXHNdKj9bXFxcXCtcXFxcLV1cXFxcZFxcXFxkOj9cXFxcZFxcXFxkfFteXFxcXHNdKj9aP1wiLFxuICAgIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHZhciBwYXJ0cyA9ICh2ICsgXCJcIikubWF0Y2goLyhbKy1dfFxcZFxcZCkvZ2kpO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAgIHZhciBtaW51dGVzID0gK3BhcnRzWzFdICogNjAgKyBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnRzWzBdID09PSBcIitcIiA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5dO1xudmFyIHBhcnNlRmxhZ3MgPSB7XG4gICAgRDogW1wiZGF5XCIsIHR3b0RpZ2l0c09wdGlvbmFsXSxcbiAgICBERDogW1wiZGF5XCIsIHR3b0RpZ2l0c10sXG4gICAgRG86IFtcImRheVwiLCB0d29EaWdpdHNPcHRpb25hbCArIHdvcmQsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUludCh2LCAxMCk7IH1dLFxuICAgIE06IFtcIm1vbnRoXCIsIHR3b0RpZ2l0c09wdGlvbmFsLCBtb250aFBhcnNlXSxcbiAgICBNTTogW1wibW9udGhcIiwgdHdvRGlnaXRzLCBtb250aFBhcnNlXSxcbiAgICBZWTogW1xuICAgICAgICBcInllYXJcIixcbiAgICAgICAgdHdvRGlnaXRzLFxuICAgICAgICBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB2YXIgY2VudCA9ICsoXCJcIiArIG5vdy5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgICByZXR1cm4gKyhcIlwiICsgKCt2ID4gNjggPyBjZW50IC0gMSA6IGNlbnQpICsgdik7XG4gICAgICAgIH1cbiAgICBdLFxuICAgIGg6IFtcImhvdXJcIiwgdHdvRGlnaXRzT3B0aW9uYWwsIHVuZGVmaW5lZCwgXCJpc1BtXCJdLFxuICAgIGhoOiBbXCJob3VyXCIsIHR3b0RpZ2l0cywgdW5kZWZpbmVkLCBcImlzUG1cIl0sXG4gICAgSDogW1wiaG91clwiLCB0d29EaWdpdHNPcHRpb25hbF0sXG4gICAgSEg6IFtcImhvdXJcIiwgdHdvRGlnaXRzXSxcbiAgICBtOiBbXCJtaW51dGVcIiwgdHdvRGlnaXRzT3B0aW9uYWxdLFxuICAgIG1tOiBbXCJtaW51dGVcIiwgdHdvRGlnaXRzXSxcbiAgICBzOiBbXCJzZWNvbmRcIiwgdHdvRGlnaXRzT3B0aW9uYWxdLFxuICAgIHNzOiBbXCJzZWNvbmRcIiwgdHdvRGlnaXRzXSxcbiAgICBZWVlZOiBbXCJ5ZWFyXCIsIGZvdXJEaWdpdHNdLFxuICAgIFM6IFtcIm1pbGxpc2Vjb25kXCIsIFwiXFxcXGRcIiwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuICt2ICogMTAwOyB9XSxcbiAgICBTUzogW1wibWlsbGlzZWNvbmRcIiwgdHdvRGlnaXRzLCBmdW5jdGlvbiAodikgeyByZXR1cm4gK3YgKiAxMDsgfV0sXG4gICAgU1NTOiBbXCJtaWxsaXNlY29uZFwiLCB0aHJlZURpZ2l0c10sXG4gICAgZDogZW1wdHlEaWdpdHMsXG4gICAgZGQ6IGVtcHR5RGlnaXRzLFxuICAgIGRkZDogZW1wdHlXb3JkLFxuICAgIGRkZGQ6IGVtcHR5V29yZCxcbiAgICBNTU06IFtcIm1vbnRoXCIsIHdvcmQsIG1vbnRoVXBkYXRlKFwibW9udGhOYW1lc1Nob3J0XCIpXSxcbiAgICBNTU1NOiBbXCJtb250aFwiLCB3b3JkLCBtb250aFVwZGF0ZShcIm1vbnRoTmFtZXNcIildLFxuICAgIGE6IGFtUG0sXG4gICAgQTogYW1QbSxcbiAgICBaWjogdGltZXpvbmVPZmZzZXQsXG4gICAgWjogdGltZXpvbmVPZmZzZXRcbn07XG4vLyBTb21lIGNvbW1vbiBmb3JtYXQgc3RyaW5nc1xudmFyIGdsb2JhbE1hc2tzID0ge1xuICAgIGRlZmF1bHQ6IFwiZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzXCIsXG4gICAgc2hvcnREYXRlOiBcIk0vRC9ZWVwiLFxuICAgIG1lZGl1bURhdGU6IFwiTU1NIEQsIFlZWVlcIixcbiAgICBsb25nRGF0ZTogXCJNTU1NIEQsIFlZWVlcIixcbiAgICBmdWxsRGF0ZTogXCJkZGRkLCBNTU1NIEQsIFlZWVlcIixcbiAgICBpc29EYXRlOiBcIllZWVktTU0tRERcIixcbiAgICBpc29EYXRlVGltZTogXCJZWVlZLU1NLUREVEhIOm1tOnNzWlwiLFxuICAgIHNob3J0VGltZTogXCJISDptbVwiLFxuICAgIG1lZGl1bVRpbWU6IFwiSEg6bW06c3NcIixcbiAgICBsb25nVGltZTogXCJISDptbTpzcy5TU1NcIlxufTtcbnZhciBzZXRHbG9iYWxEYXRlTWFza3MgPSBmdW5jdGlvbiAobWFza3MpIHsgcmV0dXJuIGZlY2hhX2Fzc2lnbihnbG9iYWxNYXNrcywgbWFza3MpOyB9O1xuLyoqKlxuICogRm9ybWF0IGEgZGF0ZVxuICogQG1ldGhvZCBmb3JtYXRcbiAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ9IGRhdGVPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXNrIEZvcm1hdCBvZiB0aGUgZGF0ZSwgaS5lLiAnbW0tZGQteXknIG9yICdzaG9ydERhdGUnXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgZGF0ZSBzdHJpbmdcbiAqL1xudmFyIGZlY2hhX2Zvcm1hdCA9IGZ1bmN0aW9uIChkYXRlT2JqLCBtYXNrLCBpMThuKSB7XG4gICAgaWYgKG1hc2sgPT09IHZvaWQgMCkgeyBtYXNrID0gZ2xvYmFsTWFza3NbXCJkZWZhdWx0XCJdOyB9XG4gICAgaWYgKGkxOG4gPT09IHZvaWQgMCkgeyBpMThuID0ge307IH1cbiAgICBpZiAodHlwZW9mIGRhdGVPYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZGF0ZU9iaiA9IG5ldyBEYXRlKGRhdGVPYmopO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGVPYmopICE9PSBcIltvYmplY3QgRGF0ZV1cIiB8fFxuICAgICAgICBpc05hTihkYXRlT2JqLmdldFRpbWUoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBEYXRlIHBhc3MgdG8gZm9ybWF0XCIpO1xuICAgIH1cbiAgICBtYXNrID0gZ2xvYmFsTWFza3NbbWFza10gfHwgbWFzaztcbiAgICB2YXIgbGl0ZXJhbHMgPSBbXTtcbiAgICAvLyBNYWtlIGxpdGVyYWxzIGluYWN0aXZlIGJ5IHJlcGxhY2luZyB0aGVtIHdpdGggQEBAXG4gICAgbWFzayA9IG1hc2sucmVwbGFjZShsaXRlcmFsLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgIGxpdGVyYWxzLnB1c2goJDEpO1xuICAgICAgICByZXR1cm4gXCJAQEBcIjtcbiAgICB9KTtcbiAgICB2YXIgY29tYmluZWRJMThuU2V0dGluZ3MgPSBmZWNoYV9hc3NpZ24oZmVjaGFfYXNzaWduKHt9LCBnbG9iYWxJMThuKSwgaTE4bik7XG4gICAgLy8gQXBwbHkgZm9ybWF0dGluZyBydWxlc1xuICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0RmxhZ3NbJDBdKGRhdGVPYmosIGNvbWJpbmVkSTE4blNldHRpbmdzKTtcbiAgICB9KTtcbiAgICAvLyBJbmxpbmUgbGl0ZXJhbCB2YWx1ZXMgYmFjayBpbnRvIHRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICByZXR1cm4gbWFzay5yZXBsYWNlKC9AQEAvZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gbGl0ZXJhbHMuc2hpZnQoKTsgfSk7XG59O1xuLyoqXG4gKiBQYXJzZSBhIGRhdGUgc3RyaW5nIGludG8gYSBKYXZhc2NyaXB0IERhdGUgb2JqZWN0IC9cbiAqIEBtZXRob2QgcGFyc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIERhdGUgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0IERhdGUgcGFyc2UgZm9ybWF0XG4gKiBAcGFyYW0ge2kxOG59IEkxOG5TZXR0aW5nc09wdGlvbmFsIEZ1bGwgb3Igc3Vic2V0IG9mIEkxOE4gc2V0dGluZ3NcbiAqIEByZXR1cm5zIHtEYXRlfG51bGx9IFJldHVybnMgRGF0ZSBvYmplY3QuIFJldHVybnMgbnVsbCB3aGF0IGRhdGUgc3RyaW5nIGlzIGludmFsaWQgb3IgZG9lc24ndCBtYXRjaCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gcGFyc2UoZGF0ZVN0ciwgZm9ybWF0LCBpMThuKSB7XG4gICAgaWYgKGkxOG4gPT09IHZvaWQgMCkgeyBpMThuID0ge307IH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdCBpbiBmZWNoYSBwYXJzZVwiKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBmb3JtYXQgaXMgYWN0dWFsbHkgYSBtYXNrXG4gICAgZm9ybWF0ID0gZ2xvYmFsTWFza3NbZm9ybWF0XSB8fCBmb3JtYXQ7XG4gICAgLy8gQXZvaWQgcmVndWxhciBleHByZXNzaW9uIGRlbmlhbCBvZiBzZXJ2aWNlLCBmYWlsIGVhcmx5IGZvciByZWFsbHkgbG9uZyBzdHJpbmdzXG4gICAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9SZWd1bGFyX2V4cHJlc3Npb25fRGVuaWFsX29mX1NlcnZpY2VfLV9SZURvU1xuICAgIGlmIChkYXRlU3RyLmxlbmd0aCA+IDEwMDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgeWVhci5cbiAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIHZhciBkYXRlSW5mbyA9IHtcbiAgICAgICAgeWVhcjogdG9kYXkuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgbW9udGg6IDAsXG4gICAgICAgIGRheTogMSxcbiAgICAgICAgaG91cjogMCxcbiAgICAgICAgbWludXRlOiAwLFxuICAgICAgICBzZWNvbmQ6IDAsXG4gICAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgICAgICBpc1BtOiBudWxsLFxuICAgICAgICB0aW1lem9uZU9mZnNldDogbnVsbFxuICAgIH07XG4gICAgdmFyIHBhcnNlSW5mbyA9IFtdO1xuICAgIHZhciBsaXRlcmFscyA9IFtdO1xuICAgIC8vIFJlcGxhY2UgYWxsIHRoZSBsaXRlcmFscyB3aXRoIEBAQC4gSG9wZWZ1bGx5IGEgc3RyaW5nIHRoYXQgd29uJ3QgZXhpc3QgaW4gdGhlIGZvcm1hdFxuICAgIHZhciBuZXdGb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsaXRlcmFsLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgIGxpdGVyYWxzLnB1c2gocmVnZXhFc2NhcGUoJDEpKTtcbiAgICAgICAgcmV0dXJuIFwiQEBAXCI7XG4gICAgfSk7XG4gICAgdmFyIHNwZWNpZmllZEZpZWxkcyA9IHt9O1xuICAgIHZhciByZXF1aXJlZEZpZWxkcyA9IHt9O1xuICAgIC8vIENoYW5nZSBldmVyeSB0b2tlbiB0aGF0IHdlIGZpbmQgaW50byB0aGUgY29ycmVjdCByZWdleFxuICAgIG5ld0Zvcm1hdCA9IHJlZ2V4RXNjYXBlKG5ld0Zvcm1hdCkucmVwbGFjZSh0b2tlbiwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICAgIHZhciBpbmZvID0gcGFyc2VGbGFnc1skMF07XG4gICAgICAgIHZhciBmaWVsZCA9IGluZm9bMF0sIHJlZ2V4ID0gaW5mb1sxXSwgcmVxdWlyZWRGaWVsZCA9IGluZm9bM107XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBwZXJzb24gaGFzIHNwZWNpZmllZCB0aGUgc2FtZSBmaWVsZCB0d2ljZS4gVGhpcyB3aWxsIGxlYWQgdG8gY29uZnVzaW5nIHJlc3VsdHMuXG4gICAgICAgIGlmIChzcGVjaWZpZWRGaWVsZHNbZmllbGRdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZvcm1hdC4gXCIgKyBmaWVsZCArIFwiIHNwZWNpZmllZCB0d2ljZSBpbiBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3BlY2lmaWVkRmllbGRzW2ZpZWxkXSA9IHRydWU7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgcmVxdWlyZWQgZmllbGRzLiBGb3IgaW5zdGFuY2UsIDEyIGhvdXIgdGltZSByZXF1aXJlcyBBTS9QTSBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHJlcXVpcmVkRmllbGQpIHtcbiAgICAgICAgICAgIHJlcXVpcmVkRmllbGRzW3JlcXVpcmVkRmllbGRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZUluZm8ucHVzaChpbmZvKTtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgcmVnZXggKyBcIilcIjtcbiAgICB9KTtcbiAgICAvLyBDaGVjayBhbGwgdGhlIHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICAgIE9iamVjdC5rZXlzKHJlcXVpcmVkRmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoIXNwZWNpZmllZEZpZWxkc1tmaWVsZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZm9ybWF0LiBcIiArIGZpZWxkICsgXCIgaXMgcmVxdWlyZWQgaW4gc3BlY2lmaWVkIGZvcm1hdFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBiYWNrIGFsbCB0aGUgbGl0ZXJhbHMgYWZ0ZXJcbiAgICBuZXdGb3JtYXQgPSBuZXdGb3JtYXQucmVwbGFjZSgvQEBAL2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpdGVyYWxzLnNoaWZ0KCk7IH0pO1xuICAgIC8vIENoZWNrIGlmIHRoZSBkYXRlIHN0cmluZyBtYXRjaGVzIHRoZSBmb3JtYXQuIElmIGl0IGRvZXNuJ3QgcmV0dXJuIG51bGxcbiAgICB2YXIgbWF0Y2hlcyA9IGRhdGVTdHIubWF0Y2gobmV3IFJlZ0V4cChuZXdGb3JtYXQsIFwiaVwiKSk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgY29tYmluZWRJMThuU2V0dGluZ3MgPSBmZWNoYV9hc3NpZ24oZmVjaGFfYXNzaWduKHt9LCBnbG9iYWxJMThuKSwgaTE4bik7XG4gICAgLy8gRm9yIGVhY2ggbWF0Y2gsIGNhbGwgdGhlIHBhcnNlciBmdW5jdGlvbiBmb3IgdGhhdCBkYXRlIHBhcnRcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IG1hdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF9hID0gcGFyc2VJbmZvW2kgLSAxXSwgZmllbGQgPSBfYVswXSwgcGFyc2VyID0gX2FbMl07XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlclxuICAgICAgICAgICAgPyBwYXJzZXIobWF0Y2hlc1tpXSwgY29tYmluZWRJMThuU2V0dGluZ3MpXG4gICAgICAgICAgICA6ICttYXRjaGVzW2ldO1xuICAgICAgICAvLyBJZiB0aGUgcGFyc2VyIGNhbid0IG1ha2Ugc2Vuc2Ugb2YgdGhlIHZhbHVlLCByZXR1cm4gbnVsbFxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZGF0ZUluZm9bZmllbGRdID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChkYXRlSW5mby5pc1BtID09PSAxICYmIGRhdGVJbmZvLmhvdXIgIT0gbnVsbCAmJiArZGF0ZUluZm8uaG91ciAhPT0gMTIpIHtcbiAgICAgICAgZGF0ZUluZm8uaG91ciA9ICtkYXRlSW5mby5ob3VyICsgMTI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGVJbmZvLmlzUG0gPT09IDAgJiYgK2RhdGVJbmZvLmhvdXIgPT09IDEyKSB7XG4gICAgICAgIGRhdGVJbmZvLmhvdXIgPSAwO1xuICAgIH1cbiAgICB2YXIgZGF0ZVdpdGhvdXRUWiA9IG5ldyBEYXRlKGRhdGVJbmZvLnllYXIsIGRhdGVJbmZvLm1vbnRoLCBkYXRlSW5mby5kYXksIGRhdGVJbmZvLmhvdXIsIGRhdGVJbmZvLm1pbnV0ZSwgZGF0ZUluZm8uc2Vjb25kLCBkYXRlSW5mby5taWxsaXNlY29uZCk7XG4gICAgdmFyIHZhbGlkYXRlRmllbGRzID0gW1xuICAgICAgICBbXCJtb250aFwiLCBcImdldE1vbnRoXCJdLFxuICAgICAgICBbXCJkYXlcIiwgXCJnZXREYXRlXCJdLFxuICAgICAgICBbXCJob3VyXCIsIFwiZ2V0SG91cnNcIl0sXG4gICAgICAgIFtcIm1pbnV0ZVwiLCBcImdldE1pbnV0ZXNcIl0sXG4gICAgICAgIFtcInNlY29uZFwiLCBcImdldFNlY29uZHNcIl1cbiAgICBdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWxpZGF0ZUZpZWxkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhlIGRhdGUgZmllbGQgaXMgd2l0aGluIHRoZSBhbGxvd2VkIHJhbmdlLiBKYXZhc2NyaXB0IGRhdGVzIGFsbG93cyB2YWx1ZXNcbiAgICAgICAgLy8gb3V0c2lkZSB0aGUgYWxsb3dlZCByYW5nZS4gSWYgdGhlIHZhbHVlcyBkb24ndCBtYXRjaCB0aGUgdmFsdWUgd2FzIGludmFsaWRcbiAgICAgICAgaWYgKHNwZWNpZmllZEZpZWxkc1t2YWxpZGF0ZUZpZWxkc1tpXVswXV0gJiZcbiAgICAgICAgICAgIGRhdGVJbmZvW3ZhbGlkYXRlRmllbGRzW2ldWzBdXSAhPT0gZGF0ZVdpdGhvdXRUWlt2YWxpZGF0ZUZpZWxkc1tpXVsxXV0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRhdGVJbmZvLnRpbWV6b25lT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRhdGVXaXRob3V0VFo7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkYXRlSW5mby55ZWFyLCBkYXRlSW5mby5tb250aCwgZGF0ZUluZm8uZGF5LCBkYXRlSW5mby5ob3VyLCBkYXRlSW5mby5taW51dGUgLSBkYXRlSW5mby50aW1lem9uZU9mZnNldCwgZGF0ZUluZm8uc2Vjb25kLCBkYXRlSW5mby5taWxsaXNlY29uZCkpO1xufVxudmFyIGZlY2hhID0ge1xuICAgIGZvcm1hdDogZmVjaGFfZm9ybWF0LFxuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBkZWZhdWx0STE4bjogZGVmYXVsdEkxOG4sXG4gICAgc2V0R2xvYmFsRGF0ZUkxOG46IHNldEdsb2JhbERhdGVJMThuLFxuICAgIHNldEdsb2JhbERhdGVNYXNrczogc2V0R2xvYmFsRGF0ZU1hc2tzXG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsaWJfZmVjaGEgPSAoZmVjaGEpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWNoYS5qcy5tYXBcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI1NTMyZTQxMC12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9Nb250aC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzczN2RmZDQmXG52YXIgTW9udGh2dWVfdHlwZV90ZW1wbGF0ZV9pZF83NzM3ZGZkNF9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtyZWY6XCJkYXRlcGlja2VyTW9udGhcIixzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fbW9udGhcIixjbGFzczp7ICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLS13aXRoLXdlZWstbnVtYmVycyc6IF92bS5zaG93V2Vla051bWJlcnMgfSxvbjp7XCJtb3VzZWVudGVyXCI6ZnVuY3Rpb24oJGV2ZW50KXtyZXR1cm4gX3ZtLmVudGVyTW9udGgoJGV2ZW50KX19fSxbX2MoJ3AnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtbmFtZVwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0ubW9udGhOYW1lKStcIiBcIildKSxfYygnd2Vlay1yb3cnLF92bS5fYih7fSwnd2Vlay1yb3cnLF92bS4kcHJvcHMsZmFsc2UpKSwoX3ZtLnNob3dXZWVrTnVtYmVycyk/X2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyX193ZWVrbnVtYmVyc1wifSxfdm0uX2woKF92bS53ZWVrTnVtYmVycyksZnVuY3Rpb24od2Vla051bWJlcixpbmRleFdOKXtyZXR1cm4gX2MoJ2Rpdicse2tleTooXCJ2aGRfX2RhdGVwaWNrZXJfX3dlZWtudW1iZXJfX1wiICsgd2Vla051bWJlciArIFwiLVwiICsgaW5kZXhXTiksc3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX3dlZWtudW1iZXJzX19udW1iZXJcIn0sW192bS5fdihcIiBcIitfdm0uX3Mod2Vla051bWJlcikrXCIgXCIpXSl9KSwwKTpfdm0uX2UoKSxfdm0uX2woKF92bS5tb250aC5kYXlzKSxmdW5jdGlvbihkYXksZGF5SW5kZXgpe3JldHVybiBfYygnZGl2Jyx7a2V5Oihfdm0uZGF5S2V5ICsgXCItXCIgKyBkYXlJbmRleCksc3RhdGljQ2xhc3M6XCJ2aGRfX3NxdWFyZVwiLG9uOntcIm1vdXNlZW50ZXJcIjpmdW5jdGlvbigkZXZlbnQpe3JldHVybiBfdm0uZW50ZXJEYXkoJGV2ZW50LCBkYXkpfX19LFtfYygnRGF5Jyxfdm0uX2Ioe2F0dHJzOntcImJlbG9uZ3NUb1RoaXNNb250aFwiOmRheS5iZWxvbmdzVG9UaGlzTW9udGgsXCJkYXRlXCI6ZGF5LmRhdGV9LG9uOntcImNsZWFyLXNlbGVjdGlvblwiOl92bS5jbGVhclNlbGVjdGlvbixcImJvb2tpbmctY2xpY2tlZFwiOl92bS5oYW5kbGVCb29raW5nQ2xpY2tlZCxcImRheS1jbGlja2VkXCI6X3ZtLmhhbmRsZURheUNsaWNrfX0sJ0RheScsX3ZtLiRwcm9wcyxmYWxzZSkpXSwxKX0pXSwyKX1cbnZhciBNb250aHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzc3MzdkZmQ0X3N0YXRpY1JlbmRlckZucyA9IFtdXG5cblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL01vbnRoLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03NzM3ZGZkNCZcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLmpzXG52YXIgZXNfc3RyaW5nX3RyaW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjEzNVwiKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI1NTMyZTQxMC12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9EYXkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBiMTM0ODcyJlxudmFyIERheXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzBiMTM0ODcyX3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2RpdicsWyhfdm0uc2hvd1Rvb2x0aXAgJiYgX3ZtLm9wdGlvbnMuaG92ZXJpbmdUb29sdGlwKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX3Rvb2x0aXBcIixkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoX3ZtLnRvb2x0aXBNZXNzYWdlRGlzcGxheSl9fSk6X3ZtLl9lKCksX2MoJ2Rpdicse3JlZjpcImRheVwiLHN0YXRpY0NsYXNzOlwidmhkX19kYXRlcGlja2VyX19tb250aC1kYXlcIixjbGFzczpbXG4gICAgICBfdm0uZGF5Q2xhc3MsXG4gICAgICBfdm0uZGlzYWJsZWRDbGFzcyxcbiAgICAgIF92bS5jaGVja2luQ2hlY2tvdXRDbGFzcyxcbiAgICAgIF92bS5ib29raW5nQ2xhc3MsXG4gICAgICB7ICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tdG9kYXknOiBfdm0uaXNUb2RheSB9IF0sYXR0cnM6e1widGFiaW5kZXhcIjpfdm0udGFiSW5kZXh9LG9uOntcImNsaWNrXCI6ZnVuY3Rpb24oJGV2ZW50KXskZXZlbnQucHJldmVudERlZmF1bHQoKTskZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7cmV0dXJuIF92bS5kYXlDbGlja2VkKCRldmVudCwgX3ZtLmRhdGUpfX19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS13cmFwcGVyXCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiZGF5XCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5kYXlOdW1iZXIpKV0pLF9jKCdQcmljZScse2F0dHJzOntcInNob3dcIjpfdm0uc2hvd1ByaWNlLFwicHJpY2VcIjpfdm0uZGF5UHJpY2UsXCJzeW1ib2xcIjpfdm0ucHJpY2VTeW1ib2x9fSldLDEpXSksKF92bS5jdXJyZW50Qm9va2luZyAmJiBfdm0uYmVsb25nc1RvVGhpc01vbnRoICYmICFfdm0uaXNEaXNhYmxlZCk/X2MoJ0Jvb2tpbmdCdWxsZXQnLHthdHRyczp7XCJjdXJyZW50Qm9va2luZ1wiOl92bS5jdXJyZW50Qm9va2luZyxcImR1cGxpY2F0ZUJvb2tpbmdEYXRlc1wiOl92bS5kdXBsaWNhdGVCb29raW5nRGF0ZXMsXCJmb3JtYXREYXRlXCI6X3ZtLmZvcm1hdERhdGUsXCJwcmV2aW91c0Jvb2tpbmdcIjpfdm0ucHJldmlvdXNCb29raW5nfX0pOl92bS5fZSgpXSwxKX1cbnZhciBEYXl2dWVfdHlwZV90ZW1wbGF0ZV9pZF8wYjEzNDg3Ml9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9EYXkudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBiMTM0ODcyJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvcmUtanNAMy4xNS4yL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLW5hbi5qc1xudmFyIGVzX251bWJlcl9pc19uYW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDFlZFwiKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jb3JlLWpzQDMuMTUuMi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZC5qc1xudmFyIGVzX251bWJlcl90b19maXhlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiYTgzXCIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9oZWxwZXJzLmpzXG5cblxuXG5cblxuLyogZXNsaW50LWRpc2FibGUgdmFycy1vbi10b3AgKi9cblxudmFyIGhlbHBlcnMgPSB7XG4gIGdldE5leHREYXRlOiBmdW5jdGlvbiBnZXROZXh0RGF0ZShkYXRlc0FycmF5LCByZWZlcmVuY2VEYXRlKSB7XG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKHJlZmVyZW5jZURhdGUpO1xuICAgIHZhciBjbG9zZXN0ID0gSW5maW5pdHk7XG4gICAgZGF0ZXNBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGQpO1xuXG4gICAgICBpZiAoZGF0ZSA+PSBub3cgJiYgZGF0ZSA8IGNsb3Nlc3QpIHtcbiAgICAgICAgY2xvc2VzdCA9IGQ7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY2xvc2VzdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9zZXN0O1xuICB9LFxuICBuZXh0RGF0ZUJ5RGF5T2ZXZWVrOiBmdW5jdGlvbiBuZXh0RGF0ZUJ5RGF5T2ZXZWVrKHdlZWtEYXksIHJlZmVyZW5jZURhdGUsIGkxOG4pIHtcbiAgICB2YXIgbmV3UmVmZXJlbmNlRGF0ZSA9IG5ldyBEYXRlKHJlZmVyZW5jZURhdGUpO1xuICAgIHZhciBuZXdXZWVrRGF5ID0gd2Vla0RheS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBkYXlzRGVmYXVsdCA9IFsnc3VuZGF5JywgJ21vbmRheScsICd0dWVzZGF5JywgJ3dlZG5lc2RheScsICd0aHVyc2RheScsICdmcmlkYXknLCAnc2F0dXJkYXknXTtcbiAgICB2YXIgZGF5cyA9IGkxOG4gPyBpMThuWydkYXktbmFtZXMnXSA6IGRheXNEZWZhdWx0O1xuICAgIHZhciByZWZlcmVuY2VEYXRlRGF5ID0gbmV3UmVmZXJlbmNlRGF0ZS5nZXREYXkoKTtcblxuICAgIGZvciAodmFyIGkgPSA3OzsgaS0tKSB7XG4gICAgICBpZiAobmV3V2Vla0RheSA9PT0gZGF5c1tpXSkge1xuICAgICAgICBuZXdXZWVrRGF5ID0gaSA8PSByZWZlcmVuY2VEYXRlRGF5ID8gaSArIDcgOiBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGF5c1VudGlsTmV4dCA9IG5ld1dlZWtEYXkgLSByZWZlcmVuY2VEYXRlRGF5O1xuICAgIHJldHVybiBuZXdSZWZlcmVuY2VEYXRlLnNldERhdGUobmV3UmVmZXJlbmNlRGF0ZS5nZXREYXRlKCkgKyBkYXlzVW50aWxOZXh0KTtcbiAgfSxcbiAgbmV4dERhdGVCeURheU9mV2Vla0FycmF5OiBmdW5jdGlvbiBuZXh0RGF0ZUJ5RGF5T2ZXZWVrQXJyYXkoZGF5c0FycmF5LCByZWZlcmVuY2VEYXRlLCBpMThuKSB7XG4gICAgdmFyIHRlbXBBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXlzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRlbXBBcnJheS5wdXNoKG5ldyBEYXRlKHRoaXMubmV4dERhdGVCeURheU9mV2VlayhkYXlzQXJyYXlbaV0sIHJlZmVyZW5jZURhdGUsIGkxOG4pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0TmV4dERhdGUodGVtcEFycmF5LCByZWZlcmVuY2VEYXRlKTtcbiAgfSxcbiAgbmV4dERhdGVCeURheU9mV2Vla09iamVjdDogZnVuY3Rpb24gbmV4dERhdGVCeURheU9mV2Vla09iamVjdChkYXlzLCByZWZlcmVuY2VEYXRlLCBpMThuKSB7XG4gICAgdmFyIGRheXNBcnJheSA9IE9iamVjdC5lbnRyaWVzKGRheXMpLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGVbMV0gPyBlWzBdIDogZmFsc2U7XG4gICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5uZXh0RGF0ZUJ5RGF5T2ZXZWVrQXJyYXkoZGF5c0FycmF5LCByZWZlcmVuY2VEYXRlLCBpMThuKTtcbiAgfSxcbiAgY291bnREYXlzOiBmdW5jdGlvbiBjb3VudERheXMoc3RhcnQsIGVuZCkge1xuICAgIHZhciBvbmVEYXkgPSAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgIHZhciBmaXJzdERhdGUgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgdmFyIHNlY29uZERhdGUgPSBuZXcgRGF0ZShlbmQpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKE1hdGguYWJzKChmaXJzdERhdGUuZ2V0VGltZSgpIC0gc2Vjb25kRGF0ZS5nZXRUaW1lKCkpIC8gb25lRGF5KSk7XG4gIH0sXG4gIGFkZERheXM6IGZ1bmN0aW9uIGFkZERheXMoZGF0ZSwgcXVhbnRpdHkpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgcmVzdWx0LnNldERhdGUocmVzdWx0LmdldERhdGUoKSArIHF1YW50aXR5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBnZXREYXlEaWZmOiBmdW5jdGlvbiBnZXREYXlEaWZmKGQxLCBkMikge1xuICAgIHZhciB0MiA9IG5ldyBEYXRlKGQyKS5nZXRUaW1lKCk7XG4gICAgdmFyIHQxID0gbmV3IERhdGUoZDEpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gcGFyc2VJbnQoKHQyIC0gdDEpIC8gKDI0ICogMzYwMCAqIDEwMDApLCAxMCk7XG4gIH0sXG4gIGdldEZpcnN0RGF5OiBmdW5jdGlvbiBnZXRGaXJzdERheShkYXRlLCBmaXJzdERheU9mV2Vlaykge1xuICAgIHZhciBmaXJzdERheSA9IHRoaXMuZ2V0Rmlyc3REYXlPZk1vbnRoKGRhdGUpO1xuICAgIHZhciBkYXkgPSBmaXJzdERheS5nZXREYXkoKTtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChmaXJzdERheU9mV2VlayA+IDApIHtcbiAgICAgIG9mZnNldCA9ICFkYXkgPyAtNiA6IGZpcnN0RGF5T2ZXZWVrO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZShmaXJzdERheS5zZXREYXRlKGZpcnN0RGF5LmdldERhdGUoKSAtIChkYXkgLSBvZmZzZXQpKSk7XG4gIH0sXG4gIGdldEZpcnN0RGF5T2ZNb250aDogZnVuY3Rpb24gZ2V0Rmlyc3REYXlPZk1vbnRoKGRhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEsIDAsIDAsIDAsIDApO1xuICB9LFxuICBnZXROZXh0TW9udGg6IGZ1bmN0aW9uIGdldE5leHRNb250aChkYXRlKSB7XG4gICAgdmFyIG5leHRNb250aDtcblxuICAgIGlmIChkYXRlLmdldE1vbnRoKCkgPT09IDExKSB7XG4gICAgICBuZXh0TW9udGggPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCkgKyAxLCAwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dE1vbnRoID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dE1vbnRoO1xuICB9LFxuICBnZXRQcmV2aW91c01vbnRoOiBmdW5jdGlvbiBnZXRQcmV2aW91c01vbnRoKGRhdGUpIHtcbiAgICB2YXIgcHJldk1vbnRoO1xuXG4gICAgaWYgKGRhdGUuZ2V0TW9udGgoKSA9PT0gMCkge1xuICAgICAgcHJldk1vbnRoID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpIC0gMSwgMTEsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2TW9udGggPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSAtIDEsIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2TW9udGg7XG4gIH0sXG4gIGhhbmRsZVRvdWNoU3RhcnQ6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnQoZXZ0KSB7XG4gICAgdGhpcy5pc1RvdWNoTW92ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICB0aGlzLnhEb3duID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIHRoaXMueURvd24gPSBldnQudG91Y2hlc1swXS5jbGllbnRZO1xuICAgIH1cbiAgfSxcbiAgaGFuZGxlVG91Y2hNb3ZlOiBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLnhEb3duIHx8ICF0aGlzLnlEb3duKSB7XG4gICAgICB0aGlzLmlzVG91Y2hNb3ZlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1RvdWNoTW92ZSA9IHRydWU7XG4gICAgdGhpcy54VXAgPSBldnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgIHRoaXMueVVwID0gZXZ0LnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgfSxcbiAgaGFuZGxlVG91Y2hFbmQ6IGZ1bmN0aW9uIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIGlmICghdGhpcy5pc1RvdWNoTW92ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy54RG93biB8fCAhdGhpcy55RG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4RGlmZiA9IHRoaXMueERvd24gLSB0aGlzLnhVcDtcbiAgICB2YXIgeURpZmYgPSB0aGlzLnlEb3duIC0gdGhpcy55VXA7XG5cbiAgICBpZiAoTWF0aC5hYnMoeERpZmYpIDwgTWF0aC5hYnMoeURpZmYpICYmIHlEaWZmID4gMCAmJiAhdGhpcy5pc1ByZXZlbnRlZE1heE1vbnRoKSB7XG4gICAgICB0aGlzLnJlbmRlck5leHRNb250aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclByZXZpb3VzTW9udGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLnhEb3duID0gbnVsbDtcbiAgICB0aGlzLnlEb3duID0gbnVsbDtcbiAgfSxcbiAgdmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzOiBmdW5jdGlvbiB2YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXMoZnJvbURhdGUsIHRvRGF0ZSwgZ2l2ZW5EYXRlKSB7XG4gICAgdmFyIGdldHZhbGlkRGF0ZSA9IGZ1bmN0aW9uIGdldHZhbGlkRGF0ZShkKSB7XG4gICAgICB2YXIgZm9ybWF0RGF0ZUF0MDAgPSBuZXcgRGF0ZShkKS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShmb3JtYXREYXRlQXQwMCk7XG4gICAgfTtcblxuICAgIHJldHVybiBnZXR2YWxpZERhdGUoZ2l2ZW5EYXRlKSA8PSBnZXR2YWxpZERhdGUodG9EYXRlKSAmJiBnZXR2YWxpZERhdGUoZ2l2ZW5EYXRlKSA+PSBnZXR2YWxpZERhdGUoZnJvbURhdGUpO1xuICB9LFxuICB2YWxpZGF0ZURhdGVCZXR3ZWVuRGF0ZTogZnVuY3Rpb24gdmFsaWRhdGVEYXRlQmV0d2VlbkRhdGUoZnJvbURhdGUsIGdpdmVuRGF0ZSkge1xuICAgIHZhciBnZXR2YWxpZERhdGUgPSBmdW5jdGlvbiBnZXR2YWxpZERhdGUoZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZ2V0dmFsaWREYXRlKGdpdmVuRGF0ZSkgPD0gZ2V0dmFsaWREYXRlKGZyb21EYXRlKTtcbiAgfSxcbiAgZ2V0TW9udGhEaWZmOiBmdW5jdGlvbiBnZXRNb250aERpZmYoZDEsIGQyKSB7XG4gICAgdmFyIG5ld0QxID0gbmV3IERhdGUoZDEpO1xuICAgIHZhciBuZXdEMiA9IG5ldyBEYXRlKGQyKTtcbiAgICB2YXIgZDFZID0gbmV3RDEuZ2V0RnVsbFllYXIoKTtcbiAgICB2YXIgZDJZID0gbmV3RDIuZ2V0RnVsbFllYXIoKTtcbiAgICB2YXIgZDFNID0gbmV3RDEuZ2V0TW9udGgoKTtcbiAgICB2YXIgZDJNID0gbmV3RDIuZ2V0TW9udGgoKTtcbiAgICByZXR1cm4gZDJNICsgMTIgKiBkMlkgLSAoZDFNICsgMTIgKiBkMVkpO1xuICB9LFxuICBzaG9ydGVuU3RyaW5nOiBmdW5jdGlvbiBzaG9ydGVuU3RyaW5nKGFyciwgc0xlbikge1xuICAgIHZhciBuZXdBcnIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5ld0Fyci5wdXNoKGFycltpXS5zdWJzdHIoMCwgc0xlbikpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdBcnI7XG4gIH0sXG4gIGdldERheXNBcnJheTogZnVuY3Rpb24gZ2V0RGF5c0FycmF5KHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyXG4gICAgdmFyIGFyciA9IFtdLCBkdCA9IG5ldyBEYXRlKHN0YXJ0KTsgZHQgPD0gZW5kOyBkdC5zZXREYXRlKGR0LmdldERhdGUoKSArIDEpKSB7XG4gICAgICBhcnIucHVzaChuZXcgRGF0ZShkdCkpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJsb2NrLXNjb3BlZC12YXJcblxuXG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgZGF0ZUZvcm1hdGVyOiBmdW5jdGlvbiBkYXRlRm9ybWF0ZXIoZGF0ZSwgZm9ybWF0KSB7XG4gICAgdmFyIGYgPSBmb3JtYXQgfHwgJ1lZWVktTU0tREQnO1xuXG4gICAgaWYgKGRhdGUpIHtcbiAgICAgIHJldHVybiBsaWJfZmVjaGEuZm9ybWF0KGRhdGUsIGYpO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfSxcbiAgcGx1cmFsaXplOiBmdW5jdGlvbiBwbHVyYWxpemUoY291bnRPZkRheXMpIHtcbiAgICB2YXIgcGVyaW9kVHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ25pZ2h0JztcblxuICAgIGlmIChwZXJpb2RUeXBlID09PSAnd2VlaycpIHtcbiAgICAgIHJldHVybiBjb3VudE9mRGF5cyA+IDcgPyB0aGlzLmkxOG4ud2Vla3MgOiB0aGlzLmkxOG4ud2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4gY291bnRPZkRheXMgIT09IDEgPyB0aGlzLmkxOG4ubmlnaHRzIDogdGhpcy5pMThuLm5pZ2h0O1xuICB9LFxuICBpc0RhdGVMZXNzT3JFcXVhbHM6IGZ1bmN0aW9uIGlzRGF0ZUxlc3NPckVxdWFscyh0aW1lMSwgdGltZTIpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGltZTEpIDwgbmV3IERhdGUodGltZTIpO1xuICB9LFxuICBjb21wYXJlRGF5OiBmdW5jdGlvbiBjb21wYXJlRGF5KGRheTEsIGRheTIpIHtcbiAgICB2YXIgZGF0ZTEgPSBsaWJfZmVjaGEuZm9ybWF0KG5ldyBEYXRlKGRheTEpLCAnWVlZWU1NREQnKTtcbiAgICB2YXIgZGF0ZTIgPSBsaWJfZmVjaGEuZm9ybWF0KG5ldyBEYXRlKGRheTIpLCAnWVlZWU1NREQnKTtcblxuICAgIGlmIChkYXRlMSA+IGRhdGUyKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZTEgPT09IGRhdGUyKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBpZiAoZGF0ZTEgPCBkYXRlMikge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBnZXRJc29XZWVrOiBmdW5jdGlvbiBnZXRJc29XZWVrKHRlc3REYXRlKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0ZXN0RGF0ZSk7XG4gICAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTsgLy8gVGh1cnNkYXkgaW4gY3VycmVudCB3ZWVrIGRlY2lkZXMgdGhlIHllYXIuXG5cbiAgICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgKyAzIC0gKGRhdGUuZ2V0RGF5KCkgKyA2KSAlIDcpOyAvLyBKYW51YXJ5IDQgaXMgYWx3YXlzIGluIHdlZWsgMS5cblxuICAgIHZhciB3ZWVrMSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgNCk7IC8vIEFkanVzdCB0byBUaHVyc2RheSBpbiB3ZWVrIDEgYW5kIGNvdW50IG51bWJlciBvZiB3ZWVrcyBmcm9tIGRhdGUgdG8gd2VlazEuXG5cbiAgICByZXR1cm4gMSArIE1hdGgucm91bmQoKChkYXRlLmdldFRpbWUoKSAtIHdlZWsxLmdldFRpbWUoKSkgLyA4NjQwMDAwMCAtIDMgKyAod2VlazEuZ2V0RGF5KCkgKyA2KSAlIDcpIC8gNyk7XG4gIH1cbn07XG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfaGVscGVycyA9IChoZWxwZXJzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcIixcImNhY2hlSWRlbnRpZmllclwiOlwiNTUzMmU0MTAtdnVlLWxvYWRlci10ZW1wbGF0ZVwifSEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvQm9va2luZ0J1bGxldC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NzNlMTUzZDkmXG52YXIgQm9va2luZ0J1bGxldHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzczZTE1M2Q5X3JlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2knLHtzdGF0aWNDbGFzczpcInZoZF9fcGFyZW50LWJ1bGxldFwifSxbKF92bS5wcmV2aW91c0Jvb2tpbmcgJiYgX3ZtLmR1cGxpY2F0ZUJvb2tpbmdEYXRlcy5pbmNsdWRlcyhfdm0uZm9ybWF0RGF0ZSkpP19jKCdpJyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2J1bGxldFwiLGNsYXNzOltcbiAgICAgIHtcbiAgICAgICAgdmhkX19jaGVja0luQ2hlY2tPdXQ6IF92bS5kdXBsaWNhdGVCb29raW5nRGF0ZXMuaW5jbHVkZXMoX3ZtLmZvcm1hdERhdGUpLFxuICAgICAgfSBdLHN0eWxlOihfdm0ucHJldmlvdXNCb29raW5nLnN0eWxlKX0pOl92bS5fZSgpLChfdm0ucHJldmlvdXNCb29raW5nICYmIF92bS5kdXBsaWNhdGVCb29raW5nRGF0ZXMuaW5jbHVkZXMoX3ZtLmZvcm1hdERhdGUpKT9fYygnaScse3N0YXRpY0NsYXNzOlwidmhkX19waXBlIHZoZF9fY2hlY2tJbkNoZWNrT3V0XCIsc3R5bGU6KF92bS5wcmV2aW91c0Jvb2tpbmcuc3R5bGUpfSk6X3ZtLl9lKCksKF92bS5jdXJyZW50Qm9va2luZyAmJiAoX3ZtLmN1cnJlbnRCb29raW5nLmNoZWNrSW5EYXRlID09PSBfdm0uZm9ybWF0RGF0ZSB8fCBfdm0uY3VycmVudEJvb2tpbmcuY2hlY2tPdXREYXRlID09PSBfdm0uZm9ybWF0RGF0ZSkpP19jKCdpJyx7c3RhdGljQ2xhc3M6XCJ2aGRfX2J1bGxldFwiLGNsYXNzOltcbiAgICAgIHtcbiAgICAgICAgdmhkX19jaGVja0luOiBfdm0uY3VycmVudEJvb2tpbmcuY2hlY2tJbkRhdGUgPT09IF92bS5mb3JtYXREYXRlLFxuICAgICAgICB2aGRfX2NoZWNrT3V0OiBfdm0uY3VycmVudEJvb2tpbmcuY2hlY2tPdXREYXRlID09PSBfdm0uZm9ybWF0RGF0ZSxcbiAgICAgIH0gXSxzdHlsZTooX3ZtLmN1cnJlbnRCb29raW5nLnN0eWxlKX0pOl92bS5fZSgpLChfdm0uY3VycmVudEJvb2tpbmcpP19jKCdpJyx7c3RhdGljQ2xhc3M6XCJ2aGRfX3BpcGVcIixjbGFzczpbXG4gICAgICB7XG4gICAgICAgIHZoZF9fY2hlY2tJbjogX3ZtLmN1cnJlbnRCb29raW5nLmNoZWNrSW5EYXRlID09PSBfdm0uZm9ybWF0RGF0ZSxcbiAgICAgICAgdmhkX19jaGVja091dDogX3ZtLmN1cnJlbnRCb29raW5nLmNoZWNrT3V0RGF0ZSA9PT0gX3ZtLmZvcm1hdERhdGUsXG4gICAgICB9IF0sc3R5bGU6KF92bS5jdXJyZW50Qm9va2luZy5zdHlsZSl9KTpfdm0uX2UoKV0pfVxudmFyIEJvb2tpbmdCdWxsZXR2dWVfdHlwZV90ZW1wbGF0ZV9pZF83M2UxNTNkOV9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9Cb29raW5nQnVsbGV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD03M2UxNTNkOSZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWQtbG9hZGVyQDIuMS4zX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2JhYmVsLWxvYWRlckA4LjIuMl80NGNkOGU4OTg4ZThmNmJkZjQwNThjMzUyZDRlNzJkZC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL0Jvb2tpbmdCdWxsZXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgQm9va2luZ0J1bGxldHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdCb29raW5nQnVsbGV0JyxcbiAgcHJvcHM6IHtcbiAgICBjdXJyZW50Qm9va2luZzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGR1cGxpY2F0ZUJvb2tpbmdEYXRlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0RGF0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHByZXZpb3VzQm9va2luZzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL0Jvb2tpbmdCdWxsZXQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfQm9va2luZ0J1bGxldHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChCb29raW5nQnVsbGV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgKG9wdGlvbnMuZnVuY3Rpb25hbCA/IHRoaXMucGFyZW50IDogdGhpcykuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdFxuICAgICAgICApXG4gICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvQm9va2luZ0J1bGxldC52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfQm9va2luZ0J1bGxldHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgQm9va2luZ0J1bGxldHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzczZTE1M2Q5X3JlbmRlcixcbiAgQm9va2luZ0J1bGxldHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzczZTE1M2Q5X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIEJvb2tpbmdCdWxsZXQgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/e1wiY2FjaGVEaXJlY3RvcnlcIjpcIm5vZGVfbW9kdWxlcy8uY2FjaGUvdnVlLWxvYWRlclwiLFwiY2FjaGVJZGVudGlmaWVyXCI6XCI1NTMyZTQxMC12dWUtbG9hZGVyLXRlbXBsYXRlXCJ9IS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3Z1ZS1sb2FkZXJAMTUuOS43XzY3OTM1OWNkYjY5YzIxOGYyZjhmNDc2YjJiYTA4Nzk2L25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9QcmljZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9Mjk5ODMxNWUmXG52YXIgUHJpY2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yOTk4MzE1ZV9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIChfdm0uc2hvdyAmJiBfdm0ucHJpY2UpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInByaWNlXCJ9LFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwicHJpY2Utc3ltYm9sXCJ9LFtfdm0uX3YoX3ZtLl9zKF92bS5zeW1ib2wpKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJwcmljZS1udW1iZXJcIn0sW192bS5fdihfdm0uX3MoX3ZtLnByaWNlKSldKV0pOl92bS5fZSgpfVxudmFyIFByaWNldnVlX3R5cGVfdGVtcGxhdGVfaWRfMjk5ODMxNWVfc3RhdGljUmVuZGVyRm5zID0gW11cblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvUHJpY2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI5OTgzMTVlJlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZC1sb2FkZXJAMi4xLjNfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvLnBucG0vYmFiZWwtbG9hZGVyQDguMi4yXzQ0Y2Q4ZTg5ODhlOGY2YmRmNDA1OGMzNTJkNGU3MmRkL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvUHJpY2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFByaWNldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1ByaWNlJyxcbiAgcHJvcHM6IHtcbiAgICBzaG93OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHByaWNlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgc3ltYm9sOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBudWxsLCB1bmRlZmluZWRdLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL1ByaWNlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX1ByaWNldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKFByaWNldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvUHJpY2UudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgUHJpY2VfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBjb21wb25lbnRzX1ByaWNldnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBQcmljZXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzI5OTgzMTVlX3JlbmRlcixcbiAgUHJpY2V2dWVfdHlwZV90ZW1wbGF0ZV9pZF8yOTk4MzE1ZV9zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBQcmljZSA9IChQcmljZV9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZC1sb2FkZXJAMi4xLjNfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvLnBucG0vYmFiZWwtbG9hZGVyQDguMi4yXzQ0Y2Q4ZTg5ODhlOGY2YmRmNDA1OGMzNTJkNGU3MmRkL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvRGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgRGF5dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0RheScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBCb29raW5nQnVsbGV0OiBCb29raW5nQnVsbGV0LFxuICAgIFByaWNlOiBQcmljZVxuICB9LFxuICBwcm9wczoge1xuICAgIGJvb2tpbmdzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBhY3RpdmVNb250aEluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIGJlbG9uZ3NUb1RoaXNNb250aDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBjaGVja0luOiB7XG4gICAgICB0eXBlOiBEYXRlXG4gICAgfSxcbiAgICBjaGVja0luY2hlY2tPdXRIYWxmRGF5OiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY2hlY2tJblBlcmlvZDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNoZWNrT3V0OiB7XG4gICAgICB0eXBlOiBEYXRlXG4gICAgfSxcbiAgICBkYXRlOiB7XG4gICAgICB0eXBlOiBEYXRlXG4gICAgfSxcbiAgICBkaXNhYmxlQ2hlY2tvdXRPbkNoZWNraW46IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgZHVwbGljYXRlQm9va2luZ0RhdGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBob3ZlcmluZ0RhdGU6IHtcbiAgICAgIHR5cGU6IERhdGVcbiAgICB9LFxuICAgIGhvdmVyaW5nUGVyaW9kOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgaG92ZXJpbmdUb29sdGlwOiB7XG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgaTE4bjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzT3Blbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBtaW5OaWdodENvdW50OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBuZXh0RGlzYWJsZWREYXRlOiB7XG4gICAgICB0eXBlOiBbRGF0ZSwgTnVtYmVyLCBTdHJpbmddXG4gICAgfSxcbiAgICBuZXh0UGVyaW9kRGlzYWJsZURhdGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuICAgIHByaWNlU3ltYm9sOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgcHJpY2VEZWNpbWFsczoge1xuICAgICAgdHlwZTogW051bWJlciwgbnVsbF0sXG4gICAgICBkZWZhdWx0OiAwXG4gICAgfSxcbiAgICBzY3JlZW5TaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnJ1xuICAgIH0sXG4gICAgc2hvd0N1c3RvbVRvb2x0aXA6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG4gICAgc2hvd1ByaWNlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHNvcnRlZERpc2FibGVkRGF0ZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvcnRlZFBlcmlvZERhdGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwTWVzc2FnZToge1xuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudERhdGU6IG5ldyBEYXRlKCksXG4gICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgIGlzSGlnaGxpZ2h0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBwcmV2aW91c0Jvb2tpbmc6IGZ1bmN0aW9uIHByZXZpb3VzQm9va2luZygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBwcmV2aW91c0Jvb2tpbmcgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50Qm9va2luZyAmJiB0aGlzLmR1cGxpY2F0ZUJvb2tpbmdEYXRlcy5pbmNsdWRlcyh0aGlzLmN1cnJlbnRCb29raW5nLmNoZWNrSW5EYXRlKSkge1xuICAgICAgICBwcmV2aW91c0Jvb2tpbmcgPSB0aGlzLmJvb2tpbmdzLmZpbmQoZnVuY3Rpb24gKGJvb2tpbmcpIHtcbiAgICAgICAgICByZXR1cm4gYm9va2luZy5jaGVja091dERhdGUgPT09IF90aGlzLmZvcm1hdERhdGUgJiYgX3RoaXMuZHVwbGljYXRlQm9va2luZ0RhdGVzLmluY2x1ZGVzKGJvb2tpbmcuY2hlY2tPdXREYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c0Jvb2tpbmc7XG4gICAgfSxcbiAgICBjdXJyZW50Qm9va2luZzogZnVuY3Rpb24gY3VycmVudEJvb2tpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuYm9va2luZ3MuZmluZChmdW5jdGlvbiAoYm9va2luZykge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmR1cGxpY2F0ZUJvb2tpbmdEYXRlcy5pbmNsdWRlcyhfdGhpczIuZm9ybWF0RGF0ZSkgJiYgYm9va2luZy5jaGVja0luRGF0ZSA9PT0gX3RoaXMyLmZvcm1hdERhdGUgfHwgIV90aGlzMi5kdXBsaWNhdGVCb29raW5nRGF0ZXMuaW5jbHVkZXMoX3RoaXMyLmZvcm1hdERhdGUpICYmIF90aGlzMi52YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXMoYm9va2luZy5jaGVja0luRGF0ZSwgYm9va2luZy5jaGVja091dERhdGUsIF90aGlzMi5mb3JtYXREYXRlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGF5TnVtYmVyOiBmdW5jdGlvbiBkYXlOdW1iZXIoKSB7XG4gICAgICByZXR1cm4gbGliX2ZlY2hhLmZvcm1hdCh0aGlzLmRhdGUsICdEJyk7XG4gICAgfSxcbiAgICBkYXlQcmljZTogZnVuY3Rpb24gZGF5UHJpY2UoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gICAgICB2YXIgY3VycmVudERhdGUgPSBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5zb3J0ZWRQZXJpb2REYXRlcykucmV2ZXJzZSgpLmZpbmQoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy52YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXMoZC5zdGFydEF0LCBkLmVuZEF0LCBfdGhpczMuZm9ybWF0RGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGN1cnJlbnREYXRlICYmIGN1cnJlbnREYXRlLnByaWNlKSB7XG4gICAgICAgIHZhciBwcmljZUlzTnVtZXJpYyA9IHR5cGVvZiBjdXJyZW50RGF0ZS5wcmljZSA9PT0gJ251bWJlcicgfHwgIU51bWJlci5pc05hTihwYXJzZUZsb2F0KGN1cnJlbnREYXRlLnByaWNlKSk7XG4gICAgICAgIHZhciB3ZWVrbHlQZXJpb2QgPSBjdXJyZW50RGF0ZS5wZXJpb2RUeXBlICE9PSAnbmlnaHRseSc7XG5cbiAgICAgICAgaWYgKHByaWNlSXNOdW1lcmljICYmIHdlZWtseVBlcmlvZCkge1xuICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByaWNlIHdoZW4gd2Vla2x5IGFuZCBpcyBub3QgYSBmbG9hdC9pbnQgdHlwZVxuICAgICAgICAgIHZhciBwcmljZSA9IHBhcnNlRmxvYXQoY3VycmVudERhdGUucHJpY2UpO1xuICAgICAgICAgIHZhciBkaXZpc29yID0gNztcbiAgICAgICAgICB2YXIgZGVjaW1hbHMgPSBOdW1iZXIuaXNOYU4ocGFyc2VGbG9hdCh0aGlzLnByaWNlRGVjaW1hbHMpKSA/IDAgOiBwYXJzZUZsb2F0KHRoaXMucHJpY2VEZWNpbWFscyk7XG4gICAgICAgICAgcmVzdWx0ID0gKHByaWNlIC8gZGl2aXNvcikudG9GaXhlZChkZWNpbWFscyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gY3VycmVudERhdGUucHJpY2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFN0cmluZyhyZXN1bHQpO1xuICAgIH0sXG4gICAgaGFsZkRheUNsYXNzOiBmdW5jdGlvbiBoYWxmRGF5Q2xhc3MoKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBrZXlEYXRlID0gdGhpcy5kYXRlRm9ybWF0ZXIodGhpcy5kYXRlKTtcblxuICAgICAgICBpZiAodGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W2tleURhdGVdICYmIHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheVtrZXlEYXRlXS5jaGVja0luKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCkge1xuICAgICAgICAgICAgcmV0dXJuICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0taGFsZkNoZWNrSW4gdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLXZhbGlkJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1oYWxmQ2hlY2tJbiB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0taW52YWxpZCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W2tleURhdGVdICYmIHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheVtrZXlEYXRlXS5jaGVja091dCkge1xuICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWhhbGZDaGVja091dCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tdmFsaWQnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGJvb2tpbmdDbGFzczogZnVuY3Rpb24gYm9va2luZ0NsYXNzKCkge1xuICAgICAgaWYgKHRoaXMuYm9va2luZ3MubGVuZ3RoID4gMCAmJiB0aGlzLmN1cnJlbnRCb29raW5nKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkICYmIHRoaXMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKHRoaXMuY3VycmVudEJvb2tpbmcuY2hlY2tJbkRhdGUsIHRoaXMuY3VycmVudEJvb2tpbmcuY2hlY2tPdXREYXRlLCB0aGlzLmhvdmVyaW5nRGF0ZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W3RoaXMuZm9ybWF0RGF0ZV0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrSW4gJiYgIXRoaXMuY2hlY2tPdXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbm90LWFsbG93ZWQgdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWhvdmVyaW5nJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheVt0aGlzLmZvcm1hdERhdGVdLmNoZWNrT3V0KSB7XG4gICAgICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLW5vdC1hbGxvd2VkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ob3ZlcmluZyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLW5vdC1hbGxvd2VkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1pbnZhbGlkJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5jaGVja0luICYmICF0aGlzLmNoZWNrT3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0taW52YWxpZCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbm90LWFsbG93ZWQgdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWhvdmVyaW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXlbdGhpcy5mb3JtYXREYXRlXSAmJiB0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXlbdGhpcy5mb3JtYXREYXRlXS5jaGVja091dCAmJiAhdGhpcy5kdXBsaWNhdGVCb29raW5nRGF0ZXMuaW5jbHVkZXModGhpcy5mb3JtYXREYXRlKSkge1xuICAgICAgICAgIGlmICghdGhpcy5jaGVja0luKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0taG92ZXJpbmcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmNoZWNrSW4gJiYgdGhpcy5jaGVja0luID09PSB0aGlzLmRhdGUgfHwgdGhpcy5jaGVja0luICYmIHRoaXMuY2hlY2tPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLW5vdC1hbGxvd2VkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ob3ZlcmluZyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCAmJiB0aGlzLmhvdmVyaW5nRGF0ZSA9PT0gdGhpcy5kYXRlKSB7XG4gICAgICAgICAgcmV0dXJuICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbm90LWFsbG93ZWQgdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWhvdmVyaW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLW5vdC1hbGxvd2VkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1pbnZhbGlkJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG4gICAgZGlzYWJsZWRDbGFzczogZnVuY3Rpb24gZGlzYWJsZWRDbGFzcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGlzYWJsZWQgfHwgdGhpcy5pc0FEaXNhYmxlZERheSA/ICcgdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWRpc2FibGVkICcgOiAnJztcbiAgICB9LFxuICAgIGRheUNsYXNzOiBmdW5jdGlvbiBkYXlDbGFzcygpIHtcbiAgICAgIGlmICghdGhpcy5iZWxvbmdzVG9UaGlzTW9udGgpIHtcbiAgICAgICAgLy8gR29vZFxuICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1oaWRkZW4nO1xuICAgICAgfSAvLyBJZiB0aGUgY2FsZW5kYXIgaGFzIGEgbWluaW11bSBudW1iZXIgb2YgbmlnaHRzICYmICFjaGVja091dFxuXG5cbiAgICAgIHZhciBuZXh0VmFsaWREYXRlID0gdGhpcy5hZGREYXlzKHRoaXMuY2hlY2tJbiwgdGhpcy5taW5OaWdodENvdW50KTtcbiAgICAgIHZhciBpc0RhdGVBZnRlck1pbmltdW1EdXJhdGlvbiA9IHRoaXMuZ2V0RGF5RGlmZih0aGlzLmhvdmVyaW5nRGF0ZSwgbmV4dFZhbGlkRGF0ZSkgPD0gMDtcblxuICAgICAgaWYgKCFpc0RhdGVBZnRlck1pbmltdW1EdXJhdGlvbiAmJiAhdGhpcy5jaGVja091dCAmJiAhdGhpcy5pc0Rpc2FibGVkICYmIHRoaXMuY29tcGFyZURheSh0aGlzLmRhdGUsIHRoaXMuY2hlY2tJbikgPj0gMCAmJiB0aGlzLm1pbk5pZ2h0Q291bnQgPiAwICYmIHRoaXMuY29tcGFyZURheSh0aGlzLmRhdGUsIHRoaXMuYWRkRGF5cyh0aGlzLmNoZWNrSW4sIHRoaXMubWluTmlnaHRDb3VudCkpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS12YWxpZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tZGlzYWJsZWQgdmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLW5vdC1hbGxvd2VkIG1pbmltdW1EdXJhdGlvblVudmFsaWREYXknO1xuICAgICAgfSAvLyBDdXJyZW50IERheVxuXG5cbiAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkICYmIHRoaXMuZGF0ZSA9PT0gdGhpcy5ob3ZlcmluZ0RhdGUgJiYgdGhpcy5jaGVja0luICE9PSBudWxsICYmIHRoaXMuY2hlY2tPdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1zZWxlY3RlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0taG92ZXJpbmcgdmhkX19jdXJyZW50RGF5JztcbiAgICAgIH0gLy8gSGlnaGxpZ2h0IHRoZSBzZWxlY3RlZCBkYXRlcyBhbmQgcHJldmVudCB0aGUgdXNlciBmcm9tIHNlbGVjdGluZ1xuICAgICAgLy8gdGhlIHNhbWUgZGF0ZSBmb3IgY2hlY2tvdXQgYW5kIGNoZWNraW5cblxuXG4gICAgICBpZiAodGhpcy5jaGVja0luICE9PSBudWxsICYmIHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuY2hlY2tJbikgPT09IHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuZGF0ZSkpIHtcbiAgICAgICAgaWYgKHRoaXMubWluTmlnaHRDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWZpcnN0LWRheS1zZWxlY3RlZCBjaGVja0luJztcbiAgICAgICAgfSAvLyBHb29kXG5cblxuICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tZmlyc3QtZGF5LXNlbGVjdGVkIGNoZWNrSW4nO1xuICAgICAgfSAvLyBDaGVja291dCBkYXlcblxuXG4gICAgICBpZiAodGhpcy5jaGVja091dCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5kYXRlRm9ybWF0ZXIodGhpcy5jaGVja091dCkgPT09IHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuZGF0ZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5oYWxmRGF5Q2xhc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBcInZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbGFzdC1kYXktc2VsZWN0ZWQgXCIuY29uY2F0KHRoaXMuaGFsZkRheUNsYXNzLCBcIiBjaGVja091dFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbGFzdC1kYXktc2VsZWN0ZWQgY2hlY2tPdXQnO1xuICAgICAgICB9XG4gICAgICB9IC8vIE9ubHkgaGlnaGxpZ2h0IGRhdGVzIHRoYXQgYXJlIG5vdCBkaXNhYmxlZFxuXG5cbiAgICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0ZWQgJiYgIXRoaXMuaXNEaXNhYmxlZCkge1xuICAgICAgICB2YXIgY2xhc3NTZWxlY3RlZCA9ICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tc2VsZWN0ZWQnO1xuXG4gICAgICAgIGlmICh0aGlzLmlzQURpc2FibGVkRGF5KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNsYXNzU2VsZWN0ZWQsIFwiIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCBhZnRlck1pbmltdW1EdXJhdGlvblZhbGlkRGF5XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY2hlY2tJblBlcmlvZCkubGVuZ3RoID4gMCAmJiB0aGlzLmNoZWNrSW5QZXJpb2QucGVyaW9kVHlwZS5pbmNsdWRlcygnd2Vla2x5JykgJiYgdGhpcy5ob3ZlcmluZ0RhdGUgJiYgKHRoaXMuY2hlY2tJblBlcmlvZC5wZXJpb2RUeXBlID09PSAnd2Vla2x5X2J5X3NhdHVyZGF5JyAmJiB0aGlzLmhvdmVyaW5nRGF0ZS5nZXREYXkoKSA9PT0gNiB8fCB0aGlzLmNoZWNrSW5QZXJpb2QucGVyaW9kVHlwZSA9PT0gJ3dlZWtseV9ieV9zdW5kYXknICYmIHRoaXMuaG92ZXJpbmdEYXRlLmdldERheSgpID09PSAwKSAmJiB0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmRhdGUsIHRoaXMuaG92ZXJpbmdEYXRlKSkge1xuICAgICAgICAgIC8vIElmIGN1cnJlbnRQZXJpb2QgaGFzIGEgbWluaW11bUR1cmF0aW9uIDFcbiAgICAgICAgICBpZiAodGhpcy5jaGVja0luUGVyaW9kLm1pbmltdW1EdXJhdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGNsYXNzU2VsZWN0ZWQsIFwiIGFmdGVyTWluaW11bUR1cmF0aW9uVmFsaWREYXlcIik7XG4gICAgICAgICAgfSAvLyBJZiBjdXJyZW50UGVyaW9kIGhhcyBhIG1pbmltdW1EdXJhdGlvbiBzdXBlcmlvciB0byAxXG5cblxuICAgICAgICAgIGlmICh0aGlzLmdldERheURpZmYodGhpcy5ob3ZlcmluZ0RhdGUsIHRoaXMuY2hlY2tJblBlcmlvZC5uZXh0VmFsaWREYXRlKSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoY2xhc3NTZWxlY3RlZCwgXCIgYWZ0ZXJNaW5pbXVtRHVyYXRpb25WYWxpZERheVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5jaGVja0luUGVyaW9kKS5sZW5ndGggPiAwICYmIHRoaXMuY2hlY2tJblBlcmlvZC5wZXJpb2RUeXBlID09PSAnbmlnaHRseScgJiYgdGhpcy5ob3ZlcmluZ0RhdGUgJiYgdGhpcy5ob3ZlcmluZ1BlcmlvZC5wZXJpb2RUeXBlLmluY2x1ZGVzKCd3ZWVrbHknKSAmJiAodGhpcy5ob3ZlcmluZ1BlcmlvZC5wZXJpb2RUeXBlID09PSAnd2Vla2x5X2J5X3NhdHVyZGF5JyAmJiB0aGlzLmhvdmVyaW5nRGF0ZS5nZXREYXkoKSA9PT0gNiB8fCB0aGlzLmhvdmVyaW5nUGVyaW9kLnBlcmlvZFR5cGUgPT09ICd3ZWVrbHlfYnlfc3VuZGF5JyAmJiB0aGlzLmhvdmVyaW5nRGF0ZS5nZXREYXkoKSA9PT0gMCAmJiB0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmRhdGUsIHRoaXMuaG92ZXJpbmdEYXRlKSkpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoY2xhc3NTZWxlY3RlZCwgXCIgYWZ0ZXJNaW5pbXVtRHVyYXRpb25WYWxpZERheVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhvdmVyaW5nUGVyaW9kLnBlcmlvZFR5cGUgPT09ICduaWdodGx5JyAmJiB0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmRhdGUsIHRoaXMuaG92ZXJpbmdEYXRlKSkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjbGFzc1NlbGVjdGVkLCBcIiAgYWZ0ZXJNaW5pbXVtRHVyYXRpb25WYWxpZERheVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNoZWNrSW4gJiYgdGhpcy5jaGVja091dCkge1xuICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjbGFzc1NlbGVjdGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChjbGFzc1NlbGVjdGVkLCBcIiB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tdmFsaWRcIik7XG4gICAgICB9IC8vIEdvb2RcblxuXG4gICAgICBpZiAodGhpcy5pc0Rpc2FibGVkIHx8IHRoaXMuaXNBRGlzYWJsZWREYXkpIHtcbiAgICAgICAgcmV0dXJuICd2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tZGlzYWJsZWQnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYWxmRGF5Q2xhc3MpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHRoaXMuaGFsZkRheUNsYXNzKTtcbiAgICAgIH0gLy8gR29vZFxuXG5cbiAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLXZhbGlkJztcbiAgICB9LFxuICAgIGNoZWNraW5DaGVja291dENsYXNzOiBmdW5jdGlvbiBjaGVja2luQ2hlY2tvdXRDbGFzcygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgY3VycmVudFBlcmlvZCA9IG51bGw7XG4gICAgICB0aGlzLnNvcnRlZFBlcmlvZERhdGVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgaWYgKGQuZW5kQXQgIT09IF90aGlzNC5mb3JtYXREYXRlICYmIChkLnN0YXJ0QXQgPT09IF90aGlzNC5mb3JtYXREYXRlIHx8IF90aGlzNC52YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXMoZC5zdGFydEF0LCBkLmVuZEF0LCBfdGhpczQuZm9ybWF0RGF0ZSkpKSB7XG4gICAgICAgICAgY3VycmVudFBlcmlvZCA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5uZXh0UGVyaW9kRGlzYWJsZURhdGVzID8gdGhpcy5uZXh0UGVyaW9kRGlzYWJsZURhdGVzLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNC5jb21wYXJlRGF5KGksIF90aGlzNC5kYXRlKSA9PT0gMDtcbiAgICAgIH0pIDogbnVsbCkge1xuICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbm90LWFsbG93ZWQgbmlnaHRseSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kLnBlcmlvZFR5cGUgPT09ICduaWdodGx5JyAmJiB0aGlzLmJlbG9uZ3NUb1RoaXNNb250aCAmJiAhdGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgaWYgKCghdGhpcy5jaGVja0luICYmICF0aGlzLmNoZWNrT3V0IHx8IHRoaXMuY2hlY2tJbiAmJiB0aGlzLmNoZWNrT3V0KSAmJiB0aGlzLm5vdEFsbG93ZWREYXlEdWVUb05leHRQZXJpb2QoY3VycmVudFBlcmlvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWRpc2FibGVkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCBuaWdodGx5JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJ25pZ2h0bHknO1xuICAgICAgICB9IC8vIGRhdGUuZ2V0RGF5KCkgPT09IDYgPT4gc2F0dXJkYXlcblxuXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kLnBlcmlvZFR5cGUgPT09ICd3ZWVrbHlfYnlfc2F0dXJkYXknICYmIGN1cnJlbnRQZXJpb2Quc3RhcnRBdCAhPT0gdGhpcy5mb3JtYXREYXRlICYmIGN1cnJlbnRQZXJpb2QuZW5kQXQgIT09IHRoaXMuZm9ybWF0RGF0ZSAmJiB0aGlzLmRhdGUuZ2V0RGF5KCkgIT09IDYpIHtcbiAgICAgICAgICByZXR1cm4gJ3ZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1kaXNhYmxlZCB2aGRfX2RhdGVwaWNrZXJfX21vbnRoLWRheS0tbm90LWFsbG93ZWQgd2Vla2x5X2J5X3NhdHVyZGF5JztcbiAgICAgICAgfSAvLyBEaXNhYmxlIGRhdGUgYmV0d2VlbiBjaGVja0luIGFuZCBuZXh0RGF0ZSwgaWYgbWluaW11bUR1cmF0aW9uIGlzIHN1cGVyaW9yIHRvIDFcblxuXG4gICAgICAgIGlmICh0aGlzLm5vdEFsbG93RGF5c0JldHdlZW5DaGVja0luQW5kTmV4dFZhbGlkRGF0ZSg2KSkge1xuICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWRpc2FibGVkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCB3ZWVrbHlfYnlfc2F0dXJkYXknO1xuICAgICAgICB9IC8vIGRhdGUuZ2V0RGF5KCkgPT09IDAgPT4gc3VuZGF5XG5cblxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZC5wZXJpb2RUeXBlID09PSAnd2Vla2x5X2J5X3N1bmRheScgJiYgY3VycmVudFBlcmlvZC5zdGFydEF0ICE9PSB0aGlzLmZvcm1hdERhdGUgJiYgY3VycmVudFBlcmlvZC5lbmRBdCAhPT0gdGhpcy5mb3JtYXREYXRlICYmIHRoaXMuZGF0ZS5nZXREYXkoKSAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWRpc2FibGVkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCB3ZWVrbHlfYnlfc3VuZGF5JztcbiAgICAgICAgfSAvLyBEaXNhYmxlIGRhdGUgYmV0d2VlbiBjaGVja0luIGFuZCBuZXh0RGF0ZSwgaWYgbWluaW11bUR1cmF0aW9uIGlzIHN1cGVyaW9yIHRvIDFcblxuXG4gICAgICAgIGlmICh0aGlzLm5vdEFsbG93RGF5c0JldHdlZW5DaGVja0luQW5kTmV4dFZhbGlkRGF0ZSgwKSkge1xuICAgICAgICAgIHJldHVybiAndmhkX19kYXRlcGlja2VyX19tb250aC1kYXktLWRpc2FibGVkIHZoZF9fZGF0ZXBpY2tlcl9fbW9udGgtZGF5LS1ub3QtYWxsb3dlZCB3ZWVrbHlfYnlfc3VuZGF5JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG4gICAgZm9ybWF0RGF0ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmRhdGVGb3JtYXRlcih0aGlzLmRhdGUpO1xuICAgIH0sXG4gICAgdGFiSW5kZXg6IGZ1bmN0aW9uIHRhYkluZGV4KCkge1xuICAgICAgaWYgKCF0aGlzLmlzT3BlbiB8fCAhdGhpcy5iZWxvbmdzVG9UaGlzTW9udGggfHwgdGhpcy5pc0Rpc2FibGVkIHx8ICF0aGlzLmlzQ2xpY2thYmxlKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIG5pZ2h0c0NvdW50OiBmdW5jdGlvbiBuaWdodHNDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvdW50RGF5cyh0aGlzLmNoZWNrSW4sIHRoaXMuaG92ZXJpbmdEYXRlKTtcbiAgICB9LFxuICAgIHRvb2x0aXBNZXNzYWdlRGlzcGxheTogZnVuY3Rpb24gdG9vbHRpcE1lc3NhZ2VEaXNwbGF5KCkge1xuICAgICAgdmFyIGRhdGVJc0luUGVyaW9kID0gdGhpcy52YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXModGhpcy5ob3ZlcmluZ1BlcmlvZC5zdGFydEF0LCB0aGlzLmhvdmVyaW5nUGVyaW9kLmVuZEF0LCB0aGlzLmRhdGUpO1xuICAgICAgdmFyIGNoZWNrSW5Jc0luUGVyaW9kID0gdGhpcy52YWxpZGF0ZURhdGVCZXR3ZWVuVHdvRGF0ZXModGhpcy5ob3ZlcmluZ1BlcmlvZC5zdGFydEF0LCB0aGlzLmhvdmVyaW5nUGVyaW9kLmVuZEF0LCB0aGlzLmNoZWNrSW4pO1xuXG4gICAgICBpZiAodGhpcy50b29sdGlwTWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50b29sdGlwTWVzc2FnZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaG92ZXJpbmdQZXJpb2QgJiYgdGhpcy5ob3ZlcmluZ1BlcmlvZC50eXBlICE9PSAnbmlnaHRseScgJiYgZGF0ZUlzSW5QZXJpb2QgJiYgY2hlY2tJbklzSW5QZXJpb2QgJiYgdGhpcy5uaWdodHNDb3VudCA+PSA3KSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh0aGlzLm5pZ2h0c0NvdW50IC8gNywgXCIgXCIpLmNvbmNhdCh0aGlzLnBsdXJhbGl6ZSh0aGlzLm5pZ2h0c0NvdW50LCAnd2VlaycpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubmlnaHRzQ291bnQgPj0gMSkge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodGhpcy5uaWdodHNDb3VudCwgXCIgXCIpLmNvbmNhdCh0aGlzLm5pZ2h0c0NvdW50ICE9PSAxID8gdGhpcy5pMThuLm5pZ2h0cyA6IHRoaXMuaTE4bi5uaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnJztcbiAgICB9LFxuICAgIHNob3dUb29sdGlwOiBmdW5jdGlvbiBzaG93VG9vbHRpcCgpIHtcbiAgICAgIGlmICh0aGlzLnNjcmVlblNpemUgPT09ICdkZXNrdG9wJyB8fCB0aGlzLnNjcmVlblNpemUgPT09ICd0YWJsZXQnKSB7XG4gICAgICAgIHZhciBzaG93Q3VzdG9tVG9vbHRpcCA9IHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgJiYgdGhpcy5kYXRlID09PSB0aGlzLmhvdmVyaW5nRGF0ZTtcbiAgICAgICAgdmFyIHNob3dEZWZhdWx0VG9vbHRpcCA9ICF0aGlzLmlzRGlzYWJsZWQgJiYgdGhpcy5iZWxvbmdzVG9UaGlzTW9udGggJiYgdGhpcy5kYXRlID09PSB0aGlzLmhvdmVyaW5nRGF0ZSAmJiB0aGlzLnRvb2x0aXBNZXNzYWdlRGlzcGxheS5sZW5ndGggPiAwICYmIHRoaXMuY2hlY2tJbiAhPT0gbnVsbCAmJiB0aGlzLmNoZWNrT3V0ID09PSBudWxsO1xuICAgICAgICByZXR1cm4gc2hvd0N1c3RvbVRvb2x0aXAgfHwgc2hvd0RlZmF1bHRUb29sdGlwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBpc1RvZGF5OiBmdW5jdGlvbiBpc1RvZGF5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZURheSh0aGlzLmN1cnJlbnREYXRlLCB0aGlzLmRhdGUpID09PSAwO1xuICAgIH0sXG4gICAgaXNBRGlzYWJsZWREYXk6IGZ1bmN0aW9uIGlzQURpc2FibGVkRGF5KCkge1xuICAgICAgdmFyIGRheXMgPSBbJ3N1bmRheScsICdtb25kYXknLCAndHVlc2RheScsICd3ZWRuZXNkYXknLCAndGh1cnNkYXknLCAnZnJpZGF5JywgJ3NhdHVyZGF5J107XG4gICAgICB2YXIgZGF5ID0gZGF5c1t0aGlzLmRhdGUuZ2V0VVRDRGF5KCldO1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5kaXNhYmxlZFdlZWtEYXlzT2JqZWN0W2RheV07XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGhvdmVyaW5nRGF0ZTogZnVuY3Rpb24gaG92ZXJpbmdEYXRlKCkge1xuICAgICAgdGhpcy5mZXRjaEhpZ2hsaWdodCgpO1xuICAgIH0sXG4gICAgY2hlY2tJbjogZnVuY3Rpb24gY2hlY2tJbigpIHtcbiAgICAgIHRoaXMuZmV0Y2hIaWdobGlnaHQoKTtcbiAgICB9LFxuICAgIGFjdGl2ZU1vbnRoSW5kZXg6IGZ1bmN0aW9uIGFjdGl2ZU1vbnRoSW5kZXgoKSB7XG4gICAgICB0aGlzLmNoZWNrSWZEaXNhYmxlZCgpO1xuICAgICAgdGhpcy5jaGVja0lmSGlnaGxpZ2h0ZWQoKTtcblxuICAgICAgaWYgKHRoaXMuY2hlY2tJbiAhPT0gbnVsbCAmJiB0aGlzLmNoZWNrT3V0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmNoZWNrSW4sIHRoaXMuZGF0ZSkgJiYgdGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5kYXRlLCB0aGlzLmNoZWNrT3V0KSkge1xuICAgICAgICAgIHRoaXMuaXNIaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc0hpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja0luICE9PSBudWxsICYmIHRoaXMuY2hlY2tPdXQgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlTmV4dERheXMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5leHREaXNhYmxlZERhdGU6IGZ1bmN0aW9uIG5leHREaXNhYmxlZERhdGUoKSB7XG4gICAgICB0aGlzLmRpc2FibGVOZXh0RGF5cygpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50KCkge1xuICAgIHRoaXMuY2hlY2tJZkRpc2FibGVkKCk7XG4gICAgdGhpcy5jaGVja0lmSGlnaGxpZ2h0ZWQoKTtcbiAgfSxcbiAgbWV0aG9kczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHNyY19oZWxwZXJzKSwge30sIHtcbiAgICBub3RBbGxvd0RheXNCZXR3ZWVuQ2hlY2tJbkFuZE5leHRWYWxpZERhdGU6IGZ1bmN0aW9uIG5vdEFsbG93RGF5c0JldHdlZW5DaGVja0luQW5kTmV4dFZhbGlkRGF0ZShkYXlDb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0luICYmICF0aGlzLmNoZWNrT3V0ICYmIHRoaXMuZGF0ZS5nZXREYXkoKSA9PT0gZGF5Q29kZSAmJiBPYmplY3Qua2V5cyh0aGlzLmhvdmVyaW5nUGVyaW9kKS5sZW5ndGggPiAwICYmIHRoaXMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKHRoaXMuY2hlY2tJbiwgdGhpcy5ob3ZlcmluZ1BlcmlvZC5uZXh0VmFsaWREYXRlLCB0aGlzLmRhdGUpICYmIHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuY2hlY2tJbikgIT09IHRoaXMuZm9ybWF0RGF0ZSAmJiB0aGlzLmRhdGVGb3JtYXRlcih0aGlzLmhvdmVyaW5nUGVyaW9kLm5leHRWYWxpZERhdGUpICE9PSB0aGlzLmZvcm1hdERhdGU7XG4gICAgfSxcbiAgICBub3RBbGxvd2VkRGF5RHVlVG9OZXh0UGVyaW9kOiBmdW5jdGlvbiBub3RBbGxvd2VkRGF5RHVlVG9OZXh0UGVyaW9kKGN1cnJlbnRQZXJpb2QpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBuZXh0IHBlcmlvZCBpcyBkaXJlY3RseSBhZnRlciB0aGUgY3VycmVudCBwZXJpb2RcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoY3VycmVudFBlcmlvZC5lbmRBdCk7XG4gICAgICB2YXIgbmV4dFBlcmlvZCA9IG51bGw7XG4gICAgICB0aGlzLnNvcnRlZFBlcmlvZERhdGVzLmZvckVhY2goZnVuY3Rpb24gKHBlcmlvZCkge1xuICAgICAgICB2YXIgZGF0ZUEgPSBuZXcgRGF0ZShwZXJpb2Quc3RhcnRBdCkuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHZhciBkYXRlQiA9IG5ldyBEYXRlKGRhdGUpLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIGlmIChkYXRlQSA9PT0gZGF0ZUIpIHtcbiAgICAgICAgICBuZXh0UGVyaW9kID0gcGVyaW9kO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5leHRQZXJpb2QpIHtcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIHN0YXJ0QXQgbmV4dFBlcmlvZCB0byB0aGUgY3VycmVudFBlcmlvZCBtaW5pbXVtRHVyYXRpb25cbiAgICAgICAgdmFyIHN1YnRyYWN0VGltZXN0YW1wID0gbmV3IERhdGUobmV4dFBlcmlvZC5zdGFydEF0KS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgdmFyIHN1YnRyYWN0RGF0ZSA9IG5ldyBEYXRlKHN1YnRyYWN0VGltZXN0YW1wKTtcbiAgICAgICAgdmFyIHJlc3VsdERhdGUgPSBuZXcgRGF0ZShzdWJ0cmFjdERhdGUuc2V0RGF0ZShzdWJ0cmFjdERhdGUuZ2V0RGF0ZSgpIC0gY3VycmVudFBlcmlvZC5taW5pbXVtRHVyYXRpb24pKTtcblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKGN1cnJlbnRQZXJpb2Quc3RhcnRBdCwgcmVzdWx0RGF0ZSwgdGhpcy5kYXRlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGlzQ2xpY2thYmxlOiBmdW5jdGlvbiBpc0NsaWNrYWJsZSgpIHtcbiAgICAgIGlmICh0aGlzLiRyZWZzICYmIHRoaXMuJHJlZnMuZGF5KSB7XG4gICAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMuZGF5KS5wb2ludGVyRXZlbnRzICE9PSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZGF5Q2xpY2tlZDogZnVuY3Rpb24gZGF5Q2xpY2tlZChldmVudCwgZGF0ZSkge1xuICAgICAgdmFyIHJlc2V0Q2hlY2tpbiA9IGZhbHNlO1xuICAgICAgdmFyIGRpc2FibGVDaGVja291dE9uQ2hlY2tpbiA9ICF0aGlzLmRpc2FibGVDaGVja291dE9uQ2hlY2tpbjtcblxuICAgICAgaWYgKCF0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXlbdGhpcy5mb3JtYXREYXRlXSAmJiB0aGlzLmN1cnJlbnRCb29raW5nKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2Jvb2tpbmctY2xpY2tlZCcsIGV2ZW50LCBkYXRlLCB0aGlzLmN1cnJlbnRCb29raW5nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kaXNhYmxlQ2hlY2tvdXRPbkNoZWNraW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiB0aGlzLmNoZWNrSW4gPT09IGRhdGUpIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja091dCkge1xuICAgICAgICAgICAgZGlzYWJsZUNoZWNrb3V0T25DaGVja2luID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0Q2hlY2tpbiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc2FibGVDaGVja291dE9uQ2hlY2tpbiA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2xlYXItc2VsZWN0aW9uJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpc2FibGVDaGVja291dE9uQ2hlY2tpbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpc2FibGVDaGVja291dE9uQ2hlY2tpbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZCB8fCB0aGlzLmlzQ2xpY2thYmxlKCkpIHtcbiAgICAgICAgICB2YXIgZm9ybWF0RGF0ZSA9IHRoaXMuZGF0ZUZvcm1hdGVyKGRhdGUpO1xuICAgICAgICAgIHRoaXMuJGVtaXQoJ2RheS1jbGlja2VkJywgZXZlbnQsIGRhdGUsIGZvcm1hdERhdGUsIHJlc2V0Q2hlY2tpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgnY2xlYXItc2VsZWN0aW9uJyk7XG4gICAgICAgICAgdGhpcy5kYXlDbGlja2VkKGV2ZW50LCBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcGFyZUVuZERheTogZnVuY3Rpb24gY29tcGFyZUVuZERheSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5kRGF0ZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZURheSh0aGlzLmRhdGUsIHRoaXMub3B0aW9ucy5lbmREYXRlKSA9PT0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2hlY2tJZkRpc2FibGVkOiBmdW5jdGlvbiBjaGVja0lmRGlzYWJsZWQoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdGhpcy5pc0Rpc2FibGVkID0gLy8gSWYgdGhpcyBkYXkgaXMgZXF1YWwgYW55IG9mIHRoZSBkaXNhYmxlZCBkYXRlc1xuICAgICAgKHRoaXMuc29ydGVkRGlzYWJsZWREYXRlcyA/IHRoaXMuc29ydGVkRGlzYWJsZWREYXRlcy5zb21lKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuY29tcGFyZURheShpLCBfdGhpczUuZGF0ZSkgPT09IDA7XG4gICAgICB9KSA6IG51bGwpIHx8IC8vIE9yIGlzIGJlZm9yZSB0aGUgc3RhcnQgZGF0ZVxuICAgICAgdGhpcy5jb21wYXJlRGF5KHRoaXMuZGF0ZSwgdGhpcy5vcHRpb25zLnN0YXJ0RGF0ZSkgPT09IC0xIHx8IC8vIE9yIGlzIGFmdGVyIHRoZSBlbmQgZGF0ZVxuICAgICAgdGhpcy5jb21wYXJlRW5kRGF5KCkgfHwgLy8gT3IgaXMgaW4gb25lIG9mIHRoZSBkaXNhYmxlZCBkYXlzIG9mIHRoZSB3ZWVrXG4gICAgICB0aGlzLmlzQURpc2FibGVkRGF5IHx8IC8vIE9yIGlzIGFmdGVyIG1heCBOaWdodHNcbiAgICAgIHRoaXMuZGF0ZSA+PSB0aGlzLm5leHREaXNhYmxlZERhdGUgJiYgdGhpcy5uZXh0RGlzYWJsZWREYXRlICE9PSBudWxsOyAvLyBIYW5kbGUgY2hlY2tvdXQgZW5hYmxlZFxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZUNoZWNrb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmVEYXkodGhpcy5kYXRlLCB0aGlzLmNoZWNrSW4pID09PSAxICYmIHRoaXMuY29tcGFyZURheSh0aGlzLmRhdGUsIHRoaXMuY2hlY2tPdXQpID09PSAtMSkge1xuICAgICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGVja0lmSGlnaGxpZ2h0ZWQ6IGZ1bmN0aW9uIGNoZWNrSWZIaWdobGlnaHRlZCgpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrSW4gIT09IG51bGwgJiYgdGhpcy5jaGVja091dCAhPT0gbnVsbCAmJiB0aGlzLmlzRGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmNoZWNrSW4sIHRoaXMuZGF0ZSkgJiYgdGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5kYXRlLCB0aGlzLmNoZWNrT3V0KSkge1xuICAgICAgICAgIHRoaXMuaXNIaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc0hpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc2FibGVOZXh0RGF5czogZnVuY3Rpb24gZGlzYWJsZU5leHREYXlzKCkge1xuICAgICAgaWYgKHRoaXMubmV4dERpc2FibGVkRGF0ZSAhPT0gbnVsbCAmJiAhdGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5kYXRlLCB0aGlzLm5leHREaXNhYmxlZERhdGUpICYmIHRoaXMubmV4dERpc2FibGVkRGF0ZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5kYXRlLCBuZXcgRGF0ZSgpLnNldERhdGUodGhpcy5vcHRpb25zLnN0YXJ0RGF0ZS5nZXREYXRlKCkgLSAxKSkpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29tcGFyZURheSh0aGlzLmRhdGUsIHRoaXMuY2hlY2tJbikgPT09IDAgJiYgdGhpcy5taW5OaWdodENvdW50ID09PSAwKSB7XG4gICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5jaGVja0luLCB0aGlzLmRhdGUpICYmIHRoaXMub3B0aW9ucy5lbmFibGVDaGVja291dCkge1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZldGNoSGlnaGxpZ2h0OiBmdW5jdGlvbiBmZXRjaEhpZ2hsaWdodCgpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrSW4gIT09IG51bGwgJiYgdGhpcy5jaGVja091dCA9PT0gbnVsbCAmJiB0aGlzLmlzRGlzYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5jaGVja0luLCB0aGlzLmRhdGUpKSB7XG4gICAgICAgICAgdGhpcy5pc0hpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0RhdGVMZXNzT3JFcXVhbHModGhpcy5kYXRlLCB0aGlzLmhvdmVyaW5nRGF0ZSkpIHtcbiAgICAgICAgICB0aGlzLmlzSGlnaGxpZ2h0ZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyh0aGlzLmRhdGUsIHRoaXMuaG92ZXJpbmdEYXRlKSkge1xuICAgICAgICAgIHRoaXMuaXNIaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvRGF5LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX0RheXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChEYXl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9EYXkudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgRGF5X2NvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgY29tcG9uZW50c19EYXl2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIERheXZ1ZV90eXBlX3RlbXBsYXRlX2lkXzBiMTM0ODcyX3JlbmRlcixcbiAgRGF5dnVlX3R5cGVfdGVtcGxhdGVfaWRfMGIxMzQ4NzJfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgRGF5ID0gKERheV9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJjYWNoZURpcmVjdG9yeVwiOlwibm9kZV9tb2R1bGVzLy5jYWNoZS92dWUtbG9hZGVyXCIsXCJjYWNoZUlkZW50aWZpZXJcIjpcIjU1MzJlNDEwLXZ1ZS1sb2FkZXItdGVtcGxhdGVcIn0hLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL1dlZWtSb3cudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTMyMDRjZGY0JlxudmFyIFdlZWtSb3d2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zMjA0Y2RmNF9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9fd2Vlay1yb3cgdmhkX19oaWRlLXVwLXRvLXRhYmxldFwifSxfdm0uX2woKF92bS5kYXlOYW1lcyksZnVuY3Rpb24obmFtZSxpeCl7cmV0dXJuIF9jKCdkaXYnLHtrZXk6KF92bS53ZWVrS2V5ICsgXCItXCIgKyBpeCksc3RhdGljQ2xhc3M6XCJ2aGRfX2RhdGVwaWNrZXJfX3dlZWstbmFtZVwifSxbX3ZtLl92KFwiIFwiK192bS5fcyhuYW1lKStcIiBcIildKX0pLDApfVxudmFyIFdlZWtSb3d2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zMjA0Y2RmNF9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9XZWVrUm93LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zMjA0Y2RmNCZcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvLnBucG0vY2FjaGUtbG9hZGVyQDQuMS4wX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuL25vZGVfbW9kdWxlcy8ucG5wbS90aHJlYWQtbG9hZGVyQDIuMS4zX3dlYnBhY2tANC40Ni4wL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2JhYmVsLWxvYWRlckA4LjIuMl80NGNkOGU4OTg4ZThmNmJkZjQwNThjMzUyZDRlNzJkZC9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi9ub2RlX21vZHVsZXMvLnBucG0vdnVlLWxvYWRlckAxNS45LjdfNjc5MzU5Y2RiNjljMjE4ZjJmOGY0NzZiMmJhMDg3OTYvbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL1dlZWtSb3cudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFdlZWtSb3d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnV2Vla1JvdycsXG4gIHByb3BzOiB7XG4gICAgaTE4bjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHdlZWtLZXk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBmaXJzdERheU9mV2Vlazoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgZGF5TmFtZXM6IGZ1bmN0aW9uIGRheU5hbWVzKCkge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5pMThuWydkYXktbmFtZXMnXS5zbGljZSh0aGlzLmZpcnN0RGF5T2ZXZWVrKSksIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmkxOG5bJ2RheS1uYW1lcyddLnNsaWNlKDAsIHRoaXMuZmlyc3REYXlPZldlZWspKSkuc2xpY2UoMCwgNyk7XG4gICAgfVxuICB9XG59KTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9XZWVrUm93LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjb21wb25lbnRzX1dlZWtSb3d2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoV2Vla1Jvd3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyk7IFxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL1dlZWtSb3cudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgV2Vla1Jvd19jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfV2Vla1Jvd3Z1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgV2Vla1Jvd3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzMyMDRjZGY0X3JlbmRlcixcbiAgV2Vla1Jvd3Z1ZV90eXBlX3RlbXBsYXRlX2lkXzMyMDRjZGY0X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIFdlZWtSb3cgPSAoV2Vla1Jvd19jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZC1sb2FkZXJAMi4xLjNfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvLnBucG0vYmFiZWwtbG9hZGVyQDguMi4yXzQ0Y2Q4ZTg5ODhlOGY2YmRmNDA1OGMzNTJkNGU3MmRkL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvTW9udGgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuXG5cblxuXG5cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBNb250aHZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdNb250aCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBEYXk6IERheSxcbiAgICBXZWVrUm93OiBXZWVrUm93XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgbW9udGg6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBkYXlLZXk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB3ZWVrS2V5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgaXNEZXNrdG9wOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHNob3dZZWFyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIHllYXJCZWZvcmVNb250aDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBmaXJzdERheU9mV2Vlazoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIGJvb2tpbmdzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBhY3RpdmVNb250aEluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuICAgIGNoZWNrSW46IHtcbiAgICAgIHR5cGU6IERhdGVcbiAgICB9LFxuICAgIGNoZWNrSW5jaGVja091dEhhbGZEYXk6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGVja0luUGVyaW9kOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgY2hlY2tPdXQ6IHtcbiAgICAgIHR5cGU6IERhdGVcbiAgICB9LFxuICAgIGRpc2FibGVDaGVja291dE9uQ2hlY2tpbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkdXBsaWNhdGVCb29raW5nRGF0ZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhvdmVyaW5nRGF0ZToge1xuICAgICAgdHlwZTogRGF0ZVxuICAgIH0sXG4gICAgaG92ZXJpbmdQZXJpb2Q6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBob3ZlcmluZ1Rvb2x0aXA6IHtcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICBpMThuOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNPcGVuOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LFxuICAgIG1pbk5pZ2h0Q291bnQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIG5leHREaXNhYmxlZERhdGU6IHtcbiAgICAgIHR5cGU6IFtEYXRlLCBOdW1iZXIsIFN0cmluZ11cbiAgICB9LFxuICAgIG5leHRQZXJpb2REaXNhYmxlRGF0ZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH0sXG4gICAgcHJpY2VTeW1ib2w6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBwcmljZURlY2ltYWxzOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBudWxsXSxcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIHNjcmVlblNpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICcnXG4gICAgfSxcbiAgICBzaG93Q3VzdG9tVG9vbHRpcDoge1xuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcbiAgICBzaG93UHJpY2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd1dlZWtOdW1iZXJzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGRpc2FibGVkRGF0ZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvcnRlZERpc2FibGVkRGF0ZXM6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNvcnRlZFBlcmlvZERhdGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwTWVzc2FnZToge1xuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBtb250aE5hbWU6IGZ1bmN0aW9uIG1vbnRoTmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoKHRoaXMubW9udGguZGF5c1sxNV0uZGF0ZSk7XG4gICAgfSxcbiAgICB3ZWVrTnVtYmVyczogZnVuY3Rpb24gd2Vla051bWJlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5tb250aC5kYXlzLmZpbHRlcihmdW5jdGlvbiAoZGF5LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggJSA3ID09PSAwICYmIChkYXkuYmVsb25nc1RvVGhpc01vbnRoIHx8IF90aGlzLm1vbnRoLmRheXNbaW5kZXggKyA2XS5iZWxvbmdzVG9UaGlzTW9udGgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmdldElzb1dlZWsoZGF5LmRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc3JjX2hlbHBlcnMpLCB7fSwge1xuICAgIGdldE1vbnRoOiBmdW5jdGlvbiBnZXRNb250aChkYXRlKSB7XG4gICAgICB2YXIgbW9udGggPSAnTU1NTSc7XG4gICAgICB2YXIgeWVhciA9ICdZWVlZJztcbiAgICAgIHZhciBmb3JtYXQgPSBtb250aDsgLy8gY29uc3QgaTE4biA9IHsgbW9udGhOYW1lczogdGhpcy5pMThuWydtb250aC1uYW1lcyddIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd1llYXIpIHtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy55ZWFyQmVmb3JlTW9udGggPyBcIlwiLmNvbmNhdCh5ZWFyLCBcIiBcIikuY29uY2F0KG1vbnRoKSA6IFwiXCIuY29uY2F0KG1vbnRoLCBcIiBcIikuY29uY2F0KHllYXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGliX2ZlY2hhLmZvcm1hdChkYXRlLCBmb3JtYXQpLnRyaW0oKTtcbiAgICB9LFxuICAgIGVudGVyRGF5OiBmdW5jdGlvbiBlbnRlckRheShldmVudCwgZGF5KSB7XG4gICAgICB0aGlzLiRlbWl0KCdlbnRlci1kYXknLCBldmVudCwgZGF5KTtcbiAgICB9LFxuICAgIGVudGVyTW9udGg6IGZ1bmN0aW9uIGVudGVyTW9udGgoZXZlbnQpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2VudGVyLW1vbnRoJywgZXZlbnQsIHRoaXMubW9udGgpO1xuICAgIH0sXG4gICAgY2xlYXJTZWxlY3Rpb246IGZ1bmN0aW9uIGNsZWFyU2VsZWN0aW9uKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2xlYXItc2VsZWN0aW9uJyk7XG4gICAgfSxcbiAgICBoYW5kbGVCb29raW5nQ2xpY2tlZDogZnVuY3Rpb24gaGFuZGxlQm9va2luZ0NsaWNrZWQoZXZlbnQsIGRhdGUsIGN1cnJlbnRCb29raW5nKSB7XG4gICAgICB0aGlzLiRlbWl0KCdib29raW5nLWNsaWNrZWQnLCBldmVudCwgZGF0ZSwgY3VycmVudEJvb2tpbmcpO1xuICAgIH0sXG4gICAgaGFuZGxlRGF5Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZURheUNsaWNrKGV2ZW50LCBkYXRlLCBmb3JtYXREYXRlLCByZXNldENoZWNraW4pIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2RheS1jbGlja2VkJywgZXZlbnQsIGRhdGUsIGZvcm1hdERhdGUsIHJlc2V0Q2hlY2tpbik7XG4gICAgfVxuICB9KVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvTW9udGgudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbXBvbmVudHNfTW9udGh2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoTW9udGh2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9Nb250aC52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBNb250aF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfTW9udGh2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIE1vbnRodnVlX3R5cGVfdGVtcGxhdGVfaWRfNzczN2RmZDRfcmVuZGVyLFxuICBNb250aHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzc3MzdkZmQ0X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIE1vbnRoID0gKE1vbnRoX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzP3tcImNhY2hlRGlyZWN0b3J5XCI6XCJub2RlX21vZHVsZXMvLmNhY2hlL3Z1ZS1sb2FkZXJcIixcImNhY2hlSWRlbnRpZmllclwiOlwiNTUzMmU0MTAtdnVlLWxvYWRlci10ZW1wbGF0ZVwifSEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvRGF0ZUlucHV0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0zNGY5NThlNiZcbnZhciBEYXRlSW5wdXR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNGY5NThlNl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZoZF9fZGF0ZXBpY2tlcl9faW5wdXRcIixjbGFzczpfdm0uaW5wdXRDbGFzcyxhdHRyczp7XCJkYXRhLXFhXCI6XCJ2aGRfX2RhdGVwaWNrZXJJbnB1dFwiLFwidGFiaW5kZXhcIjpfdm0udGFiSW5kZXh9LG9uOntcImNsaWNrXCI6X3ZtLnRvZ2dsZURhdGVwaWNrZXIsXCJrZXl1cFwiOmZ1bmN0aW9uKCRldmVudCl7aWYoISRldmVudC50eXBlLmluZGV4T2YoJ2tleScpJiZfdm0uX2soJGV2ZW50LmtleUNvZGUsXCJlbnRlclwiLDEzLCRldmVudC5rZXksXCJFbnRlclwiKSl7IHJldHVybiBudWxsOyB9JGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyRldmVudC5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBfdm0udG9nZ2xlRGF0ZXBpY2tlci5hcHBseShudWxsLCBhcmd1bWVudHMpfX19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5pbnB1dERhdGUgPyBfdm0uaW5wdXREYXRlIDogX3ZtLmkxOG5bX3ZtLmlucHV0RGF0ZVR5cGVdKStcIiBcIildKX1cbnZhciBEYXRlSW5wdXR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNGY5NThlNl9zdGF0aWNSZW5kZXJGbnMgPSBbXVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL0RhdGVQaWNrZXIvY29tcG9uZW50cy9EYXRlSW5wdXQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTM0Zjk1OGU2JlxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZC1sb2FkZXJAMi4xLjNfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvLnBucG0vYmFiZWwtbG9hZGVyQDguMi4yXzQ0Y2Q4ZTg5ODhlOGY2YmRmNDA1OGMzNTJkNGU3MmRkL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvRGF0ZUlucHV0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBEYXRlSW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBwcm9wczoge1xuICAgIGlzT3Blbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBpbnB1dERhdGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6IG51bGxcbiAgICB9LFxuICAgIGlucHV0RGF0ZVR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdjaGVjay1pbidcbiAgICB9LFxuICAgIHNpbmdsZURheVNlbGVjdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICB0b2dnbGVEYXRlcGlja2VyOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICBpMThuOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpbnB1dENsYXNzOiBmdW5jdGlvbiBpbnB1dENsYXNzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3ZoZF9fZGF0ZXBpY2tlcl9faW5wdXQtLWlzLWFjdGl2ZSc6IHRoaXMuaXNPcGVuICYmIHRoaXMuaW5wdXREYXRlID09IG51bGwsXG4gICAgICAgICd2aGRfX2RhdGVwaWNrZXJfX2lucHV0LS1zaW5nbGUtZGF0ZSc6IHRoaXMuc2luZ2xlRGF5U2VsZWN0aW9uXG4gICAgICB9O1xuICAgIH0sXG4gICAgdGFiSW5kZXg6IGZ1bmN0aW9uIHRhYkluZGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5wdXREYXRlVHlwZSA9PT0gJ2NoZWNrLWluJyA/IDAgOiAtMTtcbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvRGF0ZVBpY2tlci9jb21wb25lbnRzL0RhdGVJbnB1dC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29tcG9uZW50c19EYXRlSW5wdXR2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoRGF0ZUlucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL2NvbXBvbmVudHMvRGF0ZUlucHV0LnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIERhdGVJbnB1dF9jb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIGNvbXBvbmVudHNfRGF0ZUlucHV0dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICBEYXRlSW5wdXR2dWVfdHlwZV90ZW1wbGF0ZV9pZF8zNGY5NThlNl9yZW5kZXIsXG4gIERhdGVJbnB1dHZ1ZV90eXBlX3RlbXBsYXRlX2lkXzM0Zjk1OGU2X3N0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIERhdGVJbnB1dCA9IChEYXRlSW5wdXRfY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wdWJsaWMvaTE4bi9lbi5qc1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZW4gPSAoe1xuICBuaWdodDogJ05pZ2h0JyxcbiAgbmlnaHRzOiAnTmlnaHRzJyxcbiAgd2VlazogJ1dlZWsnLFxuICB3ZWVrczogJ1dlZWtzJyxcbiAgJ2RheS1uYW1lcyc6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodXInLCAnRnJpJywgJ1NhdCddLFxuICAnY2hlY2staW4nOiAnQ2hlY2staW4nLFxuICAnY2hlY2stb3V0JzogJ0NoZWNrLW91dCcsXG4gICdtb250aC1uYW1lcyc6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICB0b29sdGlwOiB7XG4gICAgaGFsZkRheUNoZWNrSW46ICdBdmFpbGFibGUgQ2hlY2tJbicsXG4gICAgaGFsZkRheUNoZWNrT3V0OiAnQXZhaWxhYmxlIENoZWNrT3V0JyxcbiAgICBzYXR1cmRheVRvU2F0dXJkYXk6ICdPbmx5IFNhdHVyZGF5IHRvIFNhdHVyZGF5JyxcbiAgICBzdW5kYXlUb1N1bmRheTogJ09ubHkgU3VuZGF5IHRvIFN1bmRheScsXG4gICAgbWluaW11bVJlcXVpcmVkUGVyaW9kOiAnJXttaW5OaWdodEluUGVyaW9kfSAle25pZ2h0fSBtaW5pbXVtLidcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy8ucG5wbS9jYWNoZS1sb2FkZXJANC4xLjBfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4vbm9kZV9tb2R1bGVzLy5wbnBtL3RocmVhZC1sb2FkZXJAMi4xLjNfd2VicGFja0A0LjQ2LjAvbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi9ub2RlX21vZHVsZXMvLnBucG0vYmFiZWwtbG9hZGVyQDguMi4yXzQ0Y2Q4ZTg5ODhlOGY2YmRmNDA1OGMzNTJkNGU3MmRkL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzLy5wbnBtL2NhY2hlLWxvYWRlckA0LjEuMF93ZWJwYWNrQDQuNDYuMC9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuL25vZGVfbW9kdWxlcy8ucG5wbS92dWUtbG9hZGVyQDE1LjkuN182NzkzNTljZGI2OWMyMThmMmY4ZjQ3NmIyYmEwODc5Ni9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NyYy9EYXRlUGlja2VyL0hvdGVsRGF0ZVBpY2tlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgSG90ZWxEYXRlUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ0hvdGVsRGF0ZVBpY2tlcicsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBNb250aDogTW9udGgsXG4gICAgRGF0ZUlucHV0OiBEYXRlSW5wdXRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBhbHdheXNWaXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGJvb2tpbmdzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBjbG9zZURhdGVwaWNrZXJPbkNsaWNrT3V0c2lkZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGRpc2FibGVDaGVja291dE9uQ2hlY2tpbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkaXNhYmxlZERhdGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNhYmxlZERheXNPZldlZWs6IHtcbiAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpc2FibGVkV2Vla0RheXM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNwbGF5Q2xlYXJCdXR0b246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBlbmFibGVDaGVja291dDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBlbmREYXRlOiB7XG4gICAgICB0eXBlOiBbRGF0ZSwgU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogSW5maW5pdHlcbiAgICB9LFxuICAgIGVuZGluZ0RhdGVWYWx1ZToge1xuICAgICAgdHlwZTogW0RhdGUsIG51bGxdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgZmlyc3REYXlPZldlZWs6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ1lZWVktTU0tREQnXG4gICAgfSxcbiAgICBncmlkU3R5bGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBoYWxmRGF5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgaG92ZXJpbmdUb29sdGlwOiB7XG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgdHlwZTogW0Jvb2xlYW4sIEZ1bmN0aW9uXVxuICAgIH0sXG4gICAgaTE4bjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBlbjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhc3REYXRlQXZhaWxhYmxlOiB7XG4gICAgICB0eXBlOiBbTnVtYmVyLCBEYXRlXSxcbiAgICAgIGRlZmF1bHQ6IEluZmluaXR5XG4gICAgfSxcbiAgICBtYXhOaWdodHM6IHtcbiAgICAgIHR5cGU6IFtOdW1iZXIsIG51bGxdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgbWluTmlnaHRzOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICBkZWZhdWx0OiAxXG4gICAgfSxcbiAgICBwZXJpb2REYXRlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG4gICAgcG9zaXRpb25SaWdodDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBwcmljZVN5bWJvbDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJydcbiAgICB9LFxuICAgIHNob3dQcmljZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBzaG93U2luZ2xlTW9udGg6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2hvd1llYXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBzaG93V2Vla051bWJlcnM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgc2luZ2xlRGF5U2VsZWN0aW9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIHN0YXJ0RGF0ZToge1xuICAgICAgdHlwZTogW0RhdGUsIFN0cmluZ10sXG4gICAgICBkZWZhdWx0OiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFydGluZ0RhdGVWYWx1ZToge1xuICAgICAgdHlwZTogW0RhdGUsIG51bGxdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdG9vbHRpcE1lc3NhZ2U6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIG51bGxdLFxuICAgICAgZGVmYXVsdDogbnVsbFxuICAgIH0sXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICB5ZWFyQmVmb3JlTW9udGg6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aXZlTW9udGhJbmRleDogMCxcbiAgICAgIGNoZWNrSW46IHRoaXMuc3RhcnRpbmdEYXRlVmFsdWUsXG4gICAgICBjaGVja0luY2hlY2tPdXRIYWxmRGF5OiB7fSxcbiAgICAgIGNoZWNrSW5QZXJpb2Q6IHt9LFxuICAgICAgY2hlY2tPdXQ6IHRoaXMuZW5kaW5nRGF0ZVZhbHVlLFxuICAgICAgaG92ZXJpbmdQZXJpb2Q6IHt9LFxuICAgICAgY3VzdG9tVG9vbHRpcDogJycsXG4gICAgICBjdXN0b21Ub29sdGlwSGFsZmRheTogJycsXG4gICAgICBkYXRlcGlja2VyRGF5S2V5OiAwLFxuICAgICAgZGF0ZXBpY2tlck1vbnRoS2V5OiAwLFxuICAgICAgZGF0ZXBpY2tlcldlZWtLZXk6IDAsXG4gICAgICBkeW5hbWljTmlnaHRDb3VudHM6IG51bGwsXG4gICAgICBoYXNoOiBEYXRlLm5vdygpLFxuICAgICAgaG92ZXJpbmdEYXRlOiBudWxsLFxuICAgICAgaXNUb3VjaE1vdmU6IGZhbHNlLFxuICAgICAgbW9udGhzOiBbXSxcbiAgICAgIG5leHREaXNhYmxlZERhdGU6IG51bGwsXG4gICAgICBuZXh0UGVyaW9kRGlzYWJsZURhdGVzOiBbXSxcbiAgICAgIG9wZW46IGZhbHNlLFxuICAgICAgc2NyZWVuU2l6ZTogbnVsbCxcbiAgICAgIHNob3dDdXN0b21Ub29sdGlwOiBmYWxzZSxcbiAgICAgIHNvcnRlZERpc2FibGVkRGF0ZXM6IG51bGwsXG4gICAgICB4RG93bjogbnVsbCxcbiAgICAgIHhVcDogbnVsbCxcbiAgICAgIHlEb3duOiBudWxsLFxuICAgICAgeVVwOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc09wZW46IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KG9wZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLm9wZW4gPSBvcGVuO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0Rlc2t0b3AgJiYgIXRoaXMuYWx3YXlzVmlzaWJsZSkge1xuICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpO1xuXG4gICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKF90aGlzLiRyZWZzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN3aXBlcldyYXBwZXIgPSBfdGhpcy4kcmVmcy5zd2lwZXJXcmFwcGVyO1xuICAgICAgICAgICAgICAgIHZhciBtb250aEhlaWhndCA9IF90aGlzLiRyZWZzLmRhdGVwaWNrZXJNb250aFswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb25JbmRleCA9IF90aGlzLmNoZWNrT3V0ID8gX3RoaXMuZ2V0TW9udGhEaWZmKG5ldyBEYXRlKCksIF90aGlzLmNoZWNrT3V0KSA6IDA7XG4gICAgICAgICAgICAgICAgc3dpcGVyV3JhcHBlci5zY3JvbGxUb3AgPSBjdXJyZW50U2VsZWN0aW9uSW5kZXggKiBtb250aEhlaWhndDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMub3Blbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzb3J0Qm9va2luZ3M6IGZ1bmN0aW9uIHNvcnRCb29raW5ncygpIHtcbiAgICAgIGlmICh0aGlzLmJvb2tpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGJvb2tpbmdzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuYm9va2luZ3MpO1xuXG4gICAgICAgIHJldHVybiBib29raW5ncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgdmFyIGFhID0gYS5jaGVja0luRGF0ZS5zcGxpdCgnLycpLnJldmVyc2UoKS5qb2luKCk7XG4gICAgICAgICAgdmFyIGJiID0gYi5jaGVja091dERhdGUuc3BsaXQoJy8nKS5yZXZlcnNlKCkuam9pbigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcblxuICAgICAgICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBkdXBsaWNhdGVCb29raW5nRGF0ZXM6IGZ1bmN0aW9uIGR1cGxpY2F0ZUJvb2tpbmdEYXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmJhc2VIYWxmRGF5RGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChuZXdBcnIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ld0Fyci5oYXMoZGF0ZSkgfHwgIW5ld0Fyci5hZGQoZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICB9KG5ldyBTZXQoKSkpO1xuICAgIH0sXG4gICAgYmFzZUhhbGZEYXlEYXRlczogZnVuY3Rpb24gYmFzZUhhbGZEYXlEYXRlcygpIHtcbiAgICAgIGlmICh0aGlzLnNvcnRCb29raW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBib29raW5ncyA9IHRoaXMuc29ydEJvb2tpbmdzLm1hcChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBbeC5jaGVja0luRGF0ZSwgeC5jaGVja091dERhdGVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJvb2tpbmdzLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkRGF0ZXM7XG4gICAgfSxcbiAgICBwYWdpbmF0ZU1vbnRoczogZnVuY3Rpb24gcGFnaW5hdGVNb250aHMoKSB7XG4gICAgICB2YXIgbW9udGhzID0gW3RoaXMubW9udGhzW3RoaXMuYWN0aXZlTW9udGhJbmRleF1dO1xuXG4gICAgICBpZiAoISh0aGlzLnNob3dTaW5nbGVNb250aCB8fCB0aGlzLmFsd2F5c1Zpc2libGUgJiYgIXRoaXMuaXNEZXNrdG9wKSkge1xuICAgICAgICBtb250aHMucHVzaCh0aGlzLm1vbnRoc1t0aGlzLmFjdGl2ZU1vbnRoSW5kZXggKyAxXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb250aHM7XG4gICAgfSxcbiAgICBjdXN0b21Ub29sdGlwTWVzc2FnZTogZnVuY3Rpb24gY3VzdG9tVG9vbHRpcE1lc3NhZ2UoKSB7XG4gICAgICB2YXIgdG9vbHRpcCA9ICcnO1xuXG4gICAgICBpZiAodGhpcy5ob3ZlcmluZ0RhdGUgJiYgKHRoaXMuY3VzdG9tVG9vbHRpcCB8fCB0aGlzLmN1c3RvbVRvb2x0aXBIYWxmZGF5KSkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21Ub29sdGlwICYmIHRoaXMuY3VzdG9tVG9vbHRpcEhhbGZkYXkpIHtcbiAgICAgICAgICB0b29sdGlwID0gXCJcIi5jb25jYXQodGhpcy5jdXN0b21Ub29sdGlwSGFsZmRheSwgXCIuIDxici8+IFwiKS5jb25jYXQodGhpcy5jdXN0b21Ub29sdGlwKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmN1c3RvbVRvb2x0aXBIYWxmZGF5ICYmICF0aGlzLmN1c3RvbVRvb2x0aXApIHtcbiAgICAgICAgICB0b29sdGlwID0gdGhpcy5jdXN0b21Ub29sdGlwSGFsZmRheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b29sdGlwID0gdGhpcy5jdXN0b21Ub29sdGlwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvb2x0aXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBNZXNzYWdlO1xuICAgIH0sXG4gICAgc29ydGVkUGVyaW9kRGF0ZXM6IGZ1bmN0aW9uIHNvcnRlZFBlcmlvZERhdGVzKCkge1xuICAgICAgdmFyIHBlcmlvZERhdGVzID0gW107XG5cbiAgICAgIGlmICh0aGlzLnBlcmlvZERhdGVzKSB7XG4gICAgICAgIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiBzb3J0RnVuY3Rpb24oZmVjaGExLCBmZWNoYTIpIHtcbiAgICAgICAgICB2YXIgdjEgPSBmZWNoYTEuc3RhcnRBdC5zcGxpdCgnLycpLnJldmVyc2UoKS5qb2luKCkgKyBmZWNoYTEuZW5kQXQuc3BsaXQoJy8nKS5yZXZlcnNlKCkuam9pbigpO1xuICAgICAgICAgIHZhciB2MiA9IGZlY2hhMi5zdGFydEF0LnNwbGl0KCcvJykucmV2ZXJzZSgpLmpvaW4oKSArIGZlY2hhMi5lbmRBdC5zcGxpdCgnLycpLnJldmVyc2UoKS5qb2luKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuXG4gICAgICAgICAgcmV0dXJuIHYxIDwgdjIgPyAtMSA6IHYxID4gdjIgPyAxIDogMDtcbiAgICAgICAgfTtcblxuICAgICAgICBwZXJpb2REYXRlcyA9IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLnBlcmlvZERhdGVzKS5zb3J0KHNvcnRGdW5jdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwZXJpb2REYXRlcztcbiAgICB9LFxuICAgIHNsaWNlTW9udGhNb2JpbGU6IGZ1bmN0aW9uIHNsaWNlTW9udGhNb2JpbGUoKSB7XG4gICAgICB2YXIgbmJNb250aFJlbmRlckRvbSA9IDQ7XG5cbiAgICAgIGlmICh0aGlzLmFjdGl2ZU1vbnRoSW5kZXggPj0gbmJNb250aFJlbmRlckRvbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aHMuc2xpY2UodGhpcy5hY3RpdmVNb250aEluZGV4IC0gMywgdGhpcy5hY3RpdmVNb250aEluZGV4ICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm1vbnRocy5zbGljZSgwLCBuYk1vbnRoUmVuZGVyRG9tKTtcbiAgICB9LFxuICAgIGlzUHJldmVudGVkTWF4TW9udGg6IGZ1bmN0aW9uIGlzUHJldmVudGVkTWF4TW9udGgoKSB7XG4gICAgICB2YXIgbGFzdEluZGV4TW9udGhBdmFpbGFibGUgPSB0aGlzLmdldE1vbnRoRGlmZih0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5sYXN0RGF0ZUF2YWlsYWJsZSk7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVNb250aEluZGV4ID49IGxhc3RJbmRleE1vbnRoQXZhaWxhYmxlIC0gMTtcbiAgICB9LFxuICAgIG1pbk5pZ2h0Q291bnQ6IGZ1bmN0aW9uIG1pbk5pZ2h0Q291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5keW5hbWljTmlnaHRDb3VudHMgfHwgdGhpcy5taW5OaWdodHM7XG4gICAgfSxcbiAgICBzaG93Q2xlYXJTZWxlY3Rpb25CdXR0b246IGZ1bmN0aW9uIHNob3dDbGVhclNlbGVjdGlvbkJ1dHRvbigpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmNoZWNrSW4gfHwgdGhpcy5jaGVja091dCkgJiYgdGhpcy5kaXNwbGF5Q2xlYXJCdXR0b24pO1xuICAgIH0sXG4gICAgZGlzYWJsZWRXZWVrRGF5c09iamVjdDogZnVuY3Rpb24gZGlzYWJsZWRXZWVrRGF5c09iamVjdCgpIHtcbiAgICAgIHZhciBkaXNhYmxlZERheXMgPSB0aGlzLmRpc2FibGVkRGF5c09mV2Vlay5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0pOyAvLyBjb25zdCBuYW1lcyA9IHRoaXMuaTE4blsnZGF5LW5hbWVzJ11cblxuICAgICAgdmFyIG5hbWVzID0gWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheSddO1xuICAgICAgdmFyIFNVTkRBWSA9IG5hbWVzWzBdO1xuICAgICAgdmFyIE1PTkRBWSA9IG5hbWVzWzFdO1xuICAgICAgdmFyIFRVRVNEQVkgPSBuYW1lc1syXTtcbiAgICAgIHZhciBXRURORVNEQVkgPSBuYW1lc1szXTtcbiAgICAgIHZhciBUSFVSU0RBWSA9IG5hbWVzWzRdO1xuICAgICAgdmFyIEZSSURBWSA9IG5hbWVzWzVdO1xuICAgICAgdmFyIFNBVFVSREFZID0gbmFtZXNbNl07IC8vIFRoZSBvcmRlciBvZiBfZGVmYXVsdCBpcyBpbXBvcnRhbnQhXG5cbiAgICAgIHZhciBkaXNhYmxlZFdlZWtEYXlzT2JqZWN0ID0ge1xuICAgICAgICBzdW5kYXk6IGRpc2FibGVkRGF5cy5pbmNsdWRlcyhTVU5EQVkpLFxuICAgICAgICBtb25kYXk6IGRpc2FibGVkRGF5cy5pbmNsdWRlcyhNT05EQVkpLFxuICAgICAgICB0dWVzZGF5OiBkaXNhYmxlZERheXMuaW5jbHVkZXMoVFVFU0RBWSksXG4gICAgICAgIHdlZG5lc2RheTogZGlzYWJsZWREYXlzLmluY2x1ZGVzKFdFRE5FU0RBWSksXG4gICAgICAgIHRodXJzZGF5OiBkaXNhYmxlZERheXMuaW5jbHVkZXMoVEhVUlNEQVkpLFxuICAgICAgICBmcmlkYXk6IGRpc2FibGVkRGF5cy5pbmNsdWRlcyhGUklEQVkpLFxuICAgICAgICBzYXR1cmRheTogZGlzYWJsZWREYXlzLmluY2x1ZGVzKFNBVFVSREFZKVxuICAgICAgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRpc2FibGVkV2Vla0RheXNPYmplY3QsIHRoaXMuZGlzYWJsZWRXZWVrRGF5cyk7XG4gICAgfSxcbiAgICBkaXNhYmxlZFdlZWtEYXlzQXJyYXk6IGZ1bmN0aW9uIGRpc2FibGVkV2Vla0RheXNBcnJheSgpIHtcbiAgICAgIHZhciBkYXlzID0gdGhpcy5kaXNhYmxlZFdlZWtEYXlzT2JqZWN0OyAvLyBjb25zdCBuYW1lcyA9IHRoaXMuaTE4blsnZGF5LW5hbWVzJ11cblxuICAgICAgdmFyIG5hbWVzID0gWydzdW5kYXknLCAnbW9uZGF5JywgJ3R1ZXNkYXknLCAnd2VkbmVzZGF5JywgJ3RodXJzZGF5JywgJ2ZyaWRheScsICdzYXR1cmRheSddO1xuXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbiBmbkRpc2FibGVkV2Vla0RheXNBcnJheShkYXksIGl4KSB7XG4gICAgICAgIHJldHVybiBkYXlbMV0gPyBuYW1lc1tpeF0gOiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYXlzKS5tYXAoZm4pLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGF5T3B0aW9uczogZnVuY3Rpb24gZGF5T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy4kcHJvcHMpLCB7fSwge1xuICAgICAgICBkaXNhYmxlZFdlZWtEYXlzT2JqZWN0OiB0aGlzLmRpc2FibGVkV2Vla0RheXNPYmplY3RcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbnVtYmVyT2ZNb250aHM6IGZ1bmN0aW9uIG51bWJlck9mTW9udGhzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1NpbmdsZU1vbnRoID8gMSA6IDI7XG4gICAgfSxcbiAgICBpc0Rlc2t0b3A6IGZ1bmN0aW9uIGlzRGVza3RvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcmVlblNpemUgPT09ICdkZXNrdG9wJztcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgYm9va2luZ3M6IGZ1bmN0aW9uIGJvb2tpbmdzKCkge1xuICAgICAgdGhpcy5jcmVhdGVIYWxmRGF5RGF0ZXModGhpcy5iYXNlSGFsZkRheURhdGVzKTtcbiAgICAgIHRoaXMucmVSZW5kZXIoKTtcbiAgICB9LFxuICAgIGNoZWNrSW46IGZ1bmN0aW9uIGNoZWNrSW4obmV3RGF0ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hlY2staW4tY2hhbmdlZCcsIG5ld0RhdGUpO1xuICAgICAgdGhpcy4kZW1pdCgnc3RhcnRpbmctZGF0ZS1jaGFuZ2VkJywgbmV3RGF0ZSk7XG4gICAgICB0aGlzLnJlUmVuZGVyKCk7XG4gICAgfSxcbiAgICBjaGVja091dDogZnVuY3Rpb24gY2hlY2tPdXQobmV3RGF0ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnZW5kaW5nLWRhdGUtY2hhbmdlZCcsIG5ld0RhdGUpO1xuXG4gICAgICBpZiAodGhpcy5jaGVja091dCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmhvdmVyaW5nRGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dERpc2FibGVkRGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3JlYXRlSGFsZkRheURhdGVzKHRoaXMuYmFzZUhhbGZEYXlEYXRlcyk7XG4gICAgICAgIHRoaXMucmVSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5zaG93Q3VzdG9tVG9vbHRpcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiRlbWl0KCdjaGVjay1vdXQtY2hhbmdlZCcsIG5ld0RhdGUpO1xuICAgICAgdGhpcy5yZVJlbmRlcigpO1xuICAgIH0sXG4gICAgZmlyc3REYXlPZldlZWs6IGZ1bmN0aW9uIGZpcnN0RGF5T2ZXZWVrKG5ld0RheSkge1xuICAgICAgdGhpcy4kZW1pdCgnZmlyc3QtZGF5LW9mLXdlZWstY2hhbmdlZCcsIG5ld0RheSk7XG4gICAgICB2YXIgc3RhcnREYXRlID0gbmV3IERhdGUodGhpcy5zdGFydERhdGUpO1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMubnVtYmVyT2ZNb250aHMgKyB0aGlzLmFjdGl2ZU1vbnRoSW5kZXg7XG4gICAgICB0aGlzLmdlbmVyYXRlSW5pdGlhbE1vbnRocygpO1xuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy5udW1iZXJPZk1vbnRoczsgaSA8IG9mZnNldDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgobmV3IERhdGUoc3RhcnREYXRlLmdldEZ1bGxZZWFyKCksIHN0YXJ0RGF0ZS5nZXRNb250aCgpICsgaSwgMSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlUmVuZGVyKCk7XG4gICAgfSxcbiAgICBzdGFydGluZ0RhdGVWYWx1ZTogZnVuY3Rpb24gc3RhcnRpbmdEYXRlVmFsdWUoZGF0ZSkge1xuICAgICAgdGhpcy5zZXRDaGVja0luKGRhdGUpO1xuICAgIH0sXG4gICAgZW5kaW5nRGF0ZVZhbHVlOiBmdW5jdGlvbiBlbmRpbmdEYXRlVmFsdWUoZGF0ZSkge1xuICAgICAgdGhpcy5zZXRDaGVja091dChkYXRlKTtcbiAgICB9LFxuICAgIHNpbmdsZURheVNlbGVjdGlvbjogZnVuY3Rpb24gc2luZ2xlRGF5U2VsZWN0aW9uKHNpbmdsZSkge1xuICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICB0aGlzLnNldENoZWNrT3V0KHRoaXMuY2hlY2tJbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldENoZWNrSW4odGhpcy5jaGVja0luKTtcbiAgICAgICAgdGhpcy5zZXRDaGVja091dChudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZVJlbmRlcigpO1xuICAgIH0sXG4gICAgeWVhckJlZm9yZU1vbnRoOiBmdW5jdGlvbiB5ZWFyQmVmb3JlTW9udGgoKSB7XG4gICAgICB0aGlzLnJlUmVuZGVyKCk7XG4gICAgfSxcbiAgICBpMThuOiBmdW5jdGlvbiBpMThuKCkge1xuICAgICAgdGhpcy5jb25maWd1cmVJMThuKCk7XG4gICAgfSxcbiAgICBkaXNhYmxlZERhdGVzOiBmdW5jdGlvbiBkaXNhYmxlZERhdGVzKCkge1xuICAgICAgdGhpcy5uZXh0RGlzYWJsZWREYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuY3JlYXRlSGFsZkRheURhdGVzKHRoaXMuYmFzZUhhbGZEYXlEYXRlcyk7XG4gICAgICB0aGlzLnJlUmVuZGVyKCk7XG4gICAgfVxuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHRoaXMuY29uZmlndXJlSTE4bigpO1xuICAgIHRoaXMuZ2VuZXJhdGVJbml0aWFsTW9udGhzKCk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG5cbiAgICBpZiAoIXRoaXMuaXNEZXNrdG9wKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCBmYWxzZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLmhhbmRsZVRvdWNoRW5kLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja091dHNpZGUsIGZhbHNlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5lc2NGdW5jdGlvbiwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMub25FbGVtZW50SGVpZ2h0Q2hhbmdlKGRvY3VtZW50LmJvZHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5lbWl0SGVpZ2hDaGFuZ2VFdmVudCgpO1xuICAgIH0pO1xuICAgIHRoaXMuY3JlYXRlSGFsZkRheURhdGVzKHRoaXMuYmFzZUhhbGZEYXlEYXRlcyk7XG4gIH0sXG4gIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG5cbiAgICBpZiAoIXRoaXMuaXNEZXNrdG9wKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0KTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5lc2NGdW5jdGlvbiwgZmFsc2UpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSk7XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgc3JjX2hlbHBlcnMpLCB7fSwge1xuICAgIHRyYW5zZm9ybURpc2FibGVkV2Vla0RheXM6IGZ1bmN0aW9uIHRyYW5zZm9ybURpc2FibGVkV2Vla0RheXMoKSB7fSxcbiAgICBjb25maWd1cmVJMThuOiBmdW5jdGlvbiBjb25maWd1cmVJMThuKCkge1xuICAgICAgbGliX2ZlY2hhLnNldEdsb2JhbERhdGVJMThuKHtcbiAgICAgICAgZGF5TmFtZXM6IHRoaXMuaTE4blsnZGF5LW5hbWVzJ10sXG4gICAgICAgIGRheU5hbWVzU2hvcnQ6IHRoaXMuc2hvcnRlblN0cmluZyh0aGlzLmkxOG5bJ2RheS1uYW1lcyddLCAzKSxcbiAgICAgICAgbW9udGhOYW1lczogdGhpcy5pMThuWydtb250aC1uYW1lcyddLFxuICAgICAgICBtb250aE5hbWVzU2hvcnQ6IHRoaXMuc2hvcnRlblN0cmluZyh0aGlzLmkxOG5bJ21vbnRoLW5hbWVzJ10sIDMpLFxuICAgICAgICBhbVBtOiBbJ2FtJywgJ3BtJ10sXG4gICAgICAgIC8vIEQgaXMgdGhlIGRheSBvZiB0aGUgbW9udGgsIGZ1bmN0aW9uIHJldHVybnMgc29tZXRoaW5nIGxpa2UuLi4gIDNyZCBvciAxMXRoXG4gICAgICAgIERvRm46IGZ1bmN0aW9uIERvRm4oRCkge1xuICAgICAgICAgIHJldHVybiBEICsgWyd0aCcsICdzdCcsICduZCcsICdyZCddW0QgJSAxMCA+IDMgPyAwIDogKEQgLSBEICUgMTAgIT09IDEwKSAqIEQgJSAxMF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2VuZXJhdGVJbml0aWFsTW9udGhzOiBmdW5jdGlvbiBnZW5lcmF0ZUluaXRpYWxNb250aHMoKSB7XG4gICAgICB0aGlzLm1vbnRocyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5jaGVja0luICYmICh0aGlzLmdldE1vbnRoRGlmZih0aGlzLmdldE5leHRNb250aChuZXcgRGF0ZSh0aGlzLnN0YXJ0RGF0ZSkpLCB0aGlzLmNoZWNrSW4pID4gMCB8fCB0aGlzLmdldE1vbnRoRGlmZih0aGlzLnN0YXJ0RGF0ZSwgdGhpcy5jaGVja0luKSA+IDApKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9udGgobmV3IERhdGUodGhpcy5zdGFydERhdGUpKTtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRNb250aERpZmYodGhpcy5zdGFydERhdGUsIHRoaXMuY2hlY2tJbik7XG4gICAgICAgIHZhciBtb250aENvdW50ID0gdGhpcy5zaG93U2luZ2xlTW9udGggPyBjb3VudCAtIDEgOiBjb3VudDtcbiAgICAgICAgdmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHRoaXMuc3RhcnREYXRlKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBtb250aENvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgdGVtcE5leHRNb250aCA9IHRoaXMuZ2V0TmV4dE1vbnRoKG5leHRNb250aCk7XG4gICAgICAgICAgdGhpcy5jcmVhdGVNb250aCh0ZW1wTmV4dE1vbnRoKTtcbiAgICAgICAgICBuZXh0TW9udGggPSB0ZW1wTmV4dE1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tPdXQgJiYgdGhpcy5nZXRNb250aERpZmYodGhpcy5jaGVja0luLCB0aGlzLmNoZWNrT3V0KSA+IDApIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZU1vbnRoKHRoaXMuZ2V0TmV4dE1vbnRoKG5leHRNb250aCkpO1xuICAgICAgICAgIHRoaXMuYWN0aXZlTW9udGhJbmRleCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZU1vbnRoSW5kZXggKz0gY291bnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNyZWF0ZU1vbnRoKG5ldyBEYXRlKHRoaXMuc3RhcnREYXRlKSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNob3dTaW5nbGVNb250aCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlTW9udGgodGhpcy5nZXROZXh0TW9udGgobmV3IERhdGUodGhpcy5zdGFydERhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUJvb2tpbmdDbGlja2VkOiBmdW5jdGlvbiBoYW5kbGVCb29raW5nQ2xpY2tlZChldmVudCwgZGF0ZSwgY3VycmVudEJvb2tpbmcpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2Jvb2tpbmctY2xpY2tlZCcsIGV2ZW50LCBkYXRlLCBjdXJyZW50Qm9va2luZyk7XG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0LjAuMCBiZXRhIDExXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZW1pdCgnYm9va2luZ0NsaWNrZWQnLCBldmVudCwgZGF0ZSwgY3VycmVudEJvb2tpbmcpO1xuICAgIH0sXG4gICAgZXNjRnVuY3Rpb246IGZ1bmN0aW9uIGVzY0Z1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBlc2NUb3VjaCA9IDI3O1xuXG4gICAgICBpZiAoZS5rZXlDb2RlID09PSBlc2NUb3VjaCAmJiB0aGlzLmlzT3BlbiAmJiB0aGlzLmNoZWNrSW4pIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0RGF0ZTogZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5kYXRlRm9ybWF0ZXIoZGF0ZSwgdGhpcy5mb3JtYXQpO1xuICAgIH0sXG4gICAgY2xlYW5TdHJpbmc6IGZ1bmN0aW9uIGNsZWFuU3RyaW5nKHN0cmluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1xcPGJyXFwvPi9nLCAnJyk7XG4gICAgfSxcbiAgICBkYXRlSXNJbkNoZWNrSW5DaGVja091dDogZnVuY3Rpb24gZGF0ZUlzSW5DaGVja0luQ2hlY2tPdXQoZGF0ZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb21wYXJlRGF0ZSA9IHRoaXMuZGF0ZUZvcm1hdGVyKGRhdGUpO1xuICAgICAgdmFyIGN1cnJlbnRQZXJpb2QgPSBudWxsO1xuICAgICAgdGhpcy5zb3J0ZWRQZXJpb2REYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGlmIChkLmVuZEF0ICE9PSBjb21wYXJlRGF0ZSAmJiAoZC5zdGFydEF0ID09PSBjb21wYXJlRGF0ZSB8fCBfdGhpczMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKGQuc3RhcnRBdCwgZC5lbmRBdCwgY29tcGFyZURhdGUpKSkge1xuICAgICAgICAgIGN1cnJlbnRQZXJpb2QgPSBkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJyZW50UGVyaW9kO1xuICAgIH0sXG4gICAgZGF5SXNEaXNhYmxlZDogZnVuY3Rpb24gZGF5SXNEaXNhYmxlZChkYXRlKSB7XG4gICAgICBpZiAodGhpcy5jaGVja0luICYmICF0aGlzLmNoZWNrT3V0ICYmICF0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyhkYXRlLCB0aGlzLm5leHREaXNhYmxlZERhdGUpICYmIHRoaXMubmV4dERpc2FibGVkRGF0ZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNoZWNrSW4gJiYgIXRoaXMuY2hlY2tPdXQgJiYgdGhpcy5pc0RhdGVMZXNzT3JFcXVhbHMoZGF0ZSwgdGhpcy5jaGVja0luKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZW50ZXJNb250aDogZnVuY3Rpb24gZW50ZXJNb250aChldmVudCwgbW9udGgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2VudGVyLW1vbnRoJywgZXZlbnQsIG1vbnRoKTtcbiAgICB9LFxuICAgIGVudGVyRGF5OiBmdW5jdGlvbiBlbnRlckRheShldmVudCwgZGF5KSB7XG4gICAgICB2YXIgZm9ybWF0RGF0ZSA9IHRoaXMuZGF0ZUZvcm1hdGVyKGRheS5kYXRlKTtcbiAgICAgIHZhciBoYWxmRGF5cyA9IE9iamVjdC5rZXlzKHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheSk7XG4gICAgICB2YXIgZGlzYWJsZURheXMgPSB0aGlzLmRpc2FibGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkaXNhYmxlRGF0ZSkge1xuICAgICAgICByZXR1cm4gIWhhbGZEYXlzLmluY2x1ZGVzKGRpc2FibGVEYXRlKTtcbiAgICAgIH0pLmluY2x1ZGVzKGZvcm1hdERhdGUpO1xuXG4gICAgICBpZiAoIXRoaXMuZGF5SXNEaXNhYmxlZChkYXkuZGF0ZSkgJiYgZGF5LmJlbG9uZ3NUb1RoaXNNb250aCAmJiAhZGlzYWJsZURheXMpIHtcbiAgICAgICAgdGhpcy5zZXRDdXN0b21Ub29sdGlwT25Ib3ZlcihkYXkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvdmVyaW5nRGF0ZSA9IHRoaXMuc2luZ2xlRGF5U2VsZWN0aW9uID8gbnVsbCA6IGRheS5kYXRlO1xuICAgICAgdGhpcy4kZW1pdCgnZW50ZXItZGF5JywgZXZlbnQsIGRheSk7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50UGVyaW9kOiBmdW5jdGlvbiBzZXRDdXJyZW50UGVyaW9kKGRhdGUsIGV2ZW50VHlwZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBjdXJyZW50UGVyaW9kID0ge307XG5cbiAgICAgIGlmICh0aGlzLnNvcnRlZFBlcmlvZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zb3J0ZWRQZXJpb2REYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgaWYgKGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyAmJiAoZC5zdGFydEF0ID09PSBfdGhpczQuZGF0ZUZvcm1hdGVyKGRhdGUpIHx8IGQuZW5kQXQgIT09IF90aGlzNC5kYXRlRm9ybWF0ZXIoZGF0ZSkgJiYgX3RoaXM0LnZhbGlkYXRlRGF0ZUJldHdlZW5Ud29EYXRlcyhkLnN0YXJ0QXQsIGQuZW5kQXQsIGRhdGUpKSkge1xuICAgICAgICAgICAgY3VycmVudFBlcmlvZCA9IGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09ICdob3ZlcicgJiYgKGQuc3RhcnRBdCA9PT0gX3RoaXM0LmRhdGVGb3JtYXRlcihkYXRlKSB8fCBfdGhpczQudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKGQuc3RhcnRBdCwgZC5lbmRBdCwgZGF0ZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhjdXJyZW50UGVyaW9kKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5ob3ZlcmluZ1BlcmlvZCA9IGN1cnJlbnRQZXJpb2Q7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5taW5OaWdodENvdW50ID4gMCAmJiB0aGlzLmNoZWNrSW4pIHtcbiAgICAgICAgICB0aGlzLmhvdmVyaW5nUGVyaW9kID0ge1xuICAgICAgICAgICAgcGVyaW9kVHlwZTogJ25pZ2h0bHknLFxuICAgICAgICAgICAgbWluaW11bUR1cmF0aW9uOiB0aGlzLm1pbk5pZ2h0Q291bnQsXG4gICAgICAgICAgICBzdGFydEF0OiB0aGlzLmNoZWNrSW4sXG4gICAgICAgICAgICBlbmRBdDogdGhpcy5hZGREYXlzKHRoaXMuY2hlY2tJbiwgdGhpcy5taW5OaWdodENvdW50KVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ob3ZlcmluZ1BlcmlvZCA9IHtcbiAgICAgICAgICAgIHBlcmlvZFR5cGU6ICduaWdodGx5JyxcbiAgICAgICAgICAgIG1pbmltdW1EdXJhdGlvbjogdGhpcy5taW5OaWdodENvdW50LFxuICAgICAgICAgICAgc3RhcnRBdDogdGhpcy5jaGVja0luLFxuICAgICAgICAgICAgZW5kQXQ6IHRoaXMuYWRkRGF5cyh0aGlzLmNoZWNrSW4sIHRoaXMubWluTmlnaHRDb3VudClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWluTmlnaHRDb3VudCA+IDApIHtcbiAgICAgICAgdGhpcy5ob3ZlcmluZ1BlcmlvZCA9IHtcbiAgICAgICAgICBwZXJpb2RUeXBlOiAnbmlnaHRseScsXG4gICAgICAgICAgbWluaW11bUR1cmF0aW9uOiB0aGlzLm1pbk5pZ2h0Q291bnQsXG4gICAgICAgICAgc3RhcnRBdDogdGhpcy5jaGVja0luLFxuICAgICAgICAgIGVuZEF0OiB0aGlzLmFkZERheXModGhpcy5jaGVja0luLCB0aGlzLm1pbk5pZ2h0Q291bnQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRDdXN0b21Ub29sdGlwT25Ib3ZlcjogZnVuY3Rpb24gc2V0Q3VzdG9tVG9vbHRpcE9uSG92ZXIoZGF5KSB7XG4gICAgICB2YXIgZGF0ZSA9IGRheS5kYXRlO1xuICAgICAgdGhpcy5ob3ZlcmluZ0RhdGUgPSBkYXRlO1xuICAgICAgaWYgKHRoaXMuc2hvd0N1c3RvbVRvb2x0aXApIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFBlcmlvZChkYXRlLCAnaG92ZXInKTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuaG92ZXJpbmdQZXJpb2QpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRvb2x0aXBcbiAgICAgICAgaWYgKHRoaXMuaG92ZXJpbmdQZXJpb2QucGVyaW9kVHlwZSA9PT0gJ3dlZWtseV9ieV9zYXR1cmRheScpIHtcbiAgICAgICAgICB2YXIgZGF5Q29kZSA9IDY7XG4gICAgICAgICAgdmFyIHRleHQgPSB0aGlzLmkxOG4udG9vbHRpcC5zYXR1cmRheVRvU2F0dXJkYXk7XG4gICAgICAgICAgdGhpcy5zaG93VG9vbHRpcFdlZWtseU9uSG92ZXIoZGF0ZSwgZGF5Q29kZSwgdGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3ZlcmluZ1BlcmlvZC5wZXJpb2RUeXBlID09PSAnd2Vla2x5X2J5X3N1bmRheScpIHtcbiAgICAgICAgICB2YXIgX2RheUNvZGUgPSAwO1xuICAgICAgICAgIHZhciBfdGV4dCA9IHRoaXMuaTE4bi50b29sdGlwLnN1bmRheVRvU3VuZGF5O1xuICAgICAgICAgIHRoaXMuc2hvd1Rvb2x0aXBXZWVrbHlPbkhvdmVyKGRhdGUsIF9kYXlDb2RlLCBfdGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3ZlcmluZ1BlcmlvZC5wZXJpb2RUeXBlID09PSAnbmlnaHRseScpIHtcbiAgICAgICAgICB0aGlzLnNob3dUb29sdGlwTmlnaHRseU9uSG92ZXIoZGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYW4gdG9vbHRpcFxuICAgICAgICAgIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ob3ZlcmluZ1BlcmlvZCA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYWxmRGF5KSB7XG4gICAgICAgIHRoaXMuY3JlYXRlSGFsZkRheVRvb2x0aXAoZGF5LmRhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlRGF5Q2xpY2s6IGZ1bmN0aW9uIGhhbmRsZURheUNsaWNrKGV2ZW50LCBkYXRlLCBmb3JtYXREYXRlLCByZXNldENoZWNraW4pIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICB0aGlzLm5leHRQZXJpb2REaXNhYmxlRGF0ZXMgPSBbXTtcblxuICAgICAgaWYgKHJlc2V0Q2hlY2tpbikge1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuaGFuZGxlRGF5Q2xpY2soZXZlbnQsIGRhdGUsIGZvcm1hdERhdGUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHREaXNhYmxlZERhdGUgPSAodGhpcy5tYXhOaWdodHMgPyB0aGlzLmFkZERheXMoZGF0ZSwgdGhpcy5tYXhOaWdodHMgKyAxKSA6IG51bGwpIHx8IHRoaXMuZ2V0TmV4dERhdGUodGhpcy5zb3J0ZWREaXNhYmxlZERhdGVzLCBkYXRlKSB8fCB0aGlzLm5leHREYXRlQnlEYXlPZldlZWtBcnJheSh0aGlzLmRpc2FibGVkV2Vla0RheXNBcnJheSwgZGF0ZSwgdGhpcy5pMThuKSB8fCB0aGlzLm5leHRCb29raW5nRGF0ZShkYXRlKSB8fCBJbmZpbml0eTtcbiAgICAgIHRoaXMuZHluYW1pY05pZ2h0Q291bnRzID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuZW5hYmxlQ2hlY2tvdXQpIHtcbiAgICAgICAgbmV4dERpc2FibGVkRGF0ZSA9IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGVja0luID09IG51bGwgJiYgIXRoaXMuc2luZ2xlRGF5U2VsZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbiA9IGRhdGU7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoZWNrLWluLXNlbGVjdGVkJywgZGF0ZSk7XG4gICAgICAgIHRoaXMuc2V0TWluaW11bUR1cmF0aW9uKGRhdGUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNpbmdsZURheVNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLmNoZWNrSW4gPSBkYXRlO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGVjay1pbi1zZWxlY3RlZCcsIGRhdGUpO1xuICAgICAgICB0aGlzLmNoZWNrT3V0ID0gZGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja0luICE9PSBudWxsICYmIHRoaXMuY2hlY2tPdXQgPT0gbnVsbCAmJiB0aGlzLmlzRGF0ZUxlc3NPckVxdWFscyhkYXRlLCB0aGlzLmNoZWNrSW4pKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbiA9IGRhdGU7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoZWNrLWluLXNlbGVjdGVkJywgZGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tJbiAhPT0gbnVsbCAmJiB0aGlzLmNoZWNrT3V0ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGVja091dCA9IGRhdGU7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3BlcmlvZC1zZWxlY3RlZCcsIGV2ZW50LCB0aGlzLmNoZWNrSW4sIHRoaXMuY2hlY2tPdXQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdjQuMC4wIGJldGEgMTFcbiAgICAgICAgICovXG5cbiAgICAgICAgdGhpcy4kZW1pdCgncGVyaW9kU2VsZWN0ZWQnLCBldmVudCwgdGhpcy5jaGVja0luLCB0aGlzLmNoZWNrT3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hlY2tPdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNoZWNrSW4gPSBkYXRlO1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGVjay1pbi1zZWxlY3RlZCcsIGRhdGUpO1xuICAgICAgICB0aGlzLnNldE1pbmltdW1EdXJhdGlvbihkYXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCkge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRQZXJpb2QoZGF0ZSwgJ2NsaWNrJyk7XG4gICAgICAgIHRoaXMuY2hlY2tJblBlcmlvZCA9IHRoaXMuaG92ZXJpbmdQZXJpb2Q7XG4gICAgICAgIHRoaXMuc2V0Q3VzdG9tVG9vbHRpcE9uQ2xpY2soKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0RGlzYWJsZWREYXRlID0gbmV4dERpc2FibGVkRGF0ZTtcbiAgICAgIHRoaXMuaG92ZXJpbmdEYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaG92ZXJpbmdEYXRlID0gZGF0ZTtcbiAgICAgIHRoaXMuJGVtaXQoJ2RheS1jbGlja2VkJywgZGF0ZSwgZm9ybWF0RGF0ZSwgbmV4dERpc2FibGVkRGF0ZSk7XG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0LjAuMCBiZXRhIDExXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZW1pdCgnZGF5Q2xpY2tlZCcsIGRhdGUsIGZvcm1hdERhdGUsIG5leHREaXNhYmxlZERhdGUpO1xuICAgIH0sXG4gICAgbmV4dEJvb2tpbmdEYXRlOiBmdW5jdGlvbiBuZXh0Qm9va2luZ0RhdGUoZGF0ZSkge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbG9zZXN0ID0gSW5maW5pdHk7XG5cbiAgICAgIGlmICh0aGlzLnNvcnRCb29raW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBuZXh0RGF0ZUZvcm1hdGVkID0gdGhpcy5kYXRlRm9ybWF0ZXIodGhpcy5hZGREYXlzKGRhdGUsIDEpKTtcbiAgICAgICAgdmFyIG5leHRCb29raW5nID0gdGhpcy5zb3J0Qm9va2luZ3MuZmluZChmdW5jdGlvbiAoYm9va2luZykge1xuICAgICAgICAgIHJldHVybiBfdGhpczYudmFsaWRhdGVEYXRlQmV0d2VlbkRhdGUoYm9va2luZy5jaGVja0luRGF0ZSwgbmV4dERhdGVGb3JtYXRlZCkgfHwgX3RoaXM2LnZhbGlkYXRlRGF0ZUJldHdlZW5Ud29EYXRlcyhib29raW5nLmNoZWNrSW5EYXRlLCBib29raW5nLmNoZWNrT3V0RGF0ZSwgbmV4dERhdGVGb3JtYXRlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjbG9zZXN0ID0gbmV4dEJvb2tpbmcgPyBuZXh0Qm9va2luZy5jaGVja0luRGF0ZSA6IEluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuICAgIHNldEN1c3RvbVRvb2x0aXBPbkNsaWNrOiBmdW5jdGlvbiBzZXRDdXN0b21Ub29sdGlwT25DbGljaygpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNoZWNrSW5QZXJpb2QpLmxlbmd0aCA+IDAgJiYgdGhpcy5jaGVja0luUGVyaW9kLnBlcmlvZFR5cGUuaW5jbHVkZXMoJ3dlZWtseScpKSB7XG4gICAgICAgIHZhciBuZXh0VmFsaWREYXRlID0gdGhpcy5hZGREYXlzKHRoaXMuY2hlY2tJbiwgdGhpcy5taW5OaWdodENvdW50KTtcbiAgICAgICAgdGhpcy5jaGVja0luUGVyaW9kLm5leHRWYWxpZERhdGUgPSBuZXh0VmFsaWREYXRlO1xuICAgICAgICB0aGlzLnNob3dUb29sdGlwV2Vla2x5T25DbGljaygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrSW5QZXJpb2QucGVyaW9kVHlwZSA9PT0gJ25pZ2h0bHknKSB7XG4gICAgICAgIHRoaXMuc2hvd1Rvb2x0aXBOaWdodGx5T25DbGljaygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd1Rvb2x0aXBXZWVrbHlPbkhvdmVyOiBmdW5jdGlvbiBzaG93VG9vbHRpcFdlZWtseU9uSG92ZXIoZGF0ZSwgcGVyaW9kRGF5VHlwZSwgdGV4dCkge1xuICAgICAgdmFyIGNvdW50RGF5c0JldHdlZW5DaGVja0luQ3VycmVudERheSA9IHRoaXMuY291bnREYXlzKHRoaXMuY2hlY2tJbiwgZGF0ZSk7XG4gICAgICB2YXIgbm90T25QZXJpb2REYXlUeXBlID0gZGF0ZS5nZXREYXkoKSAhPT0gcGVyaW9kRGF5VHlwZTtcbiAgICAgIHZhciBpc0NoZWNrSW5DaGVja091dCA9IHRoaXMuY2hlY2tJbiAmJiB0aGlzLmNoZWNrT3V0O1xuICAgICAgdmFyIG5vdENoZWNrSW5Ob3RQZXJpb2REYXlUeXBlID0gIXRoaXMuY2hlY2tJbiAmJiBub3RPblBlcmlvZERheVR5cGU7XG4gICAgICB2YXIgaXNDaGVja0luTm90Q2hlY2tPdXQgPSB0aGlzLmNoZWNrSW4gJiYgIXRoaXMuY2hlY2tPdXQ7XG4gICAgICB2YXIgaXNOb3RCZXR3ZWVuQ2hlY2tJbkFuZENoZWNrT3V0ID0gIXRoaXMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKHRoaXMuY2hlY2tJbiwgdGhpcy5jaGVja091dCwgZGF0ZSk7XG4gICAgICB2YXIgbm90QWxsb3dEYXlzQmV0d2VlbkNoZWNrSW5BbmROZXh0VmFsaWREYXRlID0gdGhpcy5ob3ZlcmluZ1BlcmlvZC5uZXh0VmFsaWREYXRlICYmIHRoaXMudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKHRoaXMuY2hlY2tJbiwgdGhpcy5ob3ZlcmluZ1BlcmlvZC5uZXh0VmFsaWREYXRlLCB0aGlzLmhvdmVyaW5nRGF0ZSkgJiYgdGhpcy5kYXRlRm9ybWF0ZXIodGhpcy5jaGVja0luKSAhPT0gdGhpcy5kYXRlRm9ybWF0ZXIodGhpcy5ob3ZlcmluZ0RhdGUpICYmIHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuaG92ZXJpbmdQZXJpb2QubmV4dFZhbGlkRGF0ZSkgIT09IHRoaXMuZGF0ZUZvcm1hdGVyKHRoaXMuaG92ZXJpbmdEYXRlKTtcbiAgICAgIHZhciBoYXNIYWxmRGF5T25XZWVrbHlQZXJpb2QgPSBPYmplY3Qua2V5cyh0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXkpLmxlbmd0aCA+IDAgJiYgdGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W3RoaXMuZGF0ZUZvcm1hdGVyKGRhdGUpXSAmJiB0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXlbdGhpcy5kYXRlRm9ybWF0ZXIoZGF0ZSldLmNoZWNrSW47IC8vIFNob3cgdG9vbHRpcCBvbiBub3QtYWxsb3dlZCBkYXlcblxuICAgICAgaWYgKG5vdENoZWNrSW5Ob3RQZXJpb2REYXlUeXBlKSB7XG4gICAgICAgIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSB0ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93Q3VzdG9tVG9vbHRpcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSAnJztcbiAgICAgIH0gLy8gU2hvdyB0b29sdGlwIHdoZW4gQ2hlY2tJblxuXG5cbiAgICAgIGlmIChpc0NoZWNrSW5Ob3RDaGVja091dCkge1xuICAgICAgICB2YXIgbmV4dERheVZhbGlkID0gdGhpcy5hZGREYXlzKHRoaXMuY2hlY2tJbiwgdGhpcy5taW5OaWdodENvdW50KTtcbiAgICAgICAgdmFyIGlzRGF0ZUFmdGVyTWluaW11bUR1cmF0aW9uID0gdGhpcy5nZXREYXlEaWZmKGRhdGUsIG5leHREYXlWYWxpZCkgPD0gMDtcblxuICAgICAgICBpZiAoaXNEYXRlQWZ0ZXJNaW5pbXVtRHVyYXRpb24gJiYgbm90T25QZXJpb2REYXlUeXBlKSB7XG4gICAgICAgICAgdGhpcy5zaG93Q3VzdG9tVG9vbHRpcCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5jdXN0b21Ub29sdGlwID0gdGV4dDtcbiAgICAgICAgfSBlbHNlIGlmIChub3RPblBlcmlvZERheVR5cGUgfHwgbm90QWxsb3dEYXlzQmV0d2VlbkNoZWNrSW5BbmROZXh0VmFsaWREYXRlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tJblBlcmlvZCAmJiB0aGlzLmNoZWNrSW5QZXJpb2QucGVyaW9kVHlwZSA9PT0gJ25pZ2h0bHknKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dDdXN0b21Ub29sdGlwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSAnJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdyBkZWZhdWx0IG1lc3NhZ2Ugb24gY3VycmVudERheVxuICAgICAgICAgICAgdmFyIG5pZ2h0ID0gdGhpcy5wbHVyYWxpemUodGhpcy5taW5OaWdodENvdW50LCAnd2VlaycpO1xuICAgICAgICAgICAgdGhpcy5zaG93Q3VzdG9tVG9vbHRpcCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSB0aGlzLmNvbXBsZXRlVHJhZCh0aGlzLmkxOG4udG9vbHRpcC5taW5pbXVtUmVxdWlyZWRQZXJpb2QsIHtcbiAgICAgICAgICAgICAgbWluTmlnaHRJblBlcmlvZDogdGhpcy5taW5OaWdodENvdW50IC8gNyxcbiAgICAgICAgICAgICAgbmlnaHQ6IG5pZ2h0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzSGFsZkRheU9uV2Vla2x5UGVyaW9kKSB7XG4gICAgICAgICAgLy8gU2hvdyB0aGUgY29ycmVjdCB3b3JkaW5nIGluIGNvbXBhcmlzb24gdG8gcGVyaW9kVHlwZSBvZiB0aGlzLmNoZWNrSW5QZXJpb2QgZXF1YWwgdG8gXCJuaWdodGx5XCIgLyBcIndlZWtseVwiXG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tJblBlcmlvZC5wZXJpb2RUeXBlICE9PSAnbmlnaHRseScpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcCA9IFwiXCIuY29uY2F0KGNvdW50RGF5c0JldHdlZW5DaGVja0luQ3VycmVudERheSAvIDcsIFwiIFwiKS5jb25jYXQodGhpcy5wbHVyYWxpemUodGhpcy5taW5OaWdodENvdW50LCAnd2VlaycpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tJblBlcmlvZC5wZXJpb2RUeXBlID09PSAnbmlnaHRseScpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcCA9IFwiXCIuY29uY2F0KGNvdW50RGF5c0JldHdlZW5DaGVja0luQ3VycmVudERheSwgXCIgXCIpLmNvbmNhdChjb3VudERheXNCZXR3ZWVuQ2hlY2tJbkN1cnJlbnREYXkgIT09IDEgPyB0aGlzLmkxOG4ubmlnaHRzIDogdGhpcy5pMThuLm5pZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xlYW4gdG9vbHRpcFxuICAgICAgICAgIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSAnJztcbiAgICAgICAgfSAvLyBTaG93IHRvb2x0aXAgd2hlbiBDaGVja0luICYgQ2hlY2tPdXQgb24gYWxsIHRoZSBkYXlzIHRoYXQgYXJlIG5vdCBiZXR3ZWVuIGNoZWNrSW4gYW5kIENoZWNrT3V0XG5cbiAgICAgIH0gZWxzZSBpZiAoaXNDaGVja0luQ2hlY2tPdXQgJiYgbm90T25QZXJpb2REYXlUeXBlICYmIGlzTm90QmV0d2VlbkNoZWNrSW5BbmRDaGVja091dCkge1xuICAgICAgICB0aGlzLnNob3dDdXN0b21Ub29sdGlwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXN0b21Ub29sdGlwID0gdGV4dDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dUb29sdGlwV2Vla2x5T25DbGljazogZnVuY3Rpb24gc2hvd1Rvb2x0aXBXZWVrbHlPbkNsaWNrKCkge1xuICAgICAgdmFyIG5pZ2h0ID0gdGhpcy5wbHVyYWxpemUodGhpcy5taW5OaWdodENvdW50LCAnd2VlaycpO1xuICAgICAgdGhpcy5zaG93Q3VzdG9tVG9vbHRpcCA9IHRydWU7XG4gICAgICB0aGlzLmN1c3RvbVRvb2x0aXAgPSB0aGlzLmNvbXBsZXRlVHJhZCh0aGlzLmkxOG4udG9vbHRpcC5taW5pbXVtUmVxdWlyZWRQZXJpb2QsIHtcbiAgICAgICAgbWluTmlnaHRJblBlcmlvZDogdGhpcy5taW5OaWdodENvdW50IC8gNyxcbiAgICAgICAgbmlnaHQ6IG5pZ2h0XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNob3dUb29sdGlwTmlnaHRseU9uSG92ZXI6IGZ1bmN0aW9uIHNob3dUb29sdGlwTmlnaHRseU9uSG92ZXIoZGF0ZSkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCkge1xuICAgICAgICB2YXIgbmV4dERheVZhbGlkID0gdGhpcy5hZGREYXlzKHRoaXMuY2hlY2tJbiwgdGhpcy5taW5OaWdodENvdW50KTtcbiAgICAgICAgdmFyIGlzRGF0ZUFmdGVyTWluaW11bUR1cmF0aW9uID0gdGhpcy5nZXREYXlEaWZmKGRhdGUsIG5leHREYXlWYWxpZCkgPD0gMDtcbiAgICAgICAgdmFyIGNvdW50T2ZEYXlzID0gdGhpcy5jb3VudERheXModGhpcy5jaGVja0luLCBkYXRlKTtcbiAgICAgICAgdmFyIG5pZ2h0ID0gdGhpcy5wbHVyYWxpemUoTWF0aC5tYXgodGhpcy5taW5OaWdodENvdW50LCBjb3VudE9mRGF5cykpO1xuXG4gICAgICAgIGlmICghaXNEYXRlQWZ0ZXJNaW5pbXVtRHVyYXRpb24pIHtcbiAgICAgICAgICB2YXIgbWluTmlnaHRJblBlcmlvZCA9IHRoaXMuaG92ZXJpbmdQZXJpb2QubWluaW11bUR1cmF0aW9uO1xuICAgICAgICAgIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcCA9IHRoaXMuY29tcGxldGVUcmFkKHRoaXMuaTE4bi50b29sdGlwLm1pbmltdW1SZXF1aXJlZFBlcmlvZCwge1xuICAgICAgICAgICAgbWluTmlnaHRJblBlcmlvZDogbWluTmlnaHRJblBlcmlvZCxcbiAgICAgICAgICAgIG5pZ2h0OiBuaWdodFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcCA9IFwiXCIuY29uY2F0KGNvdW50T2ZEYXlzLCBcIiBcIikuY29uY2F0KG5pZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXN0b21Ub29sdGlwID0gJyc7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93VG9vbHRpcE5pZ2h0bHlPbkNsaWNrOiBmdW5jdGlvbiBzaG93VG9vbHRpcE5pZ2h0bHlPbkNsaWNrKCkge1xuICAgICAgdmFyIG1pbk5pZ2h0SW5QZXJpb2QgPSB0aGlzLmhvdmVyaW5nUGVyaW9kLm1pbmltdW1EdXJhdGlvbjtcbiAgICAgIHZhciBuaWdodCA9IHRoaXMucGx1cmFsaXplKHRoaXMubWluTmlnaHRDb3VudCk7XG4gICAgICB0aGlzLnNob3dDdXN0b21Ub29sdGlwID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcCA9IHRoaXMuY29tcGxldGVUcmFkKHRoaXMuaTE4bi50b29sdGlwLm1pbmltdW1SZXF1aXJlZFBlcmlvZCwge1xuICAgICAgICBtaW5OaWdodEluUGVyaW9kOiBtaW5OaWdodEluUGVyaW9kLFxuICAgICAgICBuaWdodDogbmlnaHRcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgY3JlYXRlSGFsZkRheVRvb2x0aXA6IGZ1bmN0aW9uIGNyZWF0ZUhhbGZEYXlUb29sdGlwKGRhdGUpIHtcbiAgICAgIHRoaXMuY3VzdG9tVG9vbHRpcEhhbGZkYXkgPSAnJztcbiAgICAgIHZhciBmb3JtYXRlZEhvdmVyaW5nRGF0ZSA9IHRoaXMuZGF0ZUZvcm1hdGVyKGRhdGUpO1xuXG4gICAgICBpZiAodGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W2Zvcm1hdGVkSG92ZXJpbmdEYXRlXSkge1xuICAgICAgICB0aGlzLnNob3dDdXN0b21Ub29sdGlwID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jaGVja0luY2hlY2tPdXRIYWxmRGF5W2Zvcm1hdGVkSG92ZXJpbmdEYXRlXS5jaGVja0luKSB7XG4gICAgICAgICAgdGhpcy5jdXN0b21Ub29sdGlwSGFsZmRheSA9IHRoaXMuaTE4bi50b29sdGlwLmhhbGZEYXlDaGVja091dDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrSW5jaGVja091dEhhbGZEYXlbZm9ybWF0ZWRIb3ZlcmluZ0RhdGVdLmNoZWNrT3V0KSB7XG4gICAgICAgICAgdGhpcy5jdXN0b21Ub29sdGlwSGFsZmRheSA9IHRoaXMuaTE4bi50b29sdGlwLmhhbGZEYXlDaGVja0luO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wbGV0ZVRyYWQ6IGZ1bmN0aW9uIGNvbXBsZXRlVHJhZCh0cmFuc2xhdGlvbiwga2V5cykge1xuICAgICAgdmFyIG5ld1QgPSB0cmFuc2xhdGlvbjtcbiAgICAgIHZhciBrZXlzVHJhbnNsYXRpb25zID0gT2JqZWN0LmtleXMoa2V5cyk7XG4gICAgICBrZXlzVHJhbnNsYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBuZXdUID0gbmV3VC5yZXBsYWNlKFwiJXtcIi5jb25jYXQoa2V5LCBcIn1cIiksIGtleXNba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdUO1xuICAgIH0sXG4gICAgaGFuZGxlQ2xpY2tPdXRzaWRlOiBmdW5jdGlvbiBoYW5kbGVDbGlja091dHNpZGUoZXZlbnQpIHtcbiAgICAgIHZhciBpZ25vcmVDbGlja09uTWVFbGVtZW50ID0gdGhpcy4kcmVmc1tcIkRhdGVQaWNrZXItXCIuY29uY2F0KHRoaXMuaGFzaCldO1xuXG4gICAgICBpZiAoaWdub3JlQ2xpY2tPbk1lRWxlbWVudCkge1xuICAgICAgICB2YXIgaXNDbGlja0luc2lkZUVsZW1lbnQgPSBpZ25vcmVDbGlja09uTWVFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgaWYgKCFpc0NsaWNrSW5zaWRlRWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuaGlkZURhdGVwaWNrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBmdW5jdGlvbiBoYW5kbGVXaW5kb3dSZXNpemUoKSB7XG4gICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPCA0ODApIHtcbiAgICAgICAgdGhpcy5zY3JlZW5TaXplID0gJ3NtYXJ0cGhvbmUnO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+PSA0ODAgJiYgd2luZG93LmlubmVyV2lkdGggPCA3NjgpIHtcbiAgICAgICAgdGhpcy5zY3JlZW5TaXplID0gJ3RhYmxldCc7XG4gICAgICB9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoID49IDc2OCkge1xuICAgICAgICB0aGlzLnNjcmVlblNpemUgPSAnZGVza3RvcCc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnNjcmVlblNpemU7XG4gICAgfSxcbiAgICBvbkVsZW1lbnRIZWlnaHRDaGFuZ2U6IGZ1bmN0aW9uIG9uRWxlbWVudEhlaWdodENoYW5nZShlbCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsYXN0SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgdmFyIG5ld0hlaWdodCA9IGxhc3RIZWlnaHQ7XG4gICAgICB2YXIgbmV3RWwgPSBlbDtcblxuICAgICAgKGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgICAgbmV3SGVpZ2h0ID0gZWwuY2xpZW50SGVpZ2h0O1xuXG4gICAgICAgIGlmIChsYXN0SGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEhlaWdodCA9IG5ld0hlaWdodDtcblxuICAgICAgICBpZiAobmV3RWwub25FbGVtZW50SGVpZ2h0Q2hhbmdlVGltZXIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZWwub25FbGVtZW50SGVpZ2h0Q2hhbmdlVGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3RWwub25FbGVtZW50SGVpZ2h0Q2hhbmdlVGltZXIgPSBzZXRUaW1lb3V0KHJ1biwgMTAwMCk7XG4gICAgICB9KSgpO1xuICAgIH0sXG4gICAgZW1pdEhlaWdoQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uIGVtaXRIZWlnaENoYW5nZUV2ZW50KCkge1xuICAgICAgdGhpcy4kZW1pdCgnaGVpZ2h0LWNoYW5nZWQnKTtcbiAgICB9LFxuICAgIHJlUmVuZGVyOiBmdW5jdGlvbiByZVJlbmRlcigpIHtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlckRheUtleSArPSAxO1xuICAgICAgdGhpcy5kYXRlcGlja2VyTW9udGhLZXkgKz0gMTtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlcldlZWtLZXkgKz0gMTtcbiAgICB9LFxuICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgIHRoaXMuaG92ZXJpbmdEYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuY2hlY2tJbiA9IG51bGw7XG4gICAgICB0aGlzLmNoZWNrT3V0ID0gbnVsbDtcbiAgICAgIHRoaXMubmV4dERpc2FibGVkRGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLm5leHRQZXJpb2REaXNhYmxlRGF0ZXMgPSBbXTtcbiAgICAgIHRoaXMuc2hvd0N1c3RvbVRvb2x0aXAgPSBmYWxzZTtcbiAgICAgIHRoaXMuaG92ZXJpbmdQZXJpb2QgPSB7fTtcbiAgICAgIHRoaXMuY2hlY2tJblBlcmlvZCA9IHt9O1xuICAgICAgdGhpcy5jcmVhdGVIYWxmRGF5RGF0ZXModGhpcy5iYXNlSGFsZkRheURhdGVzKTtcbiAgICAgIHRoaXMucmVSZW5kZXIoKTtcbiAgICAgIHRoaXMuJGVtaXQoJ2NsZWFyLXNlbGVjdGlvbicpO1xuICAgIH0sXG4gICAgY2xvc2VNb2JpbGVEYXRlcGlja2VyOiBmdW5jdGlvbiBjbG9zZU1vYmlsZURhdGVwaWNrZXIoKSB7XG4gICAgICB0aGlzLmhpZGVEYXRlcGlja2VyKCk7XG4gICAgfSxcbiAgICBoaWRlRGF0ZXBpY2tlcjogZnVuY3Rpb24gaGlkZURhdGVwaWNrZXIoKSB7XG4gICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgIH0sXG4gICAgc2hvd0RhdGVwaWNrZXI6IGZ1bmN0aW9uIHNob3dEYXRlcGlja2VyKCkge1xuICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgdG9nZ2xlRGF0ZXBpY2tlcjogZnVuY3Rpb24gdG9nZ2xlRGF0ZXBpY2tlcigpIHtcbiAgICAgIHRoaXNbdGhpcy5pc09wZW4gPyAnaGlkZURhdGVwaWNrZXInIDogJ3Nob3dEYXRlcGlja2VyJ10oKTtcbiAgICB9LFxuICAgIGNsZWFyQ2hlY2tJbjogZnVuY3Rpb24gY2xlYXJDaGVja0luKCkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCkge1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGlja091dHNpZGU6IGZ1bmN0aW9uIGNsaWNrT3V0c2lkZSgpIHtcbiAgICAgIGlmICh0aGlzLmNsb3NlRGF0ZXBpY2tlck9uQ2xpY2tPdXRzaWRlKSB7XG4gICAgICAgIHRoaXMuaGlkZURhdGVwaWNrZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldE1pbmltdW1EdXJhdGlvbjogZnVuY3Rpb24gc2V0TWluaW11bUR1cmF0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zb3J0ZWRQZXJpb2REYXRlcykge1xuICAgICAgICB2YXIgbmV4dFBlcmlvZCA9IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50UGVyaW9kID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbXBhcmVEYXRlID0gdGhpcy5kYXRlRm9ybWF0ZXIoZGF0ZSk7XG4gICAgICAgIHRoaXMuc29ydGVkUGVyaW9kRGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGlmIChkLmVuZEF0ICE9PSBjb21wYXJlRGF0ZSAmJiAoZC5zdGFydEF0ID09PSBjb21wYXJlRGF0ZSB8fCBfdGhpczcudmFsaWRhdGVEYXRlQmV0d2VlblR3b0RhdGVzKGQuc3RhcnRBdCwgZC5lbmRBdCwgZGF0ZSkpKSB7XG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjdXJyZW50UGVyaW9kKSB7XG4gICAgICAgICAgdGhpcy5zb3J0ZWRQZXJpb2REYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChwZXJpb2QpIHtcbiAgICAgICAgICAgIGlmIChwZXJpb2Quc3RhcnRBdCA9PT0gY3VycmVudFBlcmlvZC5lbmRBdCkge1xuICAgICAgICAgICAgICBuZXh0UGVyaW9kID0gcGVyaW9kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY2hlY2tJbiAmJiAhdGhpcy5jaGVja091dCAmJiBuZXh0UGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZW5kTmV4dFBlcmlvZCA9IHRoaXMuYWRkRGF5cyhuZXh0UGVyaW9kLnN0YXJ0QXQsIG5leHRQZXJpb2QubWluaW11bUR1cmF0aW9uIC0gMSk7XG4gICAgICAgICAgICB2YXIgc3RhcnROZXh0UGVyaW9kUGx1c09uZSA9IHRoaXMuYWRkRGF5cyhuZXh0UGVyaW9kLnN0YXJ0QXQsIDEpO1xuICAgICAgICAgICAgdmFyIG5ld0Rpc2FibGVzRGF0ZXMgPSB0aGlzLmdldERheXNBcnJheShzdGFydE5leHRQZXJpb2RQbHVzT25lLCBlbmROZXh0UGVyaW9kKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFBlcmlvZERpc2FibGVEYXRlcyA9IG5ld0Rpc2FibGVzRGF0ZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QucGVyaW9kVHlwZSA9PT0gJ25pZ2h0bHknICYmIGN1cnJlbnRQZXJpb2QuZW5kQXQgIT09IGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY05pZ2h0Q291bnRzID0gY3VycmVudFBlcmlvZC5taW5pbXVtRHVyYXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QucGVyaW9kVHlwZSA9PT0gJ3dlZWtseV9ieV9zYXR1cmRheScgfHwgY3VycmVudFBlcmlvZC5wZXJpb2RUeXBlID09PSAnd2Vla2x5X2J5X3N1bmRheScpIHtcbiAgICAgICAgICAgIHZhciBtaW5pbXVtRHVyYXRpb24gPSBjdXJyZW50UGVyaW9kLm1pbmltdW1EdXJhdGlvbiAqIDc7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNOaWdodENvdW50cyA9IG1pbmltdW1EdXJhdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5keW5hbWljTmlnaHRDb3VudHMgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJQcmV2aW91c01vbnRoOiBmdW5jdGlvbiByZW5kZXJQcmV2aW91c01vbnRoKCkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZlTW9udGhJbmRleCA+PSAxKSB7XG4gICAgICAgIHZhciBmaXJzdERheU9mTGFzdE1vbnRoID0gdGhpcy5tb250aHNbdGhpcy5hY3RpdmVNb250aEluZGV4XS5kYXlzLmZpbHRlcihmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgcmV0dXJuIGRheS5iZWxvbmdzVG9UaGlzTW9udGggPT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldmlvdXNNb250aCA9IHRoaXMuZ2V0UHJldmlvdXNNb250aChmaXJzdERheU9mTGFzdE1vbnRoWzBdLmRhdGUpO1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnRoSW5kZXgtLTtcbiAgICAgICAgdGhpcy4kZW1pdCgncHJldmlvdXMtbW9udGgtcmVuZGVyZWQnLCBwcmV2aW91c01vbnRoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlck5leHRNb250aDogbG9kYXNoX3Rocm90dGxlX2RlZmF1bHQoKShmdW5jdGlvbiB0aHJvdHRsZVJlbmRlck5leHRNb250aCgpIHtcbiAgICAgIGlmICghdGhpcy5zaG93U2luZ2xlTW9udGggJiYgdGhpcy5hY3RpdmVNb250aEluZGV4IDwgdGhpcy5tb250aHMubGVuZ3RoIC0gMiB8fCB0aGlzLnNob3dTaW5nbGVNb250aCAmJiB0aGlzLmFjdGl2ZU1vbnRoSW5kZXggPCB0aGlzLm1vbnRocy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9udGhJbmRleCsrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdERheU9mTGFzdE1vbnRoO1xuXG4gICAgICBpZiAoIXRoaXMuaXNEZXNrdG9wIHx8IHRoaXMuc2hvd1NpbmdsZU1vbnRoKSB7XG4gICAgICAgIGZpcnN0RGF5T2ZMYXN0TW9udGggPSB0aGlzLm1vbnRoc1t0aGlzLm1vbnRocy5sZW5ndGggLSAxXS5kYXlzLmZpbHRlcihmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgcmV0dXJuIGRheS5iZWxvbmdzVG9UaGlzTW9udGggPT09IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3REYXlPZkxhc3RNb250aCA9IHRoaXMubW9udGhzW3RoaXMuYWN0aXZlTW9udGhJbmRleCArIDFdLmRheXMuZmlsdGVyKGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICByZXR1cm4gZGF5LmJlbG9uZ3NUb1RoaXNNb250aCA9PT0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuZERhdGUgIT09IEluZmluaXR5KSB7XG4gICAgICAgIGlmIChsaWJfZmVjaGEuZm9ybWF0KGZpcnN0RGF5T2ZMYXN0TW9udGhbMF0uZGF0ZSwgJ1lZWVlNTScpID09PSBsaWJfZmVjaGEuZm9ybWF0KG5ldyBEYXRlKHRoaXMuZW5kRGF0ZSksICdZWVlZTU0nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dE1vbnRoID0gdGhpcy5nZXROZXh0TW9udGgoZmlyc3REYXlPZkxhc3RNb250aFswXS5kYXRlKTtcbiAgICAgIHRoaXMuY3JlYXRlTW9udGgobmV4dE1vbnRoKTtcbiAgICAgIHRoaXMuYWN0aXZlTW9udGhJbmRleCsrO1xuICAgICAgdGhpcy4kZW1pdCgnbmV4dC1tb250aC1yZW5kZXJlZCcsIG5leHRNb250aCk7XG4gICAgfSwgMzUwKSxcbiAgICBzZXRDaGVja0luOiBmdW5jdGlvbiBzZXRDaGVja0luKGRhdGUpIHtcbiAgICAgIHRoaXMuY2hlY2tJbiA9IGRhdGU7XG4gICAgfSxcbiAgICBzZXRDaGVja091dDogZnVuY3Rpb24gc2V0Q2hlY2tPdXQoZGF0ZSkge1xuICAgICAgdGhpcy5jaGVja091dCA9IGRhdGU7XG4gICAgfSxcbiAgICBjcmVhdGVNb250aDogZnVuY3Rpb24gY3JlYXRlTW9udGgoZGF0ZSkge1xuICAgICAgdmFyIGZpcnN0RGF5ID0gdGhpcy5nZXRGaXJzdERheShkYXRlLCB0aGlzLmZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgIHZhciBtb250aCA9IHtcbiAgICAgICAgZGF5czogW11cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDI7IGkrKykge1xuICAgICAgICBtb250aC5kYXlzLnB1c2goe1xuICAgICAgICAgIGRhdGU6IHRoaXMuYWRkRGF5cyhmaXJzdERheSwgaSksXG4gICAgICAgICAgYmVsb25nc1RvVGhpc01vbnRoOiB0aGlzLmFkZERheXMoZmlyc3REYXksIGkpLmdldE1vbnRoKCkgPT09IGRhdGUuZ2V0TW9udGgoKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb250aHMucHVzaChtb250aCk7XG4gICAgfSxcbiAgICBjcmVhdGVIYWxmRGF5RGF0ZXM6IGZ1bmN0aW9uIGNyZWF0ZUhhbGZEYXlEYXRlcyhfYmFzZUhhbGZEYXlEYXRlcykge1xuICAgICAgdmFyIHNvcnRlZERhdGVzID0gW107XG4gICAgICB2YXIgY2hlY2tJbmNoZWNrT3V0SGFsZkRheSA9IHt9O1xuXG4gICAgICB2YXIgYmFzZUhhbGZEYXlEYXRlcyA9IF90b0NvbnN1bWFibGVBcnJheShfYmFzZUhhbGZEYXlEYXRlcyk7IC8vIFNvcnRlZCBkaXNhYmxlZERhdGVzXG5cblxuICAgICAgYmFzZUhhbGZEYXlEYXRlcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhYSA9IGEuc3BsaXQoJy8nKS5yZXZlcnNlKCkuam9pbigpO1xuICAgICAgICB2YXIgYmIgPSBiLnNwbGl0KCcvJykucmV2ZXJzZSgpLmpvaW4oKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG5cbiAgICAgICAgcmV0dXJuIGFhIDwgYmIgPyAtMSA6IGFhID4gYmIgPyAxIDogMDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5zb3J0Qm9va2luZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZUhhbGZEYXlEYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdEYXRlID0gYmFzZUhhbGZEYXlEYXRlc1tpXTtcblxuICAgICAgICAgIGlmICh0aGlzLmhhbGZEYXkpIHtcbiAgICAgICAgICAgIHZhciBuZXdEYXRlSW5jcmVtZW50T25lID0gYmFzZUhhbGZEYXlEYXRlc1tpICsgMV07XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIGNoZWNrSW5jaGVja091dEhhbGZEYXlbbmV3RGF0ZV0gPSB7XG4gICAgICAgICAgICAgICAgY2hlY2tJbjogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNoZWNrSW5jaGVja091dEhhbGZEYXlbbmV3RGF0ZV0gJiYgYmFzZUhhbGZEYXlEYXRlc1tpICsgMV0gJiYgdGhpcy5nZXREYXlEaWZmKG5ld0RhdGUsIG5ld0RhdGVJbmNyZW1lbnRPbmUpID4gMSkge1xuICAgICAgICAgICAgICBjaGVja0luY2hlY2tPdXRIYWxmRGF5W25ld0RhdGVdID0ge1xuICAgICAgICAgICAgICAgIGNoZWNrT3V0OiB0cnVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNoZWNrSW5jaGVja091dEhhbGZEYXlbbmV3RGF0ZUluY3JlbWVudE9uZV0gPSB7XG4gICAgICAgICAgICAgICAgY2hlY2tJbjogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaSA9PT0gYmFzZUhhbGZEYXlEYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgIGNoZWNrSW5jaGVja091dEhhbGZEYXlbYmFzZUhhbGZEYXlEYXRlc1tiYXNlSGFsZkRheURhdGVzLmxlbmd0aCAtIDFdXSA9IHtcbiAgICAgICAgICAgICAgICBjaGVja091dDogdHJ1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvcnRlZERhdGVzW2ldID0gYmFzZUhhbGZEYXlEYXRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zb3J0Qm9va2luZ3MuZm9yRWFjaChmdW5jdGlvbiAoYm9va2luZykge1xuICAgICAgICAgIGNoZWNrSW5jaGVja091dEhhbGZEYXlbYm9va2luZy5jaGVja0luRGF0ZV0gPSB7XG4gICAgICAgICAgICBjaGVja0luOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjaGVja0luY2hlY2tPdXRIYWxmRGF5W2Jvb2tpbmcuY2hlY2tPdXREYXRlXSA9IHtcbiAgICAgICAgICAgIGNoZWNrT3V0OiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhbGZEYXkpIHtcbiAgICAgICAgdmFyIGhhbGZEYXlzID0gT2JqZWN0LmtleXMoY2hlY2tJbmNoZWNrT3V0SGFsZkRheSk7XG4gICAgICAgIHNvcnRlZERhdGVzID0gc29ydGVkRGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuICFoYWxmRGF5cy5pbmNsdWRlcyhkYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHNvcnRlZERhdGVzID0gc29ydGVkRGF0ZXMubWFwKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zb3J0ZWREaXNhYmxlZERhdGVzID0gc29ydGVkRGF0ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheSA9IGNoZWNrSW5jaGVja091dEhhbGZEYXk7XG4gICAgICB0aGlzLiRlbWl0KCdoYW5kbGUtY2hlY2tpbi1jaGVja291dC1oYWxmLWRheScsIHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheSk7XG4gICAgICAvKipcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY0LjAuMCBiZXRhIDExXG4gICAgICAgKi9cblxuICAgICAgdGhpcy4kZW1pdCgnaGFuZGxlQ2hlY2tpbkNoZWNrb3V0SGFsZkRheScsIHRoaXMuY2hlY2tJbmNoZWNrT3V0SGFsZkRheSk7XG4gICAgfVxuICB9KVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL0hvdGVsRGF0ZVBpY2tlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4gLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgRGF0ZVBpY2tlcl9Ib3RlbERhdGVQaWNrZXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoSG90ZWxEYXRlUGlja2VydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9EYXRlUGlja2VyL0hvdGVsRGF0ZVBpY2tlci52dWVcblxuXG5cblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5cbnZhciBIb3RlbERhdGVQaWNrZXJfY29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBEYXRlUGlja2VyX0hvdGVsRGF0ZVBpY2tlcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBIb3RlbERhdGVQaWNrZXIgPSAoSG90ZWxEYXRlUGlja2VyX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvYXNzZXRzL3Njc3MvaW5kZXguc2Nzc1xudmFyIHNjc3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTQxYlwiKTtcbnZhciBzY3NzX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHNjc3MpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9pbmRleC5qc1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY18wID0gKEhvdGVsRGF0ZVBpY2tlcik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzLy5wbnBtL0B2dWUrY2xpLXNlcnZpY2VANC41LjEzXzBmMjVkMWFhODQxNWU5OGMzZTYyYTQxNzhmM2M1NTVkL25vZGVfbW9kdWxlcy9AdnVlL2NsaS1zZXJ2aWNlL2xpYi9jb21tYW5kcy9idWlsZC9lbnRyeS1saWIuanNcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlbnRyeV9saWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChzcmNfMCk7XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIzZTQwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIFRPRE86IHVzZSBzb21ldGhpbmcgbW9yZSBjb21wbGV4IGxpa2UgdGltc29ydD9cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIG1lcmdlU29ydChhcnJheS5zbGljZSgwLCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIG1lcmdlU29ydChhcnJheS5zbGljZShtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBpZiAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10pO1xuICAgIH1cbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZVNvcnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2Y1ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4MjZcIik7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwZmM0XCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYTg2XCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEwNzhcIik7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiM2Y3OFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkYzZcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpIEMgPSB1bmRlZmluZWQ7XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBuZXcgKEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQykobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQwNjVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkYzZcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjk5YzdcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThhZFwiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjFiNVwiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxMDc4XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdlNFwiKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIG5hdGl2ZVNsaWNlID0gW10uc2xpY2U7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIENvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQxODdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNWNmXCIpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGZjNFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWE4NlwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZWE4XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0MmExXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1MTdcIik7XG52YXIgd2hpdGVzcGFjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWJmZFwiKTtcblxudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyArICddJztcbnZhciBsdHJpbSA9IFJlZ0V4cCgnXicgKyB3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAod2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKiQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltLCB0cmltU3RhcnQsIHRyaW1FbmQsIHRyaW1MZWZ0LCB0cmltUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQzYzZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby1hc3NlcnRpb24tY2FwdHVyaW5nLWdyb3VwLCByZWdleHAvbm8tZW1wdHktZ3JvdXAsIHJlZ2V4cC9uby1sYXp5LWVuZHMgLS0gdGVzdGluZyAqL1xuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLXVzZWxlc3MtcXVhbnRpZmllciAtLSB0ZXN0aW5nICovXG52YXIgcmVnZXhwRmxhZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjExYVwiKTtcbnZhciBzdGlja3lIZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYwNWJcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjNDBcIik7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhMjNcIik7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmYjU5XCIpLmdldDtcbnZhciBVTlNVUFBPUlRFRF9ET1RfQUxMID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI5ZDJcIik7XG52YXIgVU5TVVBQT1JURURfTkNHID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjljY2RcIik7XG5cbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG5cbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG5cbnZhciBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUxID0gL2EvO1xuICB2YXIgcmUyID0gL2IqL2c7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTEsICdhJyk7XG4gIG5hdGl2ZUV4ZWMuY2FsbChyZTIsICdhJyk7XG4gIHJldHVybiByZTEubGFzdEluZGV4ICE9PSAwIHx8IHJlMi5sYXN0SW5kZXggIT09IDA7XG59KSgpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWSB8fCBzdGlja3lIZWxwZXJzLkJST0tFTl9DQVJFVDtcblxuLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXAsIGNvcGllZCBmcm9tIGVzNS1zaGltJ3MgU3RyaW5nI3NwbGl0IHBhdGNoLlxudmFyIE5QQ0dfSU5DTFVERUQgPSAvKCk/Py8uZXhlYygnJylbMV0gIT09IHVuZGVmaW5lZDtcblxudmFyIFBBVENIID0gVVBEQVRFU19MQVNUX0lOREVYX1dST05HIHx8IE5QQ0dfSU5DTFVERUQgfHwgVU5TVVBQT1JURURfWSB8fCBVTlNVUFBPUlRFRF9ET1RfQUxMIHx8IFVOU1VQUE9SVEVEX05DRztcblxuaWYgKFBBVENIKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50cyAtLSBUT0RPXG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocmUpO1xuICAgIHZhciByYXcgPSBzdGF0ZS5yYXc7XG4gICAgdmFyIHJlc3VsdCwgcmVDb3B5LCBsYXN0SW5kZXgsIG1hdGNoLCBpLCBvYmplY3QsIGdyb3VwO1xuXG4gICAgaWYgKHJhdykge1xuICAgICAgcmF3Lmxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgIHJlc3VsdCA9IHBhdGNoZWRFeGVjLmNhbGwocmF3LCBzdHIpO1xuICAgICAgcmUubGFzdEluZGV4ID0gcmF3Lmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGdyb3VwcyA9IHN0YXRlLmdyb3VwcztcbiAgICB2YXIgc3RpY2t5ID0gVU5TVVBQT1JURURfWSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gcmVnZXhwRmxhZ3MuY2FsbChyZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IGZsYWdzLnJlcGxhY2UoJ3knLCAnJyk7XG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZignZycpID09PSAtMSkge1xuICAgICAgICBmbGFncyArPSAnZyc7XG4gICAgICB9XG5cbiAgICAgIHN0ckNvcHkgPSBTdHJpbmcoc3RyKS5zbGljZShyZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgc3RyW3JlLmxhc3RJbmRleCAtIDFdICE9PSAnXFxuJykpIHtcbiAgICAgICAgc291cmNlID0gJyg/OiAnICsgc291cmNlICsgJyknO1xuICAgICAgICBzdHJDb3B5ID0gJyAnICsgc3RyQ29weTtcbiAgICAgICAgY2hhcnNBZGRlZCsrO1xuICAgICAgfVxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIHN0ciBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBzb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICB9XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyBzb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmUubGFzdEluZGV4O1xuXG4gICAgbWF0Y2ggPSBuYXRpdmVFeGVjLmNhbGwoc3RpY2t5ID8gcmVDb3B5IDogcmUsIHN0ckNvcHkpO1xuXG4gICAgaWYgKHN0aWNreSkge1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoLmlucHV0ID0gbWF0Y2guaW5wdXQuc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoY2hhcnNBZGRlZCk7XG4gICAgICAgIG1hdGNoLmluZGV4ID0gcmUubGFzdEluZGV4O1xuICAgICAgICByZS5sYXN0SW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgfSBlbHNlIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCAmJiBncm91cHMpIHtcbiAgICAgIG1hdGNoLmdyb3VwcyA9IG9iamVjdCA9IGNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ0MzBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzE0OFwiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDMwOFwiKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSlcbiAgICA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0NTkwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjODI2XCIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzY5MlwiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjFiNVwiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNDg4XCIpLmY7XG5cbi8vIGBPYmplY3QueyBlbnRyaWVzLCB2YWx1ZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUT19FTlRSSUVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChPLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4gIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYE9iamVjdC52YWx1ZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiAgdmFsdWVzOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ1YmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzA4XCIpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjBlZFwiKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDY4ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3ZTZmXCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDkzYVwiKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNDgyN1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3YWVcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwZDBcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMGVkXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmI1OVwiKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnICYmICFoYXModmFsdWUsICduYW1lJykpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBrZXkpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjQ5NmFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzVjZlwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjFkY1wiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0YTlmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5NWNcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzVjZlwiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjZWE4XCIpLmY7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjOTRcIik7XG52YXIgRlJFRVpJTkcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjFjZlwiKTtcblxudmFyIE1FVEFEQVRBID0gdWlkKCdtZXRhJyk7XG52YXIgaWQgPSAwO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIGRlZmluZVByb3BlcnR5KGl0LCBNRVRBREFUQSwgeyB2YWx1ZToge1xuICAgIG9iamVjdElEOiAnTycgKyBpZCsrLCAvLyBvYmplY3QgSURcbiAgICB3ZWFrRGF0YToge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG5cbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG59O1xuXG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQURBVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59O1xuXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpJTkcgJiYgbWV0YS5SRVFVSVJFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEFEQVRBKSkgc2V0TWV0YWRhdGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBSRVFVSVJFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5oaWRkZW5LZXlzW01FVEFEQVRBXSA9IHRydWU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGIxY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjRiNzBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTQ3XCIpO1xuXG52YXIgZmlyZWZveCA9IHVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS9pKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGJiOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGUzNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWNmNVwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdhZVwiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzVjZlwiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjFkY1wiKTtcbnZhciBJU19QVVJFID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM3ODNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoKCFJU19QVVJFIHx8IE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0ZTg5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjODI2XCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcgPSBGdW5jdGlvblByb3RvdHlwZS50b1N0cmluZztcbnZhciBuYW1lUkUgPSAvXlxccypmdW5jdGlvbiAoW14gKF0qKS87XG52YXIgTkFNRSA9ICduYW1lJztcblxuLy8gRnVuY3Rpb24gaW5zdGFuY2VzIGAubmFtZWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZnVuY3Rpb24taW5zdGFuY2VzLW5hbWVcbmlmIChERVNDUklQVE9SUyAmJiAhKE5BTUUgaW4gRnVuY3Rpb25Qcm90b3R5cGUpKSB7XG4gIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG90eXBlLCBOQU1FLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmcuY2FsbCh0aGlzKS5tYXRjaChuYW1lUkUpWzFdO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNGY3MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNmM3YlwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDNjM1wiKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWNjNlwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOGFkXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEwNzhcIik7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiODY5MVwiKTtcblxuLy8gYEFycmF5LmZyb21gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTtcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZChtYXBmbiwgYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCwgMik7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAhPSB1bmRlZmluZWQgJiYgIShDID09IEFycmF5ICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyYXRvck1ldGhvZCkpKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvck1ldGhvZC5jYWxsKE8pO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IG5ldyBDKCk7XG4gICAgZm9yICg7IShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtzdGVwLnZhbHVlLCBpbmRleF0sIHRydWUpIDogc3RlcC52YWx1ZTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XTtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI0ZjlmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDJkZlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MXG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUwZDBcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMzA4XCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkN2FlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjUxMDhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgJGZpbHRlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NzQ4XCIpLmZpbHRlcjtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3ZTRcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGZpbHRlcih0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU1ZWFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgbm90QVJlZ0V4cCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2ZDlkXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTUxN1wiKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YmI4XCIpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhflN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKVxuICAgICAgLmluZGV4T2Yobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjU2ZmJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1NzQ4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZjN2JcIik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwYzQ1XCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE1MGVcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThhZFwiKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiM2Y3OFwiKTtcblxudmFyIHB1c2ggPSBbXS5wdXNoO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlck91dCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfT1VUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQsIDMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY3JlYXRlID0gc3BlY2lmaWNDcmVhdGUgfHwgYXJyYXlTcGVjaWVzQ3JlYXRlO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX09VVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyT3V0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHRhcmdldDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCgwKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJPdXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hcnJheS1maWx0ZXJpbmdcbiAgZmlsdGVyT3V0OiBjcmVhdGVNZXRob2QoNylcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWE2Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbmV4cG9ydHMuZiA9IHdlbGxLbm93blN5bWJvbDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1YmQ3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSkge1xuICBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0ICcgKyAobmFtZSA/IG5hbWUgKyAnICcgOiAnJykgKyAnaW52b2NhdGlvbicpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWJmZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcbiAgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI1Y2M3XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjU0ZlwiKTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNWRhY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjExYVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2NWVcIik7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLmZsYWdzYCBnZXR0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjFiNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGM0NVwiKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1MTdcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjFjZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSwgZXMvbm8tb2JqZWN0LXByZXZlbnRleHRlbnNpb25zIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNjhjY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjY1ZVwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IpIHtcbiAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgaWYgKHJldHVybk1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSkudmFsdWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNmFhMlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZhZTlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWVmM1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYTg2XCIpLmY7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IEZBSUxTX09OX1BSSU1JVElWRVM7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QoaXQpLCBrZXkpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2YjY2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM5OWJcIik7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2YzdiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTdmNFwiKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI2YzgwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHJlc3VsdCA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmcgPyBuYXRpdmVNaW4ocmVzdWx0LCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gKiBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYFxuICogbWV0aG9kIHRvIGNhbmNlbCBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0b1xuICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gKiBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGUgbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgXG4gKiB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWQgd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlXG4gKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gKiByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8udGhyb3R0bGVgIGFuZCBgXy5kZWJvdW5jZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gKiBqUXVlcnkod2luZG93KS5vbignc2Nyb2xsJywgXy50aHJvdHRsZSh1cGRhdGVQb3NpdGlvbiwgMTAwKSk7XG4gKlxuICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gKiB2YXIgdGhyb3R0bGVkID0gXy50aHJvdHRsZShyZW5ld1Rva2VuLCAzMDAwMDAsIHsgJ3RyYWlsaW5nJzogZmFsc2UgfSk7XG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgdGhyb3R0bGVkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIHRocm90dGxlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhyb3R0bGVkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGhyb3R0bGU7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDhmY1wiKSkpXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjZkOWRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI2MjdcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc1JlZ0V4cChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3MTQ4XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDMwOFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzRkZlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3NTMxXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2M0MFwiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmM5NFwiKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiNzg5MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYTgxXCIpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkdmFuY2VzdHJpbmdpbmRleFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI3OTBkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0NDMwXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2M0MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNzgzXCIpO1xudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM4OWNcIik7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4xNS4yJyxcbiAgbW9kZTogSVNfUFVSRSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDIxIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2RhNVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsvLyBhZGRhcHRlZCBmcm9tIHRoZSBkb2N1bWVudC5jdXJyZW50U2NyaXB0IHBvbHlmaWxsIGJ5IEFkYW0gTWlsbGVyXG4vLyBNSVQgbGljZW5zZVxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vYW1pbGxlci1naC9jdXJyZW50U2NyaXB0LXBvbHlmaWxsXG5cbi8vIGFkZGVkIHN1cHBvcnQgZm9yIEZpcmVmb3ggaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYyMDUwNVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGZhY3RvcnkpLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID9cblx0XHRcdFx0KF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLFxuXHRcdFx0XHRfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG4gIH0gZWxzZSB7fVxufSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0ICgpIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZG9jdW1lbnQsICdjdXJyZW50U2NyaXB0JylcbiAgICAvLyBmb3IgY2hyb21lXG4gICAgaWYgKCFkZXNjcmlwdG9yICYmICdjdXJyZW50U2NyaXB0JyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdFxuICAgIH1cblxuICAgIC8vIGZvciBvdGhlciBicm93c2VycyB3aXRoIG5hdGl2ZSBzdXBwb3J0IGZvciBjdXJyZW50U2NyaXB0XG4gICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQgIT09IGdldEN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHRcbiAgICB9XG4gIFxuICAgIC8vIElFIDgtMTAgc3VwcG9ydCBzY3JpcHQgcmVhZHlTdGF0ZVxuICAgIC8vIElFIDExKyAmIEZpcmVmb3ggc3VwcG9ydCBzdGFjayB0cmFjZVxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgLy8gRmluZCB0aGUgc2Vjb25kIG1hdGNoIGZvciB0aGUgXCJhdFwiIHN0cmluZyB0byBnZXQgZmlsZSBzcmMgdXJsIGZyb20gc3RhY2suXG4gICAgICB2YXIgaWVTdGFja1JlZ0V4cCA9IC8uKmF0IFteKF0qXFwoKC4qKTooLispOiguKylcXCkkL2lnLFxuICAgICAgICBmZlN0YWNrUmVnRXhwID0gL0AoW15AXSopOihcXGQrKTooXFxkKylcXHMqJC9pZyxcbiAgICAgICAgc3RhY2tEZXRhaWxzID0gaWVTdGFja1JlZ0V4cC5leGVjKGVyci5zdGFjaykgfHwgZmZTdGFja1JlZ0V4cC5leGVjKGVyci5zdGFjayksXG4gICAgICAgIHNjcmlwdExvY2F0aW9uID0gKHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMV0pIHx8IGZhbHNlLFxuICAgICAgICBsaW5lID0gKHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMl0pIHx8IGZhbHNlLFxuICAgICAgICBjdXJyZW50TG9jYXRpb24gPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLnJlcGxhY2UoZG9jdW1lbnQubG9jYXRpb24uaGFzaCwgJycpLFxuICAgICAgICBwYWdlU291cmNlLFxuICAgICAgICBpbmxpbmVTY3JpcHRTb3VyY2VSZWdFeHAsXG4gICAgICAgIGlubGluZVNjcmlwdFNvdXJjZSxcbiAgICAgICAgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTsgLy8gTGl2ZSBOb2RlTGlzdCBjb2xsZWN0aW9uXG4gIFxuICAgICAgaWYgKHNjcmlwdExvY2F0aW9uID09PSBjdXJyZW50TG9jYXRpb24pIHtcbiAgICAgICAgcGFnZVNvdXJjZSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIGlubGluZVNjcmlwdFNvdXJjZVJlZ0V4cCA9IG5ldyBSZWdFeHAoJyg/OlteXFxcXG5dKz9cXFxcbil7MCwnICsgKGxpbmUgLSAyKSArICd9W148XSo8c2NyaXB0PihbXFxcXGRcXFxcRF0qPyk8XFxcXC9zY3JpcHQ+W1xcXFxkXFxcXERdKicsICdpJyk7XG4gICAgICAgIGlubGluZVNjcmlwdFNvdXJjZSA9IHBhZ2VTb3VyY2UucmVwbGFjZShpbmxpbmVTY3JpcHRTb3VyY2VSZWdFeHAsICckMScpLnRyaW0oKTtcbiAgICAgIH1cbiAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gSWYgcmVhZHkgc3RhdGUgaXMgaW50ZXJhY3RpdmUsIHJldHVybiB0aGUgc2NyaXB0IHRhZ1xuICAgICAgICBpZiAoc2NyaXB0c1tpXS5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XG4gICAgICAgICAgcmV0dXJuIHNjcmlwdHNbaV07XG4gICAgICAgIH1cbiAgXG4gICAgICAgIC8vIElmIHNyYyBtYXRjaGVzLCByZXR1cm4gdGhlIHNjcmlwdCB0YWdcbiAgICAgICAgaWYgKHNjcmlwdHNbaV0uc3JjID09PSBzY3JpcHRMb2NhdGlvbikge1xuICAgICAgICAgIHJldHVybiBzY3JpcHRzW2ldO1xuICAgICAgICB9XG4gIFxuICAgICAgICAvLyBJZiBpbmxpbmUgc291cmNlIG1hdGNoZXMsIHJldHVybiB0aGUgc2NyaXB0IHRhZ1xuICAgICAgICBpZiAoXG4gICAgICAgICAgc2NyaXB0TG9jYXRpb24gPT09IGN1cnJlbnRMb2NhdGlvbiAmJlxuICAgICAgICAgIHNjcmlwdHNbaV0uaW5uZXJIVE1MICYmXG4gICAgICAgICAgc2NyaXB0c1tpXS5pbm5lckhUTUwudHJpbSgpID09PSBpbmxpbmVTY3JpcHRTb3VyY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHNjcmlwdHNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgXG4gICAgICAvLyBJZiBubyBtYXRjaCwgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZ2V0Q3VycmVudFNjcmlwdFxufSkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjdlNmZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiN2Y5ZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNWRhY1wiKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4MTNhXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjkyZlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImY2NWVcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThhZFwiKTtcbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzI1YlwiKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjE1MTdcIik7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc4OTFcIik7XG52YXIgZ2V0U3Vic3RpdHV0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhiMGJcIik7XG52YXIgcmVnRXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI4YTEwXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xuXG52YXIgUkVQTEFDRSA9IHdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIElFIDw9IDExIHJlcGxhY2VzICQwIHdpdGggdGhlIHdob2xlIG1hdGNoLCBhcyBpZiBpdCB3YXMgJCZcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYwMjQ2NjYvZ2V0dGluZy1pZS10by1yZXBsYWNlLWEtcmVnZXgtd2l0aC10aGUtbGl0ZXJhbC1zdHJpbmctMFxudmFyIFJFUExBQ0VfS0VFUFNfJDAgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3ByZWZlci1lc2NhcGUtcmVwbGFjZW1lbnQtZG9sbGFyLWNoYXIgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuICdhJy5yZXBsYWNlKC8uLywgJyQwJykgPT09ICckMCc7XG59KSgpO1xuXG4vLyBTYWZhcmkgPD0gMTMuMC4zKD8pIHN1YnN0aXR1dGVzIG50aCBjYXB0dXJlIHdoZXJlIG4+bSB3aXRoIGFuIGVtcHR5IHN0cmluZ1xudmFyIFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID0gKGZ1bmN0aW9uICgpIHtcbiAgaWYgKC8uL1tSRVBMQUNFXSkge1xuICAgIHJldHVybiAvLi9bUkVQTEFDRV0oJ2EnLCAnJDAnKSA9PT0gJyc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSkoKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCBmdW5jdGlvbiAoXywgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBVTlNBRkVfU1VCU1RJVFVURSA9IFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFID8gJyQnIDogJyQwJztcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICAgIHJldHVybiByZXBsYWNlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVwbGFjZXIuY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChzdHJpbmcsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnc3RyaW5nJyAmJlxuICAgICAgICByZXBsYWNlVmFsdWUuaW5kZXhPZihVTlNBRkVfU1VCU1RJVFVURSkgPT09IC0xICYmXG4gICAgICAgIHJlcGxhY2VWYWx1ZS5pbmRleE9mKCckPCcpID09PSAtMVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgdGhpcywgc3RyaW5nLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIFMgPSBTdHJpbmcoc3RyaW5nKTtcblxuICAgICAgdmFyIGZ1bmN0aW9uYWxSZXBsYWNlID0gdHlwZW9mIHJlcGxhY2VWYWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIGlmICghZnVuY3Rpb25hbFJlcGxhY2UpIHJlcGxhY2VWYWx1ZSA9IFN0cmluZyhyZXBsYWNlVmFsdWUpO1xuXG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgIGlmICghZ2xvYmFsKSBicmVhaztcblxuICAgICAgICB2YXIgbWF0Y2hTdHIgPSBTdHJpbmcocmVzdWx0WzBdKTtcbiAgICAgICAgaWYgKG1hdGNoU3RyID09PSAnJykgcngubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKHJ4Lmxhc3RJbmRleCksIGZ1bGxVbmljb2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuXG4gICAgICAgIHZhciBtYXRjaGVkID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG1heChtaW4odG9JbnRlZ2VyKHJlc3VsdC5pbmRleCksIFMubGVuZ3RoKSwgMCk7XG4gICAgICAgIHZhciBjYXB0dXJlcyA9IFtdO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgICAgLy8gICBjYXB0dXJlcyA9IHJlc3VsdC5zbGljZSgxKS5tYXAobWF5YmVUb1N0cmluZylcbiAgICAgICAgLy8gYnV0IGZvciBzb21lIHJlYXNvbiBgbmF0aXZlU2xpY2UuY2FsbChyZXN1bHQsIDEsIHJlc3VsdC5sZW5ndGgpYCAoY2FsbGVkIGluXG4gICAgICAgIC8vIHRoZSBzbGljZSBwb2x5ZmlsbCB3aGVuIHNsaWNpbmcgbmF0aXZlIGFycmF5cykgXCJkb2Vzbid0IHdvcmtcIiBpbiBzYWZhcmkgOSBhbmRcbiAgICAgICAgLy8gY2F1c2VzIGEgY3Jhc2ggKGh0dHBzOi8vcGFzdGViaW4uY29tL04yMVF6ZVFBKSB3aGVuIHRyeWluZyB0byBkZWJ1ZyBpdC5cbiAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIGNhcHR1cmVzLnB1c2gobWF5YmVUb1N0cmluZyhyZXN1bHRbal0pKTtcbiAgICAgICAgdmFyIG5hbWVkQ2FwdHVyZXMgPSByZXN1bHQuZ3JvdXBzO1xuICAgICAgICBpZiAoZnVuY3Rpb25hbFJlcGxhY2UpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZXJBcmdzID0gW21hdGNoZWRdLmNvbmNhdChjYXB0dXJlcywgcG9zaXRpb24sIFMpO1xuICAgICAgICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHJlcGxhY2VyQXJncy5wdXNoKG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgICAgIHZhciByZXBsYWNlbWVudCA9IFN0cmluZyhyZXBsYWNlVmFsdWUuYXBwbHkodW5kZWZpbmVkLCByZXBsYWNlckFyZ3MpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGdldFN1YnN0aXR1dGlvbihtYXRjaGVkLCBTLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID49IG5leHRTb3VyY2VQb3NpdGlvbikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkUmVzdWx0ICs9IFMuc2xpY2UobmV4dFNvdXJjZVBvc2l0aW9uLCBwb3NpdGlvbikgKyByZXBsYWNlbWVudDtcbiAgICAgICAgICBuZXh0U291cmNlUG9zaXRpb24gPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjdW11bGF0ZWRSZXN1bHQgKyBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbik7XG4gICAgfVxuICBdO1xufSwgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIHx8ICFSRVBMQUNFX0tFRVBTXyQwIHx8IFJFR0VYUF9SRVBMQUNFX1NVQlNUSVRVVEVTX1VOREVGSU5FRF9DQVBUVVJFKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4MTcwXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgZnJvbSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ZjcxXCIpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOWJjXCIpO1xuXG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1mcm9tIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIEFycmF5LmZyb20oaXRlcmFibGUpO1xufSk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODNjZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyYTgxXCIpLmNoYXJBdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZiNTlcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWQ1NFwiKTtcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLUBAaXRlcmF0b3JcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiBTdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiODY5MVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwOTNhXCIpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhYTJmXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOGExMFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNGQ4XCIpO1xudmFyIHJlZ2V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDNjNlwiKTtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChSLCBTKSB7XG4gIHZhciBleGVjID0gUi5leGVjO1xuICBpZiAodHlwZW9mIGV4ZWMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4cEV4ZWMuY2FsbChSLCBTKTtcbn07XG5cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI4YjBiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHJlcGxhY2UgPSAnJy5yZXBsYWNlO1xudmFyIFNVQlNUSVRVVElPTl9TWU1CT0xTID0gL1xcJChbJCYnYF18XFxkezEsMn18PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmJ2BdfFxcZHsxLDJ9KS9nO1xuXG4vLyBgR2V0U3Vic3RpdHV0aW9uYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0c3Vic3RpdHV0aW9uXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtYXRjaGVkLCBzdHIsIHBvc2l0aW9uLCBjYXB0dXJlcywgbmFtZWRDYXB0dXJlcywgcmVwbGFjZW1lbnQpIHtcbiAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgdmFyIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRDtcbiAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFM7XG4gIH1cbiAgcmV0dXJuIHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgIHZhciBjYXB0dXJlO1xuICAgIHN3aXRjaCAoY2guY2hhckF0KDApKSB7XG4gICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgIGNhc2UgJyYnOiByZXR1cm4gbWF0Y2hlZDtcbiAgICAgIGNhc2UgJ2AnOiByZXR1cm4gc3RyLnNsaWNlKDAsIHBvc2l0aW9uKTtcbiAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FwdHVyZSA9IG5hbWVkQ2FwdHVyZXNbY2guc2xpY2UoMSwgLTEpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyBcXGRcXGQ/XG4gICAgICAgIHZhciBuID0gK2NoO1xuICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICBpZiAobiA+IG0pIHtcbiAgICAgICAgICB2YXIgZiA9IGZsb29yKG4gLyAxMCk7XG4gICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICBpZiAoZiA8PSBtKSByZXR1cm4gY2FwdHVyZXNbZiAtIDFdID09PSB1bmRlZmluZWQgPyBjaC5jaGFyQXQoMSkgOiBjYXB0dXJlc1tmIC0gMV0gKyBjaC5jaGFyQXQoMSk7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGNhcHR1cmUgPSBjYXB0dXJlc1tuIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5MjMyXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgJGVudHJpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDU5MFwiKS5lbnRyaWVzO1xuXG4vLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKE8pIHtcbiAgICByZXR1cm4gJGVudHJpZXMoTyk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjkyYzlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4MjdcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk4MDhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgJG1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NzQ4XCIpLm1hcDtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImQ3ZTRcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnbWFwJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFIQVNfU1BFQ0lFU19TVVBQT1JUIH0sIHtcbiAgbWFwOiBmdW5jdGlvbiBtYXAoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJG1hcCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjk5YzdcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjMjViXCIpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiOWNjNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImFhMmZcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGVbSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIjljY2RcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBiYWJlbC1taW5pZnkgdHJhbnNwaWxlcyBSZWdFeHAoJy4nLCAnZycpIC0+IC8uL2cgYW5kIGl0IGNhdXNlcyBTeW50YXhFcnJvclxuICB2YXIgcmUgPSBSZWdFeHAoJyg/PGE+YiknLCAodHlwZW9mICcnKS5jaGFyQXQoNSkpO1xuICByZXR1cm4gcmUuZXhlYygnYicpLmdyb3Vwcy5hICE9PSAnYicgfHxcbiAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZTNiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlN2Y0XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBkZWZhdWx0Q29uc3RydWN0b3IpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbnN0cnVjdG9yIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI5ZWYzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDMwOFwiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWE4NlwiKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkN2FlXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ4MjdcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjUwZDBcIik7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0MTg3XCIpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZmZjlcIik7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhMDhmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjFiNVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOGFkXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5OWM3XCIpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNDFiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhNGRmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNmM5XCIpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgc2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0O1xuICAgIHNldHRlci5jYWxsKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdChPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyLmNhbGwoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYTUwZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNTE3XCIpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImE5NWNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJhYTJmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWE4NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzgyNlwiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiNDg4XCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oXCJiZDA2XCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRiMWNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2Y5ZFwiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImFlMGFcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTQ3XCIpO1xuXG52YXIgd2Via2l0ID0gdXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8pO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhd2Via2l0ICYmICt3ZWJraXRbMV07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYWY4NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4MjZcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmZmOVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODI3XCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNWNmXCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzRkOFwiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzMmRhXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRiMWNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2EyM1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjA0YTRcIikuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWE4NlwiKS5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIikuZjtcbnZhciB0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQyYTFcIikudHJpbTtcblxudmFyIE5VTUJFUiA9ICdOdW1iZXInO1xudmFyIE5hdGl2ZU51bWJlciA9IGdsb2JhbFtOVU1CRVJdO1xudmFyIE51bWJlclByb3RvdHlwZSA9IE5hdGl2ZU51bWJlci5wcm90b3R5cGU7XG5cbi8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xudmFyIEJST0tFTl9DTEFTU09GID0gY2xhc3NvZihjcmVhdGUoTnVtYmVyUHJvdG90eXBlKSkgPT0gTlVNQkVSO1xuXG4vLyBgVG9OdW1iZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b251bWJlclxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCBmYWxzZSk7XG4gIHZhciBmaXJzdCwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlLCBkaWdpdHMsIGxlbmd0aCwgaW5kZXgsIGNvZGU7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gdHJpbShpdCk7XG4gICAgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBpdC5zbGljZSgyKTtcbiAgICAgIGxlbmd0aCA9IGRpZ2l0cy5sZW5ndGg7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbi8vIGBOdW1iZXJgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgcmV0dXJuIGR1bW15IGluc3RhbmNlb2YgTnVtYmVyV3JhcHBlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NMQVNTT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IE51bWJlclByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZHVtbXkpOyB9KSA6IGNsYXNzb2YoZHVtbXkpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlTnVtYmVyKHRvTnVtYmVyKGl0KSksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IERFU0NSSVBUT1JTID8gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVOdW1iZXIpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVMyMDE1IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVMyMDE1IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlciwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYjM4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRlMzVcIikuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhMjNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkMDZcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk2YVwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWEyZlwiKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImI0ODhcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImI1ZGJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgJGZpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTc0OFwiKS5maW5kO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzU2NlwiKTtcblxudmFyIEZJTkQgPSAnZmluZCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTS0lQU19IT0xFUyB9LCB7XG4gIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiNWVjXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyIGFGdW5jdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlN2Y0XCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE1MGVcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZThhZFwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xudmFyIGludGVybmFsU29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIzZTQwXCIpO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTI0NFwiKTtcbnZhciBGRiA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0YjcwXCIpO1xudmFyIElFX09SX0VER0UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjNmNVwiKTtcbnZhciBWOCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMmVmXCIpO1xudmFyIFdFQktJVCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhZTBhXCIpO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIG5hdGl2ZVNvcnQgPSB0ZXN0LnNvcnQ7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnc29ydCcpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QgfHwgIVNUQUJMRV9TT1JUO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgcmV0dXJuIFN0cmluZyh4KSA+IFN0cmluZyh5KSA/IDEgOiAtMTtcbiAgfTtcbn07XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUZ1bmN0aW9uKGNvbXBhcmVmbik7XG5cbiAgICB2YXIgYXJyYXkgPSB0b09iamVjdCh0aGlzKTtcblxuICAgIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkID8gbmF0aXZlU29ydC5jYWxsKGFycmF5KSA6IG5hdGl2ZVNvcnQuY2FsbChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IHRvTGVuZ3RoKGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIGl0ZW1zTGVuZ3RoLCBpbmRleDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoaW5kZXggaW4gYXJyYXkpIGl0ZW1zLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG4gICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgaXRlbXNMZW5ndGgpIGFycmF5W2luZGV4XSA9IGl0ZW1zW2luZGV4KytdO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGUgYXJyYXlbaW5kZXgrK107XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImJhODNcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMyNWJcIik7XG52YXIgdGhpc051bWJlclZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjEyZGFcIik7XG52YXIgcmVwZWF0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUzYTZcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcblxudmFyIG5hdGl2ZVRvRml4ZWQgPSAxLjAudG9GaXhlZDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBwb3cgPSBmdW5jdGlvbiAoeCwgbiwgYWNjKSB7XG4gIHJldHVybiBuID09PSAwID8gYWNjIDogbiAlIDIgPT09IDEgPyBwb3coeCwgbiAtIDEsIGFjYyAqIHgpIDogcG93KHggKiB4LCBuIC8gMiwgYWNjKTtcbn07XG5cbnZhciBsb2cgPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgbiA9IDA7XG4gIHZhciB4MiA9IHg7XG4gIHdoaWxlICh4MiA+PSA0MDk2KSB7XG4gICAgbiArPSAxMjtcbiAgICB4MiAvPSA0MDk2O1xuICB9XG4gIHdoaWxlICh4MiA+PSAyKSB7XG4gICAgbiArPSAxO1xuICAgIHgyIC89IDI7XG4gIH0gcmV0dXJuIG47XG59O1xuXG52YXIgbXVsdGlwbHkgPSBmdW5jdGlvbiAoZGF0YSwgbiwgYykge1xuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGMyID0gYztcbiAgd2hpbGUgKCsraW5kZXggPCA2KSB7XG4gICAgYzIgKz0gbiAqIGRhdGFbaW5kZXhdO1xuICAgIGRhdGFbaW5kZXhdID0gYzIgJSAxZTc7XG4gICAgYzIgPSBmbG9vcihjMiAvIDFlNyk7XG4gIH1cbn07XG5cbnZhciBkaXZpZGUgPSBmdW5jdGlvbiAoZGF0YSwgbikge1xuICB2YXIgaW5kZXggPSA2O1xuICB2YXIgYyA9IDA7XG4gIHdoaWxlICgtLWluZGV4ID49IDApIHtcbiAgICBjICs9IGRhdGFbaW5kZXhdO1xuICAgIGRhdGFbaW5kZXhdID0gZmxvb3IoYyAvIG4pO1xuICAgIGMgPSAoYyAlIG4pICogMWU3O1xuICB9XG59O1xuXG52YXIgZGF0YVRvU3RyaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdmFyIGluZGV4ID0gNjtcbiAgdmFyIHMgPSAnJztcbiAgd2hpbGUgKC0taW5kZXggPj0gMCkge1xuICAgIGlmIChzICE9PSAnJyB8fCBpbmRleCA9PT0gMCB8fCBkYXRhW2luZGV4XSAhPT0gMCkge1xuICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpbmRleF0pO1xuICAgICAgcyA9IHMgPT09ICcnID8gdCA6IHMgKyByZXBlYXQuY2FsbCgnMCcsIDcgLSB0Lmxlbmd0aCkgKyB0O1xuICAgIH1cbiAgfSByZXR1cm4gcztcbn07XG5cbnZhciBGT1JDRUQgPSBuYXRpdmVUb0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgbmF0aXZlVG9GaXhlZC5jYWxsKHt9KTtcbn0pO1xuXG4vLyBgTnVtYmVyLnByb3RvdHlwZS50b0ZpeGVkYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLnByb3RvdHlwZS50b2ZpeGVkXG4kKHsgdGFyZ2V0OiAnTnVtYmVyJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgdG9GaXhlZDogZnVuY3Rpb24gdG9GaXhlZChmcmFjdGlvbkRpZ2l0cykge1xuICAgIHZhciBudW1iZXIgPSB0aGlzTnVtYmVyVmFsdWUodGhpcyk7XG4gICAgdmFyIGZyYWN0RGlnaXRzID0gdG9JbnRlZ2VyKGZyYWN0aW9uRGlnaXRzKTtcbiAgICB2YXIgZGF0YSA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICB2YXIgc2lnbiA9ICcnO1xuICAgIHZhciByZXN1bHQgPSAnMCc7XG4gICAgdmFyIGUsIHosIGosIGs7XG5cbiAgICBpZiAoZnJhY3REaWdpdHMgPCAwIHx8IGZyYWN0RGlnaXRzID4gMjApIHRocm93IFJhbmdlRXJyb3IoJ0luY29ycmVjdCBmcmFjdGlvbiBkaWdpdHMnKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChudW1iZXIgIT0gbnVtYmVyKSByZXR1cm4gJ05hTic7XG4gICAgaWYgKG51bWJlciA8PSAtMWUyMSB8fCBudW1iZXIgPj0gMWUyMSkgcmV0dXJuIFN0cmluZyhudW1iZXIpO1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICBzaWduID0gJy0nO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKG51bWJlciAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyBudW1iZXIgKiBwb3coMiwgLWUsIDEpIDogbnVtYmVyIC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseShkYXRhLCAwLCB6KTtcbiAgICAgICAgaiA9IGZyYWN0RGlnaXRzO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoZGF0YSwgMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkoZGF0YSwgcG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoZGF0YSwgMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoZGF0YSwgMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoZGF0YSwgMSwgMSk7XG4gICAgICAgIGRpdmlkZShkYXRhLCAyKTtcbiAgICAgICAgcmVzdWx0ID0gZGF0YVRvU3RyaW5nKGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlwbHkoZGF0YSwgMCwgeik7XG4gICAgICAgIG11bHRpcGx5KGRhdGEsIDEgPDwgLWUsIDApO1xuICAgICAgICByZXN1bHQgPSBkYXRhVG9TdHJpbmcoZGF0YSkgKyByZXBlYXQuY2FsbCgnMCcsIGZyYWN0RGlnaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZyYWN0RGlnaXRzID4gMCkge1xuICAgICAgayA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaWduICsgKGsgPD0gZnJhY3REaWdpdHNcbiAgICAgICAgPyAnMC4nICsgcmVwZWF0LmNhbGwoJzAnLCBmcmFjdERpZ2l0cyAtIGspICsgcmVzdWx0XG4gICAgICAgIDogcmVzdWx0LnNsaWNlKDAsIGsgLSBmcmFjdERpZ2l0cykgKyAnLicgKyByZXN1bHQuc2xpY2UoayAtIGZyYWN0RGlnaXRzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHNpZ24gKyByZXN1bHQ7XG4gICAgfSByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJiZDA2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYmRjNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjNGQ4XCIpO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImMyNWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzRkOFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzU2NlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNhMjNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiY2VhOFwiKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImM1Y2ZcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE1MGVcIik7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNjRiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5Y2M2XCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImU4YWRcIik7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2YzdiXCIpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjg2OTFcIik7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2OGNjXCIpO1xuXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24gKHN0b3BwZWQsIHJlc3VsdCkge1xuICB0aGlzLnN0b3BwZWQgPSBzdG9wcGVkO1xuICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIHRoYXQgPSBvcHRpb25zICYmIG9wdGlvbnMudGhhdDtcbiAgdmFyIEFTX0VOVFJJRVMgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuQVNfRU5UUklFUyk7XG4gIHZhciBJU19JVEVSQVRPUiA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19JVEVSQVRPUik7XG4gIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gIHZhciBmbiA9IGJpbmQodW5ib3VuZEZ1bmN0aW9uLCB0aGF0LCAxICsgQVNfRU5UUklFUyArIElOVEVSUlVQVEVEKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTtcbiAgfVxuXG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNmM5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI3NGRmXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjNzgzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzgyNlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiYzk5YlwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4MjZcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjM2OTJcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjZhYTJcIik7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjQ4OFwiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGM0NVwiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gYWxwaGFiZXQ7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJjYTIzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMWRkZFwiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyMjk0XCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYTk1Y1wiKTtcbnZhciBodG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMxYzZcIik7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjVkYWNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc1MzFcIik7XG5cbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcblxudmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIEFjdGl2ZVggT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuICBhY3RpdmVYRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCcnKSk7XG4gIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuICB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsOyAvLyBhdm9pZCBtZW1vcnkgbGVha1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFICovXG4gICAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSBhY3RpdmVYRG9jdW1lbnQgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gTnVsbFByb3RvT2JqZWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNlNjVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWVmM1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhNTBlXCIpO1xudmFyIG5hdGl2ZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzY5MlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImNlYThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM4MjZcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2Y5ZFwiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRiMWNcIik7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiY2Y3MFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciB3aGl0ZXNwYWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YmZkXCIpO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDA4Y1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU3NDhcIikuZm9yRWFjaDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyNDRcIik7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZm9yRWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSAhU1RSSUNUX01FVEhPRCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG59IDogW10uZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkMmVmXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMDMwOFwiKTtcbnZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjU0N1wiKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPCA0ID8gMSA6IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkM2MzXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjhjY1wiKTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDQ1M1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI2MWI1XCIpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzU2NlwiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWEyZlwiKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZiNTlcIik7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZWQ1NFwiKTtcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKEFSUkFZX0lURVJBVE9SKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5rZXlzXG4vLyBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS52YWx1ZXNcbi8vIGBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVhcnJheWl0ZXJhdG9yXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gICAgdGFyZ2V0OiB0b0luZGV4ZWRPYmplY3QoaXRlcmF0ZWQpLCAvLyB0YXJnZXRcbiAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgfSk7XG4vLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJkN2FlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJjODI2XCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNlYThcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImJkMDZcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImQ3ZTRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oXCJkMmVmXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiA+PSA1MSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IGFycmF5LmNvbnN0cnVjdG9yID0ge307XG4gICAgY29uc3RydWN0b3JbU1BFQ0lFU10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZDhmY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTI0NFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlM2E2XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImMyNWJcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxNTE3XCIpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGVhdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgbiA9IHRvSW50ZWdlcihjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImU3ZjRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlOGFkXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzI1YlwiKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZTliY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImYxZGNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZDU0XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYjM4Y1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oXCIxY2Y1XCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE0ZGZcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNDk2YVwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdhZVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODI3XCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmMWRjXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzc4M1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYWEyZlwiKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRlMzVcIik7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IEl0ZXJhdG9yc0NvcmUuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IEl0ZXJhdG9yc0NvcmUuQlVHR1lfU0FGQVJJX0lURVJBVE9SUztcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xudmFyIEVOVFJJRVMgPSAnZW50cmllcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKSByZXR1cm4gSXRlcmFibGVQcm90b3R5cGVbS0lORF07XG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMpOyB9O1xuICB9O1xuXG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICB2YXIgSU5DT1JSRUNUX1ZBTFVFU19OQU1FID0gZmFsc2U7XG4gIHZhciBJdGVyYWJsZVByb3RvdHlwZSA9IEl0ZXJhYmxlLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdXG4gICAgfHwgSXRlcmFibGVQcm90b3R5cGVbJ0BAaXRlcmF0b3InXVxuICAgIHx8IERFRkFVTFQgJiYgSXRlcmFibGVQcm90b3R5cGVbREVGQVVMVF07XG4gIHZhciBkZWZhdWx0SXRlcmF0b3IgPSAhQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBuYXRpdmVJdGVyYXRvciB8fCBnZXRJdGVyYXRpb25NZXRob2QoREVGQVVMVCk7XG4gIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiAgdmFyIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgbWV0aG9kcywgS0VZO1xuXG4gIC8vIGZpeCBuYXRpdmVcbiAgaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gICAgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkucHJvdG90eXBlLnsgdmFsdWVzLCBAQGl0ZXJhdG9yIH0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiAgfVxuICBJdGVyYXRvcnNbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIHJlZGVmaW5lKEl0ZXJhYmxlUHJvdG90eXBlLCBLRVksIG1ldGhvZHNbS0VZXSk7XG4gICAgICB9XG4gICAgfSBlbHNlICQoeyB0YXJnZXQ6IE5BTUUsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIH0sIG1ldGhvZHMpO1xuICB9XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImVkYThcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjllZjNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZmZmOVwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODI3XCIpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNGE5ZlwiKTtcbnZhciBpdGVyYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM2NGJcIik7XG52YXIgYW5JbnN0YW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1YmQ3XCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjc0ZGZcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNTZmYlwiKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZTliY1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0OTZhXCIpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjMyZGFcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuICB2YXIgSVNfTUFQID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdNYXAnKSAhPT0gLTE7XG4gIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdXZWFrJykgIT09IC0xO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWxbQ09OU1RSVUNUT1JfTkFNRV07XG4gIHZhciBOYXRpdmVQcm90b3R5cGUgPSBOYXRpdmVDb25zdHJ1Y3RvciAmJiBOYXRpdmVDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIHZhciBDb25zdHJ1Y3RvciA9IE5hdGl2ZUNvbnN0cnVjdG9yO1xuICB2YXIgZXhwb3J0ZWQgPSB7fTtcblxuICB2YXIgZml4TWV0aG9kID0gZnVuY3Rpb24gKEtFWSkge1xuICAgIHZhciBuYXRpdmVNZXRob2QgPSBOYXRpdmVQcm90b3R5cGVbS0VZXTtcbiAgICByZWRlZmluZShOYXRpdmVQcm90b3R5cGUsIEtFWSxcbiAgICAgIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSA6IEtFWSA9PSAnZGVsZXRlJyA/IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICAgICAgfSA6IEtFWSA9PSAnZ2V0JyA/IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyB1bmRlZmluZWQgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiBJU19XRUFLICYmICFpc09iamVjdChrZXkpID8gZmFsc2UgOiBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5KTtcbiAgICAgIH0gOiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgdmFyIFJFUExBQ0UgPSBpc0ZvcmNlZChcbiAgICBDT05TVFJVQ1RPUl9OQU1FLFxuICAgIHR5cGVvZiBOYXRpdmVDb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nIHx8ICEoSVNfV0VBSyB8fCBOYXRpdmVQcm90b3R5cGUuZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgICB9KSlcbiAgKTtcblxuICBpZiAoUkVQTEFDRSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5SRVFVSVJFRCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+IENocm9taXVtIDQwLSB3ZWFrLWNvbGxlY3Rpb25zIHRocm93cyBvbiBwcmltaXRpdmVzLCBidXQgc2hvdWxkIHJldHVybiBmYWxzZVxuICAgIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgaW5zdGFuY2UuaGFzKDEpOyB9KTtcbiAgICAvLyBtb3N0IGVhcmx5IGltcGxlbWVudGF0aW9ucyBkb2Vzbid0IHN1cHBvcnRzIGl0ZXJhYmxlcywgbW9zdCBtb2Rlcm4gLSBub3QgY2xvc2UgaXQgY29ycmVjdGx5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkgeyBuZXcgTmF0aXZlQ29uc3RydWN0b3IoaXRlcmFibGUpOyB9KTtcbiAgICAvLyBmb3IgZWFybHkgaW1wbGVtZW50YXRpb25zIC0wIGFuZCArMCBub3QgdGhlIHNhbWVcbiAgICB2YXIgQlVHR1lfWkVSTyA9ICFJU19XRUFLICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFY4IH4gQ2hyb21pdW0gNDItIGZhaWxzIG9ubHkgd2l0aCA1KyBlbGVtZW50c1xuICAgICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgICAgdmFyIGluZGV4ID0gNTtcbiAgICAgIHdoaWxlIChpbmRleC0tKSAkaW5zdGFuY2VbQURERVJdKGluZGV4LCBpbmRleCk7XG4gICAgICByZXR1cm4gISRpbnN0YW5jZS5oYXMoLTApO1xuICAgIH0pO1xuXG4gICAgaWYgKCFBQ0NFUFRfSVRFUkFCTEVTKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBpdGVyYWJsZSkge1xuICAgICAgICBhbkluc3RhbmNlKGR1bW15LCBDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XG4gICAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cblxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuXG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG4gIH1cblxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZWYyZFwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjI5MmZcIik7XG52YXIgaXNSZWdFeHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMjYyN1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJmNjVlXCIpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMTUxN1wiKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiOWUzYlwiKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzg5MVwiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oXCJlOGFkXCIpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjhhMTBcIik7XG52YXIgcmVnZXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0M2M2XCIpO1xudmFyIHN0aWNreUhlbHBlcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZjA1YlwiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oXCI1NmZiXCIpO1xuXG52YXIgVU5TVVBQT1JURURfWSA9IHN0aWNreUhlbHBlcnMuVU5TVVBQT1JURURfWTtcbnZhciBhcnJheVB1c2ggPSBbXS5wdXNoO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9VSU5UMzIgPSAweEZGRkZGRkZGO1xuXG4vLyBDaHJvbWUgNTEgaGFzIGEgYnVnZ3kgXCJzcGxpdFwiIGltcGxlbWVudGF0aW9uIHdoZW4gUmVnRXhwI2V4ZWMgIT09IG5hdGl2ZUV4ZWNcbi8vIFdlZXggSlMgaGFzIGZyb3plbiBidWlsdC1pbiBwcm90b3R5cGVzLCBzbyB1c2UgdHJ5IC8gY2F0Y2ggd3JhcHBlclxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzcGxpdCcsIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvbm8tZW1wdHktZ3JvdXAgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9IDQgfHxcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9IDQgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWFzc2VydGlvbi1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHJldHVybiBbc3RyaW5nXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXJyYXlQdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltID8gb3V0cHV0LnNsaWNlKDAsIGxpbSkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJy5zcGxpdCh1bmRlZmluZWQsIDApLmxlbmd0aCkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBuYXRpdmVTcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAoc3RyaW5nLCBsaW1pdCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCB0aGlzLCBzdHJpbmcsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSBuYXRpdmVTcGxpdCk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIFMgPSBTdHJpbmcoc3RyaW5nKTtcbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFVOU1VQUE9SVEVEX1kgPyAnZycgOiAneScpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoVU5TVVBQT1JURURfWSA/ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJyA6IHJ4LCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gVU5TVVBQT1JURURfWSA/IDAgOiBxO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBVTlNVUFBPUlRFRF9ZID8gUy5zbGljZShxKSA6IFMpO1xuICAgICAgICB2YXIgZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHogPT09IG51bGwgfHxcbiAgICAgICAgICAoZSA9IG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoVU5TVVBQT1JURURfWSA/IHEgOiAwKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEEucHVzaCh6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59LCAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDLCBVTlNVUFBPUlRFRF9ZKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJlZjRlXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMGM0NVwiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNjFiNVwiKTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImUyNDRcIik7XG5cbnZhciBuYXRpdmVKb2luID0gW10uam9pbjtcblxudmFyIEVTM19TVFJJTkdTID0gSW5kZXhlZE9iamVjdCAhPSBPYmplY3Q7XG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2pvaW4nLCAnLCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmpvaW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuam9pblxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRVMzX1NUUklOR1MgfHwgIVNUUklDVF9NRVRIT0QgfSwge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBuYXRpdmVKb2luLmNhbGwodG9JbmRleGVkT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImYwNWJcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yLFxudmFyIFJFID0gZnVuY3Rpb24gKHMsIGYpIHtcbiAgcmV0dXJuIFJlZ0V4cChzLCBmKTtcbn07XG5cbmV4cG9ydHMuVU5TVVBQT1JURURfWSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gUkUoJ2EnLCAneScpO1xuICByZS5sYXN0SW5kZXggPSAyO1xuICByZXR1cm4gcmUuZXhlYygnYWJjZCcpICE9IG51bGw7XG59KTtcblxuZXhwb3J0cy5CUk9LRU5fQ0FSRVQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSBSRSgnXnInLCAnZ3knKTtcbiAgcmUubGFzdEluZGV4ID0gMjtcbiAgcmV0dXJuIHJlLmV4ZWMoJ3N0cicpICE9IG51bGw7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmMTM1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyICR0cmltID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQyYTFcIikudHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImNmNzBcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltJykgfSwge1xuICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgIHJldHVybiAkdHJpbSh0aGlzKTtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjFkY1wiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjdjNDBcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImM1Y2ZcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImZjOTRcIik7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oXCIwMmRmXCIpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjRmOWZcIik7XG5cbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkgfHwgIShOQVRJVkVfU1lNQk9MIHx8IHR5cGVvZiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPT0gJ3N0cmluZycpKSB7XG4gICAgaWYgKE5BVElWRV9TWU1CT0wgJiYgaGFzKFN5bWJvbCwgbmFtZSkpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IFN5bWJvbFtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gY3JlYXRlV2VsbEtub3duU3ltYm9sKCdTeW1ib2wuJyArIG5hbWUpO1xuICAgIH1cbiAgfSByZXR1cm4gV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmMjhiXCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oXCI5ZWYzXCIpO1xudmFyICRpbmNsdWRlcyA9IF9fd2VicGFja19yZXF1aXJlX18oXCJhMDhmXCIpLmluY2x1ZGVzO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzU2NlwiKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmM2Y1XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVQSA9IF9fd2VicGFja19yZXF1aXJlX18oXCIyNTQ3XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImY2MzVcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaXRlcmFibGUgRE9NIGNvbGxlY3Rpb25zXG4vLyBmbGFnIC0gYGl0ZXJhYmxlYCBpbnRlcmZhY2UgLSAnZW50cmllcycsICdrZXlzJywgJ3ZhbHVlcycsICdmb3JFYWNoJyBtZXRob2RzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZjY1ZVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xuICB9IHJldHVybiBpdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiZmI1OVwiOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ1YmZcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjAzMDhcIik7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzRkZlwiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiZDdhZVwiKTtcbnZhciBvYmplY3RIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiYzVjZlwiKTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiMzg5Y1wiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiNzUzMVwiKTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcImE5NWNcIik7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCB8fCBzaGFyZWQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlID0gc2hhcmVkLnN0YXRlIHx8IChzaGFyZWQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgdmFyIHdtZ2V0ID0gc3RvcmUuZ2V0O1xuICB2YXIgd21oYXMgPSBzdG9yZS5oYXM7XG4gIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmICh3bWhhcy5jYWxsKHN0b3JlLCBpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gd21oYXMuY2FsbChzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAob2JqZWN0SGFzKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJmYzM5XCI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiN2U2ZlwiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oXCI0ODI3XCIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjQ2OGVcIik7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZjOTRcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImZmZjlcIjpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIjU2ZmJcIik7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12dWVIb3RlbERhdGVwaWNrZXIuY29tbW9uLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-hotel-datepicker/dist/vueHotelDatepicker.common.js\n");

/***/ }),

/***/ "./node_modules/vue-number-input-spinner/dist/vue-number-input-spinner.min.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vue-number-input-spinner/dist/vue-number-input-spinner.min.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(e,n){ true?module.exports=n():undefined}(this,function(){return function(e){function n(r){if(t[r])return t[r].exports;var i=t[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}var t={};return n.m=e,n.c=t,n.i=function(e){return e},n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p=\"/\",n(n.s=6)}([function(e,n,t){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.default={name:\"NumberInputSpinner\",data:function(){return{numericValue:this.value,timer:null}},props:{value:{type:Number,default:0},min:{default:0,type:Number},max:{default:10,type:Number},step:{default:1,type:Number},mouseDownSpeed:{default:100,type:Number},inputClass:{default:\"vnis__input\",type:String},buttonClass:{default:\"vnis__button\",type:String},integerOnly:{default:!1,type:Boolean}},methods:{clearTimer:function(){this.timer&&(clearInterval(this.timer),this.timer=null)},whileMouseDown:function(e){null===this.timer&&(this.timer=setInterval(function(){e()},this.mouseDownSpeed))},increaseNumber:function(){this.numericValue+=this.step},decreaseNumber:function(){this.numericValue-=this.step},isInteger:function(e){e=e||window.event;var n=e.keyCode||e.which;n=String.fromCharCode(n),/[0-9]/.test(n)||(e.returnValue=!1,e.preventDefault&&e.preventDefault())},isNumber:function(e){e=e||window.event;var n=e.which?e.which:e.keyCode;if(!(n>31&&(n<48||n>57)&&46!==n))return!0;e.preventDefault()},validateInput:function(e){!0===this.integerOnly?this.isInteger(e):this.isNumber(e)},inputValue:function(e){this.numericValue=e.target.value?parseInt(e.target.value):this.min}},watch:{numericValue:function(e,n){e<=this.min&&(this.numericValue=parseInt(this.min)),e>=this.max&&(this.numericValue=parseInt(this.max)),e<=this.max&&e>=this.min&&this.$emit(\"input\",e,n)}}}},function(e,n){e.exports=function(e,n,t,r,i){var o,s=e=e||{},u=typeof e.default;\"object\"!==u&&\"function\"!==u||(o=e,s=e.default);var a=\"function\"==typeof s?s.options:s;n&&(a.render=n.render,a.staticRenderFns=n.staticRenderFns),r&&(a._scopeId=r);var c;if(i?(c=function(e){e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,e||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),t&&t.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},a._ssrRegister=c):t&&(c=t),c){var p=a.functional,l=p?a.render:a.beforeCreate;p?a.render=function(e,n){return c.call(n),l(e,n)}:a.beforeCreate=l?[].concat(l,c):[c]}return{esModule:o,exports:s,options:a}}},function(e,n,t){e.exports={render:function(){var e=this,n=e.$createElement,t=e._self._c||n;return t(\"div\",{staticClass:\"vnis\"},[t(\"button\",{class:e.buttonClass,on:{click:e.decreaseNumber,mousedown:function(n){e.whileMouseDown(e.decreaseNumber)},mouseup:e.clearTimer}},[e._v(\"-\")]),e._v(\" \"),t(\"input\",{class:e.inputClass,attrs:{type:\"number\",min:e.min,max:e.max,debounce:\"500\"},domProps:{value:e.numericValue},on:{keypress:e.validateInput,input:e.inputValue}}),e._v(\" \"),t(\"button\",{class:e.buttonClass,on:{click:e.increaseNumber,mousedown:function(n){e.whileMouseDown(e.increaseNumber)},mouseup:e.clearTimer}},[e._v(\"+\")])])},staticRenderFns:[]},e.exports.render._withStripped=!0},function(e,n,t){var r=t(4);\"string\"==typeof r&&(r=[[e.i,r,\"\"]]),r.locals&&(e.exports=r.locals);t(7)(\"38ce7148\",r,!1)},function(e,n,t){n=e.exports=t(5)(void 0),n.push([e.i,\"\\n.vnis *,\\n.vnis *::after,\\n.vnis *::before {\\n  box-sizing: border-box;\\n}\\n.vnis__input {\\n  -webkit-appearance: none;\\n  border: 1px solid #ebebeb;\\n  float: left;\\n  font-size: 16px;\\n  height: 40px;\\n  margin: 0;\\n  outline: none;\\n  text-align: center;\\n  width: calc(100% - 80px);\\n}\\n.vnis__input::-webkit-outer-spin-button, .vnis__input::-webkit-inner-spin-button {\\n    -webkit-appearance: none;\\n}\\n.vnis__button {\\n  -webkit-appearance: none;\\n  transition: background 0.5s ease;\\n  background: #387e90;\\n  border: 0;\\n  color: #fff;\\n  cursor: pointer;\\n  float: left;\\n  font-size: 20px;\\n  height: 40px;\\n  margin: 0;\\n  width: 40px;\\n}\\n.vnis__button:hover {\\n    background: #469eb5;\\n}\\n.vnis__button:focus {\\n    outline: 1px dashed #69b2c5;\\n    outline-offset: -5px;\\n}\\n\",\"\"])},function(e,n){function t(e,n){var t=e[1]||\"\",i=e[3];if(!i)return t;if(n&&\"function\"==typeof btoa){var o=r(i);return[t].concat(i.sources.map(function(e){return\"/*# sourceURL=\"+i.sourceRoot+e+\" */\"})).concat([o]).join(\"\\n\")}return[t].join(\"\\n\")}function r(e){return\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+\" */\"}e.exports=function(e){var n=[];return n.toString=function(){return this.map(function(n){var r=t(n,e);return n[2]?\"@media \"+n[2]+\"{\"+r+\"}\":r}).join(\"\")},n.i=function(e,t){\"string\"==typeof e&&(e=[[null,e,\"\"]]);for(var r={},i=0;i<this.length;i++){var o=this[i][0];\"number\"==typeof o&&(r[o]=!0)}for(i=0;i<e.length;i++){var s=e[i];\"number\"==typeof s[0]&&r[s[0]]||(t&&!s[2]?s[2]=t:t&&(s[2]=\"(\"+s[2]+\") and (\"+t+\")\"),n.push(s))}},n}},function(e,n,t){function r(e){i||t(3)}var i=!1,o=t(1)(t(0),t(2),r,null,null);o.options.__file=\"/Users/krystalcampioni/repos/vue-number-input-spinner/src/components/NumberInputSpinner.vue\",o.esModule&&Object.keys(o.esModule).some(function(e){return\"default\"!==e&&\"__\"!==e.substr(0,2)}),o.options.functional,e.exports=o.exports},function(e,n,t){function r(e){for(var n=0;n<e.length;n++){var t=e[n],r=p[t.id];if(r){r.refs++;for(var i=0;i<r.parts.length;i++)r.parts[i](t.parts[i]);for(;i<t.parts.length;i++)r.parts.push(o(t.parts[i]));r.parts.length>t.parts.length&&(r.parts.length=t.parts.length)}else{for(var s=[],i=0;i<t.parts.length;i++)s.push(o(t.parts[i]));p[t.id]={id:t.id,refs:1,parts:s}}}}function i(){var e=document.createElement(\"style\");return e.type=\"text/css\",l.appendChild(e),e}function o(e){var n,t,r=document.querySelector('style[data-vue-ssr-id~=\"'+e.id+'\"]');if(r){if(m)return h;r.parentNode.removeChild(r)}if(v){var o=d++;r=f||(f=i()),n=s.bind(null,r,o,!1),t=s.bind(null,r,o,!0)}else r=i(),n=u.bind(null,r),t=function(){r.parentNode.removeChild(r)};return n(e),function(r){if(r){if(r.css===e.css&&r.media===e.media&&r.sourceMap===e.sourceMap)return;n(e=r)}else t()}}function s(e,n,t,r){var i=t?\"\":r.css;if(e.styleSheet)e.styleSheet.cssText=b(n,i);else{var o=document.createTextNode(i),s=e.childNodes;s[n]&&e.removeChild(s[n]),s.length?e.insertBefore(o,s[n]):e.appendChild(o)}}function u(e,n){var t=n.css,r=n.media,i=n.sourceMap;if(r&&e.setAttribute(\"media\",r),i&&(t+=\"\\n/*# sourceURL=\"+i.sources[0]+\" */\",t+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+\" */\"),e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}var a=\"undefined\"!=typeof document;if(\"undefined\"!=typeof DEBUG&&DEBUG&&!a)throw new Error(\"vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\");var c=t(8),p={},l=a&&(document.head||document.getElementsByTagName(\"head\")[0]),f=null,d=0,m=!1,h=function(){},v=\"undefined\"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());e.exports=function(e,n,t){m=t;var i=c(e,n);return r(i),function(n){for(var t=[],o=0;o<i.length;o++){var s=i[o],u=p[s.id];u.refs--,t.push(u)}n?(i=c(e,n),r(i)):i=[];for(var o=0;o<t.length;o++){var u=t[o];if(0===u.refs){for(var a=0;a<u.parts.length;a++)u.parts[a]();delete p[u.id]}}}};var b=function(){var e=[];return function(n,t){return e[n]=t,e.filter(Boolean).join(\"\\n\")}}()},function(e,n){e.exports=function(e,n){for(var t=[],r={},i=0;i<n.length;i++){var o=n[i],s=o[0],u=o[1],a=o[2],c=o[3],p={id:e+\":\"+i,css:u,media:a,sourceMap:c};r[s]?r[s].parts.push(p):t.push(r[s]={id:s,parts:[p]})}return t}}])});\n//# sourceMappingURL=vue-number-input-spinner.min.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLW51bWJlci1pbnB1dC1zcGlubmVyL2Rpc3QvdnVlLW51bWJlci1pbnB1dC1zcGlubmVyLm1pbi5qcz8xZmIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGVBQWUsS0FBaUQsb0JBQW9CLFNBQW1JLENBQUMsaUJBQWlCLG1CQUFtQixjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsU0FBUyxtQ0FBbUMsU0FBUyxxQkFBcUIscUNBQXFDLG9DQUFvQyxFQUFFLGlCQUFpQixpQ0FBaUMsaUJBQWlCLFlBQVksVUFBVSxzQkFBc0IsbUJBQW1CLGlEQUFpRCxrQkFBa0Isa0JBQWtCLGFBQWEsc0NBQXNDLFNBQVMsYUFBYSwwQ0FBMEMsT0FBTyxvQ0FBb0MsUUFBUSxPQUFPLHNCQUFzQixNQUFNLHNCQUFzQixNQUFNLHVCQUF1QixPQUFPLHNCQUFzQixpQkFBaUIsd0JBQXdCLGFBQWEsa0NBQWtDLGNBQWMsbUNBQW1DLGNBQWMseUJBQXlCLFVBQVUsc0JBQXNCLHdEQUF3RCw0QkFBNEIsc0RBQXNELElBQUksdUJBQXVCLDJCQUEyQiw2QkFBNkIsMkJBQTJCLDZCQUE2Qix1QkFBdUIsa0JBQWtCLHlCQUF5QixrR0FBa0csc0JBQXNCLGtCQUFrQixnQ0FBZ0MsMENBQTBDLG1CQUFtQiwyQkFBMkIseURBQXlELHdCQUF3QixvRUFBb0UsUUFBUSwyQkFBMkIsNkpBQTZKLGVBQWUsOEJBQThCLGVBQWUsb0JBQW9CLGdEQUFnRCx1Q0FBdUMsNkVBQTZFLE1BQU0sb0JBQW9CLDBQQUEwUCwrQkFBK0IsK0NBQStDLHlCQUF5Qix3QkFBd0IscUNBQXFDLE9BQU8saUNBQWlDLGlCQUFpQixXQUFXLGtCQUFrQiw4Q0FBOEMsZ0JBQWdCLG1CQUFtQixjQUFjLHdCQUF3Qiw2Q0FBNkMsbUNBQW1DLHVCQUF1QixtQ0FBbUMsMEJBQTBCLGlEQUFpRCxXQUFXLHFCQUFxQixLQUFLLDZDQUE2Qyx3QkFBd0Isd0JBQXdCLDZDQUE2QyxtQ0FBbUMsdUJBQXVCLGdCQUFnQixvQkFBb0IsbUNBQW1DLGlCQUFpQixXQUFXLG9FQUFvRSxzQkFBc0IsaUJBQWlCLG9GQUFvRiwyQkFBMkIsR0FBRyxnQkFBZ0IsNkJBQTZCLDhCQUE4QixnQkFBZ0Isb0JBQW9CLGlCQUFpQixjQUFjLGtCQUFrQix1QkFBdUIsNkJBQTZCLEdBQUcsb0ZBQW9GLCtCQUErQixHQUFHLGlCQUFpQiw2QkFBNkIscUNBQXFDLHdCQUF3QixjQUFjLGdCQUFnQixvQkFBb0IsZ0JBQWdCLG9CQUFvQixpQkFBaUIsY0FBYyxnQkFBZ0IsR0FBRyx1QkFBdUIsMEJBQTBCLEdBQUcsdUJBQXVCLGtDQUFrQywyQkFBMkIsR0FBRyxTQUFTLGVBQWUsZ0JBQWdCLHNCQUFzQixlQUFlLCtCQUErQixXQUFXLDJDQUEyQyw0Q0FBNEMsMEJBQTBCLHFCQUFxQixjQUFjLGtEQUFrRCxjQUFjLHFFQUFxRSxzQkFBc0IsU0FBUyw2QkFBNkIsNEJBQTRCLGFBQWEsNkJBQTZCLE1BQU0sSUFBSSxXQUFXLG1CQUFtQixzQ0FBc0MsWUFBWSxLQUFLLGNBQWMsS0FBSyxpQkFBaUIsOEJBQThCLFFBQVEsV0FBVyxLQUFLLFdBQVcsZ0dBQWdHLElBQUksaUJBQWlCLGNBQWMsUUFBUSx1Q0FBdUMsb0tBQW9LLDBDQUEwQywyQ0FBMkMsaUJBQWlCLGNBQWMsWUFBWSxXQUFXLEtBQUsscUJBQXFCLE1BQU0sU0FBUyxZQUFZLGlCQUFpQiwyQkFBMkIsS0FBSyxpQkFBaUIsZ0NBQWdDLCtEQUErRCxLQUFLLGlCQUFpQixpQkFBaUIsMEJBQTBCLFNBQVMsMEJBQTBCLGFBQWEsc0NBQXNDLDRDQUE0QyxjQUFjLHVFQUF1RSxNQUFNLGNBQWMsNEJBQTRCLE1BQU0sVUFBVSx5REFBeUQseUNBQXlDLDZCQUE2Qix3QkFBd0IsTUFBTSxzRUFBc0UsT0FBTyxVQUFVLG9CQUFvQixpQkFBaUIsNENBQTRDLEtBQUssZ0RBQWdELDRFQUE0RSxnQkFBZ0Isb0NBQW9DLDhIQUE4SCwwR0FBMEcsS0FBSyxLQUFLLGFBQWEsNkJBQTZCLDJDQUEyQyxtQ0FBbUMsNEhBQTRILGlCQUFpQixzRUFBc0UsZUFBZSw4RkFBOEYseUZBQXlGLDBCQUEwQixJQUFJLGFBQWEsd0JBQXdCLGlCQUFpQixXQUFXLEtBQUsscUJBQXFCLG1CQUFtQix1QkFBdUIsWUFBWSxXQUFXLEtBQUssV0FBVyxlQUFlLFlBQVksaUJBQWlCLGlCQUFpQixtQkFBbUIsaUJBQWlCLFNBQVMscUJBQXFCLDRDQUE0QyxHQUFHLGVBQWUsd0JBQXdCLGlCQUFpQixLQUFLLFdBQVcsS0FBSywwQ0FBMEMsc0NBQXNDLHFDQUFxQyxlQUFlLEVBQUUsVUFBVSxHQUFHO0FBQ2pnUSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtbnVtYmVyLWlucHV0LXNwaW5uZXIvZGlzdC92dWUtbnVtYmVyLWlucHV0LXNwaW5uZXIubWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKGUsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bigpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sbik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5OdW1iZXJJbnB1dFNwaW5uZXI9bigpOmUuTnVtYmVySW5wdXRTcGlubmVyPW4oKX0odGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBuKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgaT10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxuKSxpLmw9ITAsaS5leHBvcnRzfXZhciB0PXt9O3JldHVybiBuLm09ZSxuLmM9dCxuLmk9ZnVuY3Rpb24oZSl7cmV0dXJuIGV9LG4uZD1mdW5jdGlvbihlLHQscil7bi5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpyfSl9LG4ubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKHQsXCJhXCIsdCksdH0sbi5vPWZ1bmN0aW9uKGUsbil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfSxuLnA9XCIvXCIsbihuLnM9Nil9KFtmdW5jdGlvbihlLG4sdCl7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5kZWZhdWx0PXtuYW1lOlwiTnVtYmVySW5wdXRTcGlubmVyXCIsZGF0YTpmdW5jdGlvbigpe3JldHVybntudW1lcmljVmFsdWU6dGhpcy52YWx1ZSx0aW1lcjpudWxsfX0scHJvcHM6e3ZhbHVlOnt0eXBlOk51bWJlcixkZWZhdWx0OjB9LG1pbjp7ZGVmYXVsdDowLHR5cGU6TnVtYmVyfSxtYXg6e2RlZmF1bHQ6MTAsdHlwZTpOdW1iZXJ9LHN0ZXA6e2RlZmF1bHQ6MSx0eXBlOk51bWJlcn0sbW91c2VEb3duU3BlZWQ6e2RlZmF1bHQ6MTAwLHR5cGU6TnVtYmVyfSxpbnB1dENsYXNzOntkZWZhdWx0Olwidm5pc19faW5wdXRcIix0eXBlOlN0cmluZ30sYnV0dG9uQ2xhc3M6e2RlZmF1bHQ6XCJ2bmlzX19idXR0b25cIix0eXBlOlN0cmluZ30saW50ZWdlck9ubHk6e2RlZmF1bHQ6ITEsdHlwZTpCb29sZWFufX0sbWV0aG9kczp7Y2xlYXJUaW1lcjpmdW5jdGlvbigpe3RoaXMudGltZXImJihjbGVhckludGVydmFsKHRoaXMudGltZXIpLHRoaXMudGltZXI9bnVsbCl9LHdoaWxlTW91c2VEb3duOmZ1bmN0aW9uKGUpe251bGw9PT10aGlzLnRpbWVyJiYodGhpcy50aW1lcj1zZXRJbnRlcnZhbChmdW5jdGlvbigpe2UoKX0sdGhpcy5tb3VzZURvd25TcGVlZCkpfSxpbmNyZWFzZU51bWJlcjpmdW5jdGlvbigpe3RoaXMubnVtZXJpY1ZhbHVlKz10aGlzLnN0ZXB9LGRlY3JlYXNlTnVtYmVyOmZ1bmN0aW9uKCl7dGhpcy5udW1lcmljVmFsdWUtPXRoaXMuc3RlcH0saXNJbnRlZ2VyOmZ1bmN0aW9uKGUpe2U9ZXx8d2luZG93LmV2ZW50O3ZhciBuPWUua2V5Q29kZXx8ZS53aGljaDtuPVN0cmluZy5mcm9tQ2hhckNvZGUobiksL1swLTldLy50ZXN0KG4pfHwoZS5yZXR1cm5WYWx1ZT0hMSxlLnByZXZlbnREZWZhdWx0JiZlLnByZXZlbnREZWZhdWx0KCkpfSxpc051bWJlcjpmdW5jdGlvbihlKXtlPWV8fHdpbmRvdy5ldmVudDt2YXIgbj1lLndoaWNoP2Uud2hpY2g6ZS5rZXlDb2RlO2lmKCEobj4zMSYmKG48NDh8fG4+NTcpJiY0NiE9PW4pKXJldHVybiEwO2UucHJldmVudERlZmF1bHQoKX0sdmFsaWRhdGVJbnB1dDpmdW5jdGlvbihlKXshMD09PXRoaXMuaW50ZWdlck9ubHk/dGhpcy5pc0ludGVnZXIoZSk6dGhpcy5pc051bWJlcihlKX0saW5wdXRWYWx1ZTpmdW5jdGlvbihlKXt0aGlzLm51bWVyaWNWYWx1ZT1lLnRhcmdldC52YWx1ZT9wYXJzZUludChlLnRhcmdldC52YWx1ZSk6dGhpcy5taW59fSx3YXRjaDp7bnVtZXJpY1ZhbHVlOmZ1bmN0aW9uKGUsbil7ZTw9dGhpcy5taW4mJih0aGlzLm51bWVyaWNWYWx1ZT1wYXJzZUludCh0aGlzLm1pbikpLGU+PXRoaXMubWF4JiYodGhpcy5udW1lcmljVmFsdWU9cGFyc2VJbnQodGhpcy5tYXgpKSxlPD10aGlzLm1heCYmZT49dGhpcy5taW4mJnRoaXMuJGVtaXQoXCJpbnB1dFwiLGUsbil9fX19LGZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsbix0LHIsaSl7dmFyIG8scz1lPWV8fHt9LHU9dHlwZW9mIGUuZGVmYXVsdDtcIm9iamVjdFwiIT09dSYmXCJmdW5jdGlvblwiIT09dXx8KG89ZSxzPWUuZGVmYXVsdCk7dmFyIGE9XCJmdW5jdGlvblwiPT10eXBlb2Ygcz9zLm9wdGlvbnM6cztuJiYoYS5yZW5kZXI9bi5yZW5kZXIsYS5zdGF0aWNSZW5kZXJGbnM9bi5zdGF0aWNSZW5kZXJGbnMpLHImJihhLl9zY29wZUlkPXIpO3ZhciBjO2lmKGk/KGM9ZnVuY3Rpb24oZSl7ZT1lfHx0aGlzLiR2bm9kZSYmdGhpcy4kdm5vZGUuc3NyQ29udGV4dHx8dGhpcy5wYXJlbnQmJnRoaXMucGFyZW50LiR2bm9kZSYmdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQsZXx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX198fChlPV9fVlVFX1NTUl9DT05URVhUX18pLHQmJnQuY2FsbCh0aGlzLGUpLGUmJmUuX3JlZ2lzdGVyZWRDb21wb25lbnRzJiZlLl9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQoaSl9LGEuX3NzclJlZ2lzdGVyPWMpOnQmJihjPXQpLGMpe3ZhciBwPWEuZnVuY3Rpb25hbCxsPXA/YS5yZW5kZXI6YS5iZWZvcmVDcmVhdGU7cD9hLnJlbmRlcj1mdW5jdGlvbihlLG4pe3JldHVybiBjLmNhbGwobiksbChlLG4pfTphLmJlZm9yZUNyZWF0ZT1sP1tdLmNvbmNhdChsLGMpOltjXX1yZXR1cm57ZXNNb2R1bGU6byxleHBvcnRzOnMsb3B0aW9uczphfX19LGZ1bmN0aW9uKGUsbix0KXtlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbigpe3ZhciBlPXRoaXMsbj1lLiRjcmVhdGVFbGVtZW50LHQ9ZS5fc2VsZi5fY3x8bjtyZXR1cm4gdChcImRpdlwiLHtzdGF0aWNDbGFzczpcInZuaXNcIn0sW3QoXCJidXR0b25cIix7Y2xhc3M6ZS5idXR0b25DbGFzcyxvbjp7Y2xpY2s6ZS5kZWNyZWFzZU51bWJlcixtb3VzZWRvd246ZnVuY3Rpb24obil7ZS53aGlsZU1vdXNlRG93bihlLmRlY3JlYXNlTnVtYmVyKX0sbW91c2V1cDplLmNsZWFyVGltZXJ9fSxbZS5fdihcIi1cIildKSxlLl92KFwiIFwiKSx0KFwiaW5wdXRcIix7Y2xhc3M6ZS5pbnB1dENsYXNzLGF0dHJzOnt0eXBlOlwibnVtYmVyXCIsbWluOmUubWluLG1heDplLm1heCxkZWJvdW5jZTpcIjUwMFwifSxkb21Qcm9wczp7dmFsdWU6ZS5udW1lcmljVmFsdWV9LG9uOntrZXlwcmVzczplLnZhbGlkYXRlSW5wdXQsaW5wdXQ6ZS5pbnB1dFZhbHVlfX0pLGUuX3YoXCIgXCIpLHQoXCJidXR0b25cIix7Y2xhc3M6ZS5idXR0b25DbGFzcyxvbjp7Y2xpY2s6ZS5pbmNyZWFzZU51bWJlcixtb3VzZWRvd246ZnVuY3Rpb24obil7ZS53aGlsZU1vdXNlRG93bihlLmluY3JlYXNlTnVtYmVyKX0sbW91c2V1cDplLmNsZWFyVGltZXJ9fSxbZS5fdihcIitcIildKV0pfSxzdGF0aWNSZW5kZXJGbnM6W119LGUuZXhwb3J0cy5yZW5kZXIuX3dpdGhTdHJpcHBlZD0hMH0sZnVuY3Rpb24oZSxuLHQpe3ZhciByPXQoNCk7XCJzdHJpbmdcIj09dHlwZW9mIHImJihyPVtbZS5pLHIsXCJcIl1dKSxyLmxvY2FscyYmKGUuZXhwb3J0cz1yLmxvY2Fscyk7dCg3KShcIjM4Y2U3MTQ4XCIsciwhMSl9LGZ1bmN0aW9uKGUsbix0KXtuPWUuZXhwb3J0cz10KDUpKHZvaWQgMCksbi5wdXNoKFtlLmksXCJcXG4udm5pcyAqLFxcbi52bmlzICo6OmFmdGVyLFxcbi52bmlzICo6OmJlZm9yZSB7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG4udm5pc19faW5wdXQge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2ViZWJlYjtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgbWFyZ2luOiAwO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHdpZHRoOiBjYWxjKDEwMCUgLSA4MHB4KTtcXG59XFxuLnZuaXNfX2lucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLCAudm5pc19faW5wdXQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi52bmlzX19idXR0b24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAwLjVzIGVhc2U7XFxuICBiYWNrZ3JvdW5kOiAjMzg3ZTkwO1xcbiAgYm9yZGVyOiAwO1xcbiAgY29sb3I6ICNmZmY7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBmbG9hdDogbGVmdDtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGhlaWdodDogNDBweDtcXG4gIG1hcmdpbjogMDtcXG4gIHdpZHRoOiA0MHB4O1xcbn1cXG4udm5pc19fYnV0dG9uOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogIzQ2OWViNTtcXG59XFxuLnZuaXNfX2J1dHRvbjpmb2N1cyB7XFxuICAgIG91dGxpbmU6IDFweCBkYXNoZWQgIzY5YjJjNTtcXG4gICAgb3V0bGluZS1vZmZzZXQ6IC01cHg7XFxufVxcblwiLFwiXCJdKX0sZnVuY3Rpb24oZSxuKXtmdW5jdGlvbiB0KGUsbil7dmFyIHQ9ZVsxXXx8XCJcIixpPWVbM107aWYoIWkpcmV0dXJuIHQ7aWYobiYmXCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYSl7dmFyIG89cihpKTtyZXR1cm5bdF0uY29uY2F0KGkuc291cmNlcy5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuXCIvKiMgc291cmNlVVJMPVwiK2kuc291cmNlUm9vdCtlK1wiICovXCJ9KSkuY29uY2F0KFtvXSkuam9pbihcIlxcblwiKX1yZXR1cm5bdF0uam9pbihcIlxcblwiKX1mdW5jdGlvbiByKGUpe3JldHVyblwiLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGUpKSkpK1wiICovXCJ9ZS5leHBvcnRzPWZ1bmN0aW9uKGUpe3ZhciBuPVtdO3JldHVybiBuLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG4pe3ZhciByPXQobixlKTtyZXR1cm4gblsyXT9cIkBtZWRpYSBcIituWzJdK1wie1wiK3IrXCJ9XCI6cn0pLmpvaW4oXCJcIil9LG4uaT1mdW5jdGlvbihlLHQpe1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1bW251bGwsZSxcIlwiXV0pO2Zvcih2YXIgcj17fSxpPTA7aTx0aGlzLmxlbmd0aDtpKyspe3ZhciBvPXRoaXNbaV1bMF07XCJudW1iZXJcIj09dHlwZW9mIG8mJihyW29dPSEwKX1mb3IoaT0wO2k8ZS5sZW5ndGg7aSsrKXt2YXIgcz1lW2ldO1wibnVtYmVyXCI9PXR5cGVvZiBzWzBdJiZyW3NbMF1dfHwodCYmIXNbMl0/c1syXT10OnQmJihzWzJdPVwiKFwiK3NbMl0rXCIpIGFuZCAoXCIrdCtcIilcIiksbi5wdXNoKHMpKX19LG59fSxmdW5jdGlvbihlLG4sdCl7ZnVuY3Rpb24gcihlKXtpfHx0KDMpfXZhciBpPSExLG89dCgxKSh0KDApLHQoMikscixudWxsLG51bGwpO28ub3B0aW9ucy5fX2ZpbGU9XCIvVXNlcnMva3J5c3RhbGNhbXBpb25pL3JlcG9zL3Z1ZS1udW1iZXItaW5wdXQtc3Bpbm5lci9zcmMvY29tcG9uZW50cy9OdW1iZXJJbnB1dFNwaW5uZXIudnVlXCIsby5lc01vZHVsZSYmT2JqZWN0LmtleXMoby5lc01vZHVsZSkuc29tZShmdW5jdGlvbihlKXtyZXR1cm5cImRlZmF1bHRcIiE9PWUmJlwiX19cIiE9PWUuc3Vic3RyKDAsMil9KSxvLm9wdGlvbnMuZnVuY3Rpb25hbCxlLmV4cG9ydHM9by5leHBvcnRzfSxmdW5jdGlvbihlLG4sdCl7ZnVuY3Rpb24gcihlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIHQ9ZVtuXSxyPXBbdC5pZF07aWYocil7ci5yZWZzKys7Zm9yKHZhciBpPTA7aTxyLnBhcnRzLmxlbmd0aDtpKyspci5wYXJ0c1tpXSh0LnBhcnRzW2ldKTtmb3IoO2k8dC5wYXJ0cy5sZW5ndGg7aSsrKXIucGFydHMucHVzaChvKHQucGFydHNbaV0pKTtyLnBhcnRzLmxlbmd0aD50LnBhcnRzLmxlbmd0aCYmKHIucGFydHMubGVuZ3RoPXQucGFydHMubGVuZ3RoKX1lbHNle2Zvcih2YXIgcz1bXSxpPTA7aTx0LnBhcnRzLmxlbmd0aDtpKyspcy5wdXNoKG8odC5wYXJ0c1tpXSkpO3BbdC5pZF09e2lkOnQuaWQscmVmczoxLHBhcnRzOnN9fX19ZnVuY3Rpb24gaSgpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtyZXR1cm4gZS50eXBlPVwidGV4dC9jc3NcIixsLmFwcGVuZENoaWxkKGUpLGV9ZnVuY3Rpb24gbyhlKXt2YXIgbix0LHI9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicrZS5pZCsnXCJdJyk7aWYocil7aWYobSlyZXR1cm4gaDtyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocil9aWYodil7dmFyIG89ZCsrO3I9Znx8KGY9aSgpKSxuPXMuYmluZChudWxsLHIsbywhMSksdD1zLmJpbmQobnVsbCxyLG8sITApfWVsc2Ugcj1pKCksbj11LmJpbmQobnVsbCxyKSx0PWZ1bmN0aW9uKCl7ci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHIpfTtyZXR1cm4gbihlKSxmdW5jdGlvbihyKXtpZihyKXtpZihyLmNzcz09PWUuY3NzJiZyLm1lZGlhPT09ZS5tZWRpYSYmci5zb3VyY2VNYXA9PT1lLnNvdXJjZU1hcClyZXR1cm47bihlPXIpfWVsc2UgdCgpfX1mdW5jdGlvbiBzKGUsbix0LHIpe3ZhciBpPXQ/XCJcIjpyLmNzcztpZihlLnN0eWxlU2hlZXQpZS5zdHlsZVNoZWV0LmNzc1RleHQ9YihuLGkpO2Vsc2V7dmFyIG89ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaSkscz1lLmNoaWxkTm9kZXM7c1tuXSYmZS5yZW1vdmVDaGlsZChzW25dKSxzLmxlbmd0aD9lLmluc2VydEJlZm9yZShvLHNbbl0pOmUuYXBwZW5kQ2hpbGQobyl9fWZ1bmN0aW9uIHUoZSxuKXt2YXIgdD1uLmNzcyxyPW4ubWVkaWEsaT1uLnNvdXJjZU1hcDtpZihyJiZlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsciksaSYmKHQrPVwiXFxuLyojIHNvdXJjZVVSTD1cIitpLnNvdXJjZXNbMF0rXCIgKi9cIix0Kz1cIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoaSkpKSkrXCIgKi9cIiksZS5zdHlsZVNoZWV0KWUuc3R5bGVTaGVldC5jc3NUZXh0PXQ7ZWxzZXtmb3IoO2UuZmlyc3RDaGlsZDspZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpO2UuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodCkpfX12YXIgYT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIERFQlVHJiZERUJVRyYmIWEpdGhyb3cgbmV3IEVycm9yKFwidnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiKTt2YXIgYz10KDgpLHA9e30sbD1hJiYoZG9jdW1lbnQuaGVhZHx8ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdKSxmPW51bGwsZD0wLG09ITEsaD1mdW5jdGlvbigpe30sdj1cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiYvbXNpZSBbNi05XVxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO2UuZXhwb3J0cz1mdW5jdGlvbihlLG4sdCl7bT10O3ZhciBpPWMoZSxuKTtyZXR1cm4gcihpKSxmdW5jdGlvbihuKXtmb3IodmFyIHQ9W10sbz0wO288aS5sZW5ndGg7bysrKXt2YXIgcz1pW29dLHU9cFtzLmlkXTt1LnJlZnMtLSx0LnB1c2godSl9bj8oaT1jKGUsbikscihpKSk6aT1bXTtmb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIHU9dFtvXTtpZigwPT09dS5yZWZzKXtmb3IodmFyIGE9MDthPHUucGFydHMubGVuZ3RoO2ErKyl1LnBhcnRzW2FdKCk7ZGVsZXRlIHBbdS5pZF19fX19O3ZhciBiPWZ1bmN0aW9uKCl7dmFyIGU9W107cmV0dXJuIGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGVbbl09dCxlLmZpbHRlcihCb29sZWFuKS5qb2luKFwiXFxuXCIpfX0oKX0sZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9ZnVuY3Rpb24oZSxuKXtmb3IodmFyIHQ9W10scj17fSxpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciBvPW5baV0scz1vWzBdLHU9b1sxXSxhPW9bMl0sYz1vWzNdLHA9e2lkOmUrXCI6XCIraSxjc3M6dSxtZWRpYTphLHNvdXJjZU1hcDpjfTtyW3NdP3Jbc10ucGFydHMucHVzaChwKTp0LnB1c2gocltzXT17aWQ6cyxwYXJ0czpbcF19KX1yZXR1cm4gdH19XSl9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZ1ZS1udW1iZXItaW5wdXQtc3Bpbm5lci5taW4uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-number-input-spinner/dist/vue-number-input-spinner.min.js\n");

/***/ })

}]);